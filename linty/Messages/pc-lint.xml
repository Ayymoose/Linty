<doc>
    <m id="1">
        <c>End of file was reached with an open comment still unclosed.</c>
    </m>
    <m id="2">
        <c>An end of line was reached and a matching quote character (single or double) to an earlier quote character on the same line was not found.</c>
    </m>
    <m id="3">
        <c>A #elif was encountered not in the scope of a #if, #ifdef or #ifndef.</c>
    </m>
    <m id="5">
        <c>A #endif was encountered not in the scope of a #if or #ifdef or #ifndef.</c>
    </m>
    <m id="8">
        <c>A #if (or #ifdef or #ifndef) was encountered without a corresponding #endif.</c>
    </m>
    <m id="9">
        <c>A given #if contained a #else, which in turn was followed by either
another #else or a #elif. The error message gives the line of the #if
statement that started the conditional that contained the aberration.</c>
    </m>
    <m id="10">
        <c>The expected token (provided in detail) could not be found. For example:

    void foo(int, int);
    void bar() {
        foo(1, 2;
    }

will yield the error:

    error 10: expecting &apos;)&apos;
        foo(1, 2;
                ^
    supplemental 891: to match this &apos;(&apos;
        foo(1, 2;
           ^

due to the missing closing parenthesis at the end of the function call.</c>
    </m>
    <m id="12">
        <c>After a #include is detected and after macro substitution is performed,
a file specification of the form &lt;filename&gt; or &quot;filename&quot; is expected.</c>
    </m>
    <m id="13">
        <c>A type adjective such as long, unsigned, etc. cannot be applied to the
type, which follows.</c>
    </m>
    <m id="15">
        <c>The named symbol has been previously declared or defined in some other
module (location given) with a type different from the type given by the
declaration at the current location. The parenthesized type parameters
provide the two differing types.</c>
    </m>
    <m id="16">
        <c>A # directive is not followed by a recognizable word. If this is not an
error, use the +ppw option. (Section &quot;Compiler Adaptation&quot; in the
Reference Manual).</c>
    </m>
    <m id="18">
        <c>A symbol is being redeclared. The parameter typediff provides further
information on how the types differ.</c>
    </m>
    <m id="19">
        <c>A name appeared by itself without an associated type in what appears to
be a declaration, e.g.:

    x;

In C, this is a declaration of x with an implicit int type and warning
601 would be issued. In C++ this is illegal as the type must be
explicit.</c>
    </m>
    <m id="21">
        <c>An initializer for an indefinite size array must begin with a left brace.</c>
    </m>
    <m id="24">
        <c>An operator was found at the start of an expression but it was not a unary operator.</c>
    </m>
    <m id="25">
        <c>Too many characters were encountered in a character constant (a constant bounded by &apos; marks).</c>
    </m>
    <m id="29">
        <c>This message is issued in C90 mode when a type specifier is duplicated
within a declaration. For example:

    const const int i = 0;

will result in message 29 when in C90 mode, which forbids duplicate
specifiers. In C99 and later, duplicate specifiers are ignored and such
a construct will instead be greeted with warning 2435.</c>
    </m>
    <m id="31">
        <c>A data object or function previously defined in this module is being
redefined.</c>
    </m>
    <m id="32">
        <c>The length of a field was given as non-positive, (0 or negative).</c>
    </m>
    <m id="33">
        <c>A constant was badly formed as when an octal constant contains one of
the digits 8 or 9.</c>
    </m>
    <m id="34">
        <c>A non-constant initializer was found for a static data item.</c>
    </m>
    <m id="35">
        <c>An initializer with side effects was found for a static data item.</c>
    </m>
    <m id="40">
        <c>Within an expression, an identifier was encountered that had not
previously been declared and was not followed by a left parenthesis.</c>
    </m>
    <m id="44">
        <c>A case or default statement occurred outside a switch.</c>
    </m>
    <m id="47">
        <c>Unary minus requires an arithmetic operand.</c>
    </m>
    <m id="48">
        <c>Unary * or the left hand side of the ptr (-&gt;) operator requires a
pointer operand.</c>
    </m>
    <m id="50">
        <c>Unary &amp; operator requires an lvalue (a value suitable for placement on
the left hand side of an assignment operator).</c>
    </m>
    <m id="51">
        <c>Unary ~ expects an integral type (signed or unsigned char, short, int,
or long).</c>
    </m>
    <m id="52">
        <c>The autodecrement (--) and autoincrement (++) operators require an
lvalue (a value suitable for placement on the left hand side of an
assignment operator). Remember that casts do not normally produce
lvalues. Thus

    ++(char *)p;

is illegal according to the ANSI/ISO standard. This construct is allowed
by some compilers and is allowed if you use the +fpc option (Pointer
Casts are lvalues). (See Section &quot;Flag-Options&quot; in the Reference Manual)</c>
    </m>
    <m id="53">
        <c>Autodecrement (--) and autoincrement (++) operators may be applied only
to scalars (arithmetics and pointers) or to objects for which these
operators have been defined.</c>
    </m>
    <m id="54">
        <c>The constant 0 was used on the right hand side of the division operator
(/) or the remainder operator (%).</c>
    </m>
    <m id="56">
        <c>Add/subtract operator requires scalar types and pointers may not be
added to pointers.</c>
    </m>
    <m id="57">
        <c>Bit operators ( &amp;, | and ^ ) require integral arguments.</c>
    </m>
    <m id="59">
        <c>The amount by which an item can be shifted must be integral.</c>
    </m>
    <m id="60">
        <c>The value to be shifted must be integral.</c>
    </m>
    <m id="64">
        <c>There was a mismatch in types across an assignment. typediff specifies
the type difference.</c>
    </m>
    <m id="66">
        <c>A void type was employed where it is not permitted. If a void type is
placed in a prototype then it must be the only type within a prototype.</c>
    </m>
    <m id="72">
        <c>An unrecognized or invalid option was encountered on the command line,
in the LINT environment variable, in an indirect file, or in a lint
comment. The option parameter contains the offending option and detail
provides additional information about the issue.</c>
    </m>
    <m id="76">
        <c>file is the name of the file. The named file could not be opened for
output. detail contains information about the failure. This error is
issued when PC-lint Plus is directed to write to a file with the options
-oe/+oe, -os/+os, -write_file, or +stack but it unable to open the
specified file for writing.</c>
    </m>
    <m id="82">
        <c>The expression form of a return statement was used in a function that
was declared as returning void, e.g.:

    void foo() {
        return 1;  // Error 82
    }

Note that the ANSI/ISO C standard does not allow the expression form of
a return statement in a function that returns void, even when the
provided expression has void type. For example:

    void foo_v();
    int foo_i();

    void bar(int x) {
        if (x) return foo_v();          // Error 82
        else return (void) foo_i();     // Error 82
    }

If your compiler supports the latter case, you may safely suppress this
message in such situations.</c>
    </m>
    <m id="83">
        <c>Two pointers being subtracted have indirect types that differ.</c>
    </m>
    <m id="85">
        <c>An array (named symbol) was declared without a dimension in a context
that required a non-zero dimension.</c>
    </m>
    <m id="86">
        <c>A structure was declared (in a C module) that had no data members.
Though legal in C++ this is not legal C.</c>
    </m>
    <m id="92">
        <c>A negative array dimension or bit field length is not permitted.</c>
    </m>
    <m id="95">
        <c>The # operator was found within a macro definition but was not
immediately followed by a parameter of the macro as is required by the
standards.</c>
    </m>
    <m id="104">
        <c>Two consecutive conflicting types were found such as int followed by
double. Remove one of the types.</c>
    </m>
    <m id="106">
        <c>A string constant was found within a preprocessor expression as in

    #if ABC == &quot;abc&quot;

Such expressions should be integral expressions.</c>
    </m>
    <m id="107">
        <c>The name appeared in a goto but there was no corresponding label.</c>
    </m>
    <m id="108">
        <c>A continue or break statement was encountered without an appropriate
surrounding context such as a for, while, or do loop or, for the break
statement only, a surrounding switch statement.</c>
    </m>
    <m id="111">
        <c>An object declared as const was assigned a value. This could arise via
indirection. For example, if p is a pointer to a const int then
assigning to *p will raise this error.</c>
    </m>
    <m id="115">
        <c>A reference to a structure or a union was made that required a
definition and there is no definition in scope. For example, a reference
to p-&gt;a where p is a pointer to a struct that had not yet been defined
in the current module.</c>
    </m>
    <m id="116">
        <c>A storage class other than register was given in a section of code that
is dedicated to declaring parameters. The section is that part of a
function preceding the first left brace.</c>
    </m>
    <m id="117">
        <c>A storage class (indicated as either auto or register) was provided
outside any function. Such storage classes are appropriate only within
functions.</c>
    </m>
    <m id="118">
        <c>The number of arguments provided for a function was less than the number
indicated by a prototype in scope.</c>
    </m>
    <m id="119">
        <c>The number of arguments provided for a function was greater than the
number indicated by a prototype in scope.</c>
    </m>
    <m id="124">
        <c>A pointer to void was used in a context that does not permit void. This
includes subtraction, addition and the relationals (&gt; &gt;= &lt; &lt;=).</c>
    </m>
    <m id="128">
        <c>A pointer to a function was found in an arithmetic context such as
subtraction, addition, or one of the relationals (&gt; &gt;= &lt; &lt;=).</c>
    </m>
    <m id="130">
        <c>The expression in a switch statement must be some variation of an int
(possibly long or unsigned) or an enum.</c>
    </m>
    <m id="131">
        <c>This message is issued when a macro with arguments (function-like macro)
is invoked and an incorrect number of arguments is provided.</c>
    </m>
    <m id="132">
        <c>A function declaration with identifiers between parentheses is the start
of an old-style function definition (K&amp;R style). This is normally
followed by optional declarations and a left brace to signal the start
of the function body. Either replace the identifier(s) with type(s) or
complete the function with a function body.</c>
    </m>
    <m id="136">
        <c>The ANSI/ISO standard restricts the use of certain names as macros.
defined is on the restricted list.</c>
    </m>
    <m id="138">
        <c>An attempt was made to add a strong type parent to a typedef type. The
attempt is either explicit (with the -strong option) or implicit with
the use of a typedef to a known strong type. This attempt would have
caused a loop in the strong parent relationship. Such loops are simply
not tolerated.</c>
    </m>
    <m id="139">
        <c>There is an attempt to take the sizeof a function.</c>
    </m>
    <m id="148">
        <c>The indicated member was previously declared within the same structure
or union. Although a redeclaration of a function may appear benign it is
just not permitted by the rules of the language. One of the declarations
should be removed.</c>
    </m>
    <m id="157">
        <c>An incomplete array is allowed within a struct of a C99 or C++ program
but no data is allowed to appear after this array. For example

    struct A { int x; int a[]; int b; };

This diagnostic is issued when the &apos;b&apos; is seen.</c>
    </m>
    <m id="160">
        <c>PC-lint Plus encountered the sequence &apos;({&apos; in a context where an
expression (possibly a sub-expression) is expected. For example:

    int n = ({   //Error 160 here
          int y = foo ();
          int z;
          if (y &gt; 0)
              z = y;
          else z = - y;
          z; })
          // Now n has the last value of z.

In addition to being a non-standard GNU extension, there are some
caveats described in the GCC documentation (especially when used in C++)
that can lead to subtle bugs. Programmers who intend to work only with C
code with the GNU extensions may safely disable this diagnostic.</c>
    </m>
    <m id="161">
        <c>The name of a function parameter was repeated. For example:

    void f( int n, int m, int n ) {}

will cause this message to be issued. Names of parameters for a given
function must all be different.</c>
    </m>
    <m id="175">
        <c>An initializer list or an expression of a type that cannot be passed as
a variadic function argument was given as the argument to a printf/scanf
style function. The string parameter specifies the type of the argument
passed, the type parameter specifies the type that was expected from the
format string.</c>
    </m>
    <m id="176">
        <c>An attempt was made to perform an illegal cast from a type (such as a
float) to a function pointer for which such conversion is undefined.</c>
    </m>
    <m id="177">
        <c>An attempt was made to perform an illegal cast from a type (such as a
float) to an object pointer for which such conversion is undefined.</c>
    </m>
    <m id="178">
        <c>An attempt was made to perform an illegal cast from a function pointer
to a type (such as a float) for which such conversion is undefined.</c>
    </m>
    <m id="179">
        <c>An attempt was made to perform an illegal cast from an object pointer to
a type (such as a float) for which such conversion is undefined.</c>
    </m>
    <m id="180">
        <c>Name mangling refers to the process of taking the declared name of a
symbol and producing a new name which additionally incorporates
information about the symbol, for example its type, return types,
parameter types, enclosing classes or namespaces, etc. Typical compilers
and linkers use mangled names to implement function overloading and to
uniformly refer to and disambiguate external entities.
When certain combinations of compiler extensions are mixed in a manner
that does not conform to the language standard, situations may arise
where it is not possible to systematically construct a mangled name to
allow an entity to be cross-referenced between translation units. This
message is parameterized by the category of grammatical entity for which
mangling failed.</c>
    </m>
    <m id="305">
        <c>The module specified in the file parameter could not be opened for
reading, perhaps because it does not exist where PC-lint Plus expected
to find it. If the module is not in the directory from which PC-lint
Plus was invoked, it will be searched for in the directories specified
by any -i options. If the file exists in a directory not being searched,
a -i option can be used to cause PC-lint Plus to search the appropriate
directory.</c>
    </m>
    <m id="307">
        <c>The indirect file specified in the file parameter could not be opened
for reading, perhaps because it does not exist where PC-lint Plus
expected to find it. If the file is not in the directory from which
PC-lint Plus was invoked, it will be searched for in the directories
specified by any -i options. If the file exists in a directory not being
searched, a -i option can be used to cause PC-lint Plus to search the
appropriate directory.</c>
    </m>
    <m id="308">
        <c>stdout was found to equal NULL. This is most unusual.</c>
    </m>
    <m id="309">
        <c>The #error directive was encountered. This error is fatal by default,
but can be bypassed using the fce flag.</c>
    </m>
    <m id="311">
        <c>The indirect (.lnt) file nesting depth has reached an internal limit
(the current limit is 100). The most likely cause of this error is
unintended recursion between indirect files.</c>
    </m>
    <m id="314">
        <c>The indirect file named was previously encountered. If this was not an
accident, you may suppress this message.</c>
    </m>
    <m id="315">
        <c>The maximum number of messages specified using the -limit option was
exceeded.</c>
    </m>
    <m id="318">
        <c>The end of a module was encountered while processing the argument list
of a macro invocation.</c>
    </m>
    <m id="319">
        <c>A fatal inconsistency in the sizes of the fundamental data types was
introduced by use of the size options. The -s option allows for
configuration of the sizes of the fundamental data types. If these
options are used to specify sizes that violate the basic tenets of the
language, this message will be issued. Such an example would include
specifying a byte size for short int that is larger than int.</c>
    </m>
    <m id="322">
        <c>file is the name of the include file, which could not be opened.
Directory search is controlled by options: -i, +fdi, +fsi and the
INCLUDE environment variable (See Section &quot;INCLUDE-Environment-Variable&quot;
in the Reference Manual). This is a suppressible fatal message. If
option -e322 is used processing will continue.</c>
    </m>
    <m id="330">
        <c>This message is issued when the constant-expression of a
static-assert-declaration (either C11&apos;s _Static_assert or C++11&apos;s
static_assert) evaluates to false. If PC-lint Plus issues this error
message but the compiler does not, see whether the Lint configuration
matches the compiler configuration: consider potential differences in
pre-defined macros and include search options, and ensure that size
options match the target machine. Differences in these configuration
details could lead to differences in evaluation of the
constant-expression.</c>
    </m>
    <m id="331">
        <c>Use of the specified precompiled header was requested but was found to
contain a reference to a header file that has been updated since the
precompiled header was built. Since the precompiled header may no longer
accurately represent the state of the corresponding header file, PC-lint
Plus will terminate. To resolve the issue either rebuild the precompiled
header file or remove the option to use the pre-compiled header.</c>
    </m>
    <m id="333">
        <c>A &apos;forbidden&apos; file was opened. Opening such a file is considered a
security violation by a hosted implementation.</c>
    </m>
    <m id="334">
        <c>This message is given when the precompiled header file is missing, older
than the original file, created by a previous incompatible version of
PC-lint Plus, created using a different target configuration, or another
issue that prevents the file from being loaded. The PCH file will be
skipped. If this error is encountered, the PCH file should be deleted
and reconstituted using the current version of PC-lint Plus with the
same options that will be used when loading the file.</c>
    </m>
    <m id="336">
        <c>Source files are expected to be encoded as UTF-8 text or UTF-16 text.
The provided source file was presumed to contain UTF-8 text but an
invalid byte sequence was encountered.</c>
    </m>
    <m id="337">
        <c>This message is given when the internal file information inside the
precompiled header does not match its contents.</c>
    </m>
    <m id="338">
        <c>This error indicates that there was an inconsistency in the way the
precompiled header file was created and the way it is being used that
prevents it from being loaded. The details of the issue are provided in
the message text.</c>
    </m>
    <m id="339">
        <c>Precompiled header file creation was requested but an error occurred
during the processing of a precompiled header candidate file that
rendered the corresponding AST information unsuitable for use in a
precompiled header file.</c>
    </m>
    <m id="365">
        <c>An error has occurred while processing a request related to a command
pipe program. The details of the error are specified in the message in
&apos;string&apos;.</c>
    </m>
    <m id="366">
        <c>An invalid regular expression has been used with the -cond option. The
specific error is provided in &apos;string&apos;.</c>
    </m>
    <m id="367">
        <c>A limit has been reached on the number of recursively executing hooks.
The limit that was reached is specified by &apos;integer&apos;.</c>
    </m>
    <m id="368">
        <c>An invalid conditional expression has been provided to the -cond option.
The specific error is provided in the text of the message.</c>
    </m>
    <m id="369">
        <c>An invalid field name was provided in a hook field specifier or an AST
walk action was attempted on a non-walkable hook field.</c>
    </m>
    <m id="370">
        <c>An attempt was made to process a new module from within the module being
processed. For example, a lint comment might contain an -indirect option
resulting in the processing of options from a .lnt file. If this
indirect file contains the name of a module to process, the module will
not be opened and this message will be issued instead. Processing will
then continue normally for the current module.</c>
    </m>
    <m id="373">
        <c>A lint comment appeared on the same line as an #include directive. Such
usage is not currently supported and the lint comment will be ignored.
Either place the lint comment before the #include directive, on the next
line, or inside the file being included.</c>
    </m>
    <m id="398">
        <c>A suppressible fatal error was requested through the use of the option
-fatal_error. See also 399.</c>
    </m>
    <m id="399">
        <c>An unsuppressible fatal error was requested through the use of the
option +fatal_error. See also 398.</c>
    </m>
    <m id="401">
        <c>The indicated symbol declared static was previously declared without the
static storage class. This is technically a violation of the ANSI/ISO
standard. Some compilers will accept this situation without complaint
and regard the symbol as static.</c>
    </m>
    <m id="402">
        <c>The named symbol was declared as a static function in the current module
and was referenced but was not defined (in the module).</c>
    </m>
    <m id="404">
        <c>A struct (or union or enum) definition was started within a header file
but was not completed within the same header file.</c>
    </m>
    <m id="407">
        <c>A tag specified as a union, struct or enum was respecified as being one
of the other two in the same module. For example:

    struct tag *p;
    union tag *q;

will elicit this message.</c>
    </m>
    <m id="408">
        <c>The expression within a case does not agree exactly with the type within
the switch expression. For example, an enumerated type is matched
against an int.</c>
    </m>
    <m id="409">
        <c>An expression of the form i[...] was encountered where i is an integral
expression. This could be legitimate depending on the subscript operand.
For example, if i is an int and a is an array then i[a] is legitimate
but unusual. If this is your coding style, suppress this message.</c>
    </m>
    <m id="410">
        <c>This warning is issued if you had previously attempted to set the type
of sizeof by use of the options +fzl, -fzl, or -fzu, and a later size_t
declaration contradicts the setting. This usually means you are
attempting to lint programs for another system using header files for
your own system. If this is the case we suggest you create a directory
housing header files for that foreign system, alter size_t within that
directory, and lint using that directory.</c>
    </m>
    <m id="411">
        <c>This warning is issued if you had previously attempted to set the type
of pointer differences by use of the fdl option and a later ptrdiff_t
declaration contradicts the setting. See suggestion in Error Message
410.</c>
    </m>
    <m id="413">
        <c>From information gleaned from earlier statements, it appears likely that
a null pointer (a pointer whose value is 0) has been used in a context
where null pointers are inappropriate. Information leading to this
determination is provided as a series of supplemental messages. See also
message 613.</c>
    </m>
    <m id="414">
        <c>The second argument to either the division operator (/) or the modulus
operator (%) may be zero. Information is taken from earlier statements
including assignments, initialization and tests. See Chapter &quot;Value
Tracking&quot; in the Reference Manual.</c>
    </m>
    <m id="415">
        <c>An out-of-bounds pointer was likely accessed. The parameter integer
gives some idea how far out of bounds the pointer may be, measured in
bytes. For example:

    int a[10];
    a[10] = 0;

results in a message containing the phrase &apos;excess of 4 bytes&apos; if the
size of int is 4. See Chapter &quot;Value Tracking&quot; in the Reference Manual.</c>
    </m>
    <m id="416">
        <c>An out-of-bounds pointer was created. See message 415 for a description
of the integer parameter. integer and string. For example:

    int a[10];
       ...
    f( a + 11 );

Here, an illicit pointer value is created and is flagged as such by
PC-lint Plus. Note that the pointer a+10 is not considered by PC-lint
Plus to be the creation of an out-of-bounds pointer. This is because
ANSI/ISO C explicitly allows pointing just beyond an array. Access
through a+10, however, as in *(a+10) or the more familiar a[10], would
be considered erroneous but in that case message 415 would be issued.
See Chapter &quot;Value Tracking&quot; in the Reference Manual.</c>
    </m>
    <m id="417">
        <c>The longest possible integer is by default 8 bytes (see the +fll flag
and then the -sll# option). An integral constant was found to be even
larger than such a quantity. For example: 0xFFFF0000FFFF0000F requires
68 bits and would by default elicit this message. string is the token in
error, and integer is the binary precision.</c>
    </m>
    <m id="418">
        <c>A NULL pointer is being passed to a function identified by symbol. The
argument in question is given by context. The function is either a
library function designed not to receive a NULL pointer or a user
function dubbed so via the option -function or -sem. See Section
&quot;Function-Mimicry-(-function)&quot; in the Reference Manual and Section
&quot;Possible-Semantics&quot; in the Reference Manual.</c>
    </m>
    <m id="419">
        <c>This message is for data transfer functions such as memcpy, strcpy,
fgets, etc. when the size indicated by the first cited argument (or
arguments) exceeds the size of the buffer area cited by the second. The
message may also be issued for user functions via the -function option.
See Section &quot;Function-Mimicry-(-function)&quot; in the Reference Manual and
Section &quot;Possible-Semantics&quot; in the Reference Manual.</c>
    </m>
    <m id="420">
        <c>This message is issued for several library functions (such as fwrite,
memcmp, etc.) wherein there is an apparent attempt to access more data
than exist. For example, if the length of data specified in the fwrite
call exceeds the size of the data specified. The function is specified
by symbol and the arguments are identified by argument number. See
Section &quot;Function-Mimicry-(-function)&quot; in the Reference Manual and
Section &quot;Possible-Semantics&quot; in the Reference Manual.</c>
    </m>
    <m id="421">
        <c>This message is issued (by default) for the built-in function gets. This
function is considered dangerous because there is no mechanism to ensure
that the buffer provided as first argument will not overflow. Numerous
exploits and vulnerabilities are attributed to the gets function
including the Morris worm, which exploited the use of the gets function
in the fingered program of target machines. Through the -function option
or the dangerous semantic (&quot;dangerous&quot; in the Reference Manual), the
user may designate other functions as dangerous. See also -deprecate.</c>
    </m>
    <m id="422">
        <c>An integral value that appears to be negative is being passed to a
function that is expecting only positive values for a particular
argument. The message contains the name of the function (symbol), the
questionable value (integer) and the argument number (context). The
function may be a standard library function designed to accept only
positive values such as malloc or memcpy (third argument), or may have
been identified by the user as such through the -function or -sem
options.
The negative integral value may in fact be unsigned. Thus:

    void *malloc(unsigned);
    void f() {
        int n = -1;
        int *p;
        p = malloc(n);             // warning 422
        p = malloc((unsigned)n);   // warning 422
    }

will result in the warnings indicated. Note that casting the expression
does not inhibit the warning.</c>
    </m>
    <m id="423">
        <c>An assignment was made to a pointer variable (designated by symbol),
which appeared to already be holding the address of an allocated object
that had not been freed. The allocation of memory that is not freed is
considered a memory leak.</c>
    </m>
    <m id="424">
        <c>This message indicates that a deallocation (free, delete, or delete[])
as specified by the first string parameter is inappropriate for the data
being freed.
The kind of data (specified by the second string parameter) is one or
more of: malloc, new, new[], static, auto, member, modified or constant.
These have the meanings as described below:

-   malloc: data is data obtained from a call to malloc, calloc or
    realloc.

-   new and new[]: data is data derived from calls to new.

-   static: data is either static data within a function or external
    data.

-   auto: data is non-static data in a function.

-   member: data is a component of a structure (and hence can&apos;t be
    independently freed).

-   modified: data is the result of applying pointer arithmetic to some
    other pointer. E.g.

        p = malloc(100);
        free( p+1 ); // warning

    p+1 is considered modified.

-   constant data is the result of casting a constant to a pointer. E.g.

        int *p = (int *) Ox80002;
        free(p); // warning

See also message 673.</c>
    </m>
    <m id="425">
        <c>This warning is issued when a syntax error is encountered while
processing a semantic option (-sem). The &apos;message&apos; depends upon the
error. The first &apos;string&apos; represents the portion of the semantic being
processed. The second &apos;string&apos; denotes the token being scanned when the
error is first noticed.</c>
    </m>
    <m id="426">
        <c>This warning message is issued when a user semantic (as defined by -sem)
is violated. &apos;string&apos; is the subportion of the semantic that was
violated. For example:

    //lint -sem( f, 1n &gt; 10 &amp;&amp; 2n &gt; 10 )
    void f( int, int );
    ...
        f( 2, 20 );

results in the message:

    Call to function &apos;f(int, int)&apos; violates semantic &apos;(1n&gt;10)&apos;</c>
    </m>
    <m id="427">
        <c>The line that starts a C++ style comment ends with a back-slash causing
the next line to be absorbed into the comment, which may not be the
intended behavior. If you really intend the next line to be a comment,
the line should be started with its own double slash (//) or the entire
region replaced with a block comment.</c>
    </m>
    <m id="428">
        <c>A negative integer was added to an array or to a pointer to an allocated
area (allocated by malloc, operator new, etc.) This message is not given
for pointers whose origin is unknown since a negative subscript is, in
general, legal.
The addition could have occurred as part of a subscript operation or as
part of a pointer arithmetic operation.</c>
    </m>
    <m id="429">
        <c>A pointer of auto storage class was allocated storage, which was neither
freed nor returned to the caller. This represents a &quot;memory leak&quot;. A
pointer is considered custodial if it uniquely points to the storage
area. It is not considered custodial if it has been copied. Thus:

    int *p = new int[20];   // p is a custodial pointer
    int *q = p;             // p is no longer custodial
    p = new int[20];        // p again becomes custodial
    q = p + 0;              // p remains custodial

Here p does not lose its custodial property by merely participating in
an arithmetic operation.
A pointer can lose its custodial property by passing the pointer to a
function. If the parameter of the function is typed pointer to const or
if the function is a library function, that assumption is not made. For
example

    p = malloc(10);
    strcpy (p, &quot;hello&quot;);

Then p still has custody of storage allocated.
It is possible to indicate via semantic options that a function will
take custody of a pointer. See &quot;custodiali&quot; in the Reference Manual. It
is possible to declare that no functions take custody other than those
specified in a -sem option. See also Flag ffc (Functions take custody).</c>
    </m>
    <m id="430">
        <c>Many compilers for embedded systems have a declaration syntax that
specifies a location in place of an initial value for a variable. For
example:

    int x @0x2000;

specifies that variable x is actually location 0x2000. This message is a
reminder that this syntax is non-standard (although quite common). If
you are using this syntax on purpose, suppress this message.</c>
    </m>
    <m id="432">
        <c>The following pattern was detected:

    malloc( strlen(e+1) )

where e is some expression. This is suspicious because it closely
resembles the commonly used pattern:

    malloc( strlen(e)+1 )

If you really intended to use the first pattern then an equivalent
expression that will not raise this error is:

    malloc( strlen(e)-1 )</c>
    </m>
    <m id="433">
        <c>An allocation was assigned to a pointer whose reach extends beyond the
area that was allocated. This would usually happen only with library
allocation routines such as malloc and calloc. For example:

    int *p = malloc(1);

This message is also provided for user-declared allocation functions.
For example, if a user&apos;s own allocation function is provided with the
following semantic:

    -sem(ouralloc,@P==malloc(1n))

We would report the same message. Please note that it is necessary to
designate that the returned area is freshly allocated (ala malloc).
This message is always given in conjunction with the more general
Informational Message 826.</c>
    </m>
    <m id="434">
        <c>According to the C and C++ standards, any back-slash followed
immediately by a new-line results in the deletion of both characters.
For example:

    #define A \
            34

defines A to be 34. If a blank or tab intervenes between the back-slash
and the new-line then according to a strict interpretation of the
standard you have defined A to be a back-slash followed by blank or tab.
But this blank is invisible to the naked eye and hence could lead to
confusion. Worse, some compilers silently ignore the white-space and the
program becomes non-portable.
You should never deliberately place a blank at the end of a line and any
such blanks should be removed. If you really need to define a macro to
be back-slash blank you can use a comment as in:

    #define A \  /* commentary */</c>
    </m>
    <m id="435">
        <c>An integer constant was found that had a precision that was too large
for a long but would fit within a long long. Yet the +fll flag that
enables the long long type was not set.
Check the sizes that you specified for long (-sl#) and for long long
(-sll#) and make sure they are correct. Turn on +fll if your compiler
supports long long. Otherwise use smaller constants.</c>
    </m>
    <m id="436">
        <c>A function like macro was invoked whose arguments extended for multiple
lines, which included preprocessor statements. This is almost certainly
an error brought about by a missing right parenthesis.
By the rules of the C and C++ standards, the result of this behavior is
undefined. For this reason some compilers treat the apparent
preprocessor directive as a directive. However, avoiding this construct
is recommended for portability.</c>
    </m>
    <m id="437">
        <c>A struct or class is being passed to a function at a parameter position
identified by an ellipsis. For example:

    void g() {
        struct A { int a; } x;
        void f( int, ... );
        f( 1, x );
        ...
    }

This is sufficiently unusual that it is worth pointing out in the
likelihood that this is unintended. The situation becomes more severe in
the case of a non-POD struct [10]. In this case the behavior is
considered undefined.</c>
    </m>
    <m id="438">
        <c>A value had been assigned to a variable that was not subsequently used.
The message is issued either at a return statement or at the end of a
block when the variable goes out of scope. For example, consider the
following function:

    void f( int n ) {
        int x = 0, y = 1;
        if( n &gt; 0 ) {
            int z;
            z = x + y;
            if( n &gt; z ) { x = 3; return; }
            z = 12;
        }
    }

Here we can report that x was assigned a value that had not been used by
the time the return statement had been encountered. We also report that
the most recently assigned value to z is unused at the point that z goes
out of scope. See also Informational message 838 and flags -fiw and
-fiz.</c>
    </m>
    <m id="440">
        <c>A for clause has a suspicious structure. The loop variable, as
determined by an examination of the 3rd for clause expression, does not
match the variable that is tested in the 2nd for clause expression. For
example:

    for( i = 0; i &lt; 10; j++ )
        ...

would draw this complaint since the &apos;i&apos; of the 2nd expression does not
match the &apos;j&apos; of the third expression.</c>
    </m>
    <m id="442">
        <c>A for clause was encountered that appeared to have a parity problem. For
example:

    for( i = 0; i &lt; 10; i-- )
        ...

Here the test for i less than 10 seems inconsistent with the 3rd
expression of the for clause, which decreases the value of i. This same
message would be given if i were being increased by the 3rd expression
and was being tested for being greater than some value in the 2nd
expression.</c>
    </m>
    <m id="443">
        <c>A for clause has a suspicious structure. The loop variable, as
determined by an examination of the 3rd for clause expression, does not
match the variable that is initialized in the 1st expression. For
example:

    for( ii = 0; i &lt; 10; i++ )
        ...

would draw this complaint since the &apos;ii&apos; of the 1st expression does not
match the &apos;i&apos; of the third expression.</c>
    </m>
    <m id="444">
        <c>The following kind of situation has been detected:

    for( ... ; p == NULL; p++ )
         ...

A loop variable being incremented or decremented would not normally be
checked to see if it is NULL. This is more likely a programmer error.</c>
    </m>
    <m id="445">
        <c>A for loop nested within another for loop employed the same loop
variable. For example:

    for( i = 0; i &lt; 100; i++ ) {
        for( i = 0; i &lt; n; i++ ) { ... }
    }</c>
    </m>
    <m id="446">
        <c>An initializer containing a side effect can be potentially troublesome.
For example, the code:

    void f( int i ) {
        int a[2] = {i++, i++};
     }

The values of the array elements are unspecified because the order of
evaluation is unspecified by the C standard.</c>
    </m>
    <m id="447">
        <c>A named file was found to contain either leading or trailing whitespace
in the #include directive. While legal, the ISO Standards allow
compilers to define how files are specified or the header is identified,
including the appearance of whitespace characters immediately after the
&lt; or opening &quot; or before the &gt; or closing &quot;. Since filenames tend not to
contain leading or trailing whitespace, PC-lint Plus ignores the
(apparently) extraneous characters and processes the directive as though
the characters were never given. The use of a -efile option on either
file for this message will cause Lint to process #include&apos;s with
whitespace intact.</c>
    </m>
    <m id="448">
        <c>Accessing past the terminating nul character is often an indication of a
programmer error. For example:

    char buf[20];
    strcpy( buf, &quot;a&quot; );
    char c = buf[4]; // legal but suspect

Although buf has 20 characters, after the strcpy, there would be only
two that the programmer would normally be interested in.</c>
    </m>
    <m id="449">
        <c>A pointer variable (designated in the message) was freed or deleted in
an earlier statement.</c>
    </m>
    <m id="450">
        <c>A namespace was declared either with an extern C specifier or within an
extern C region. The ISO C++ standard leaves the effects of such
unspecified. If an extern C specification is necessary for the
declarations within the namespace, it should be inside the namespace
rather than outside.</c>
    </m>
    <m id="451">
        <c>The file named in the message has already been included in the current
module. Moreover it has been determined that this header does not have a
standard include guard. A standard include guard has the form:

    #ifndef Name
    #define Name
    ...
    #endif

or

    #if !defined(X)
    #define X
    ...
    #endif

with nothing but comments before and after this sequence and nothing but
comments between the #if/#ifndef and the #define name.
This warning may also be accompanied by a 537 (repeated include header).
Message 537 is often suppressed because if you are working with include
guards it is not a helpful message. However, the message 451 should be
left on in order to check the consistency of the include guards
themselves.
This message is not issued for headers that employ #pragma once.</c>
    </m>
    <m id="452">
        <c>A typedef symbol is being declared to be a different type. This can be
legal, especially with multiple modules, but is not good programming
practice. It interferes with program legibility.</c>
    </m>
    <m id="453">
        <c>A semantic option designated that the named function, symbol, is pure
(lacking non-local side-effects): see the pure semantic in Chapter
&quot;Semantics&quot; in the Reference Manual. However, an impurity was detected.
Such impurities include calling a function through a function pointer,
accessing a volatile variable, modifying a static variable or calling a
function whose purity PC-lint Plus cannot verify. Reason describes which
of these reasons apply and the second symbol parameter shows the related
variable or function as appropriate.
Despite the inconsistency reported, the function will continue to be
regarded as pure.</c>
    </m>
    <m id="463">
        <c>This message is issued when a parse failure occurs when parsing a type
specified with the -strong option. The first string contains the type
specification that caused the error and the second string provides
additional information about the error such as &quot;unmatched right
parenthesis&quot;.</c>
    </m>
    <m id="464">
        <c>This is issued when we encounter a function argument expression used in
such a way that there will be an attempt to copy its contents onto
itself. E.g.

    sprintf( s, &quot;%s&quot;, s );</c>
    </m>
    <m id="466">
        <c>A pointer to a function without a prototype was assigned to or from
another pointer to function. While assigning a pointer to function with
a prototype, to one without a prototype is legal in ISO C, unexpected
behavior may occur too easily. For example:

    char *(*pf)();
    char *strchr(const char *);
    void g() {
        pf = strchr; // Msg 466
        pf(12, 2);   // undefined behavior
    }</c>
    </m>
    <m id="473">
        <c>This message is issued when a function declared with a constant-sized
array parameter is passed an argument which can be determined, using
Value Tracking, to either be null or to point to an area that is smaller
than the size of the array. For example:

    void init(unsigned char array[10]);

    void *malloc(unsigned);

    void foo() {
        unsigned char array1[5];
        unsigned int array2[3];
        unsigned char *pc1 = malloc(8);
        unsigned char *pc2 = (unsigned char *)array2;

        init(array1);   // 473 - array1 is 5 bytes, init expects 10
        init(pc1);      // 473 - pc1 points to 8 bytes (or is null)
        init(pc2);      // Okay - assuming ints are 4 bytes or larger
        init(0);        // 473 - null argument
    }</c>
    </m>
    <m id="474">
        <c>The condition of a switch was a constant expression, e.g. switch(7).
Furthermore, there is no default case and no case statement that matches
the constant expression. &apos;string&apos; contains the constant used as the
switch condition.</c>
    </m>
    <m id="483">
        <c>At least one standards organization has expressed the perspective, if
the expression of a switch statement is boolean in nature, if-else
should be used instead.</c>
    </m>
    <m id="484">
        <c>Due to order of evaluation issues, the mixing of stringizing and pasting
operators, particularly when appearing in the order # parameter ##,
results in unspecified behavior.</c>
    </m>
    <m id="485">
        <c>In addition to the behavior being unspecified when the use of designated
initializers results in duplicate object initialization, assigning to an
array element or structure member more than once in an initializer is
typically a logic error.</c>
    </m>
    <m id="488">
        <c>Two enumerators have the same value and at least one received that value
implicitly. For example:

    enum colors { red, blue, green = 1 };

will elicit this informational message while

    enum colors { red, blue = 1, green = 1 };

will not.</c>
    </m>
    <m id="489">
        <c>An assignment to an element of a string literal was seen. Doing so
results in undefined behavior.</c>
    </m>
    <m id="490">
        <c>This message is issued as a result of processing a #warning preprocessor
directive. string is the message provided to the directive.</c>
    </m>
    <m id="491">
        <c>The ISO standards restrict the use of the defined preprocessor keyword
to either

    defined(identifier)
    defined identifier

Additionally, the preprocessor operator may not result from the
expansion of another macro. This diagnostic highlights departures from
these requirements as non-portable code.</c>
    </m>
    <m id="492">
        <c>A format specifier for a printf/scanf style function was started but did
not contain a conversion specifier. For example:

    printf(&quot;%ll&quot;, 3LL);

will yield the message:

    incomplete format specifier &apos;%ll&apos;</c>
    </m>
    <m id="493">
        <c>A format specifier for a printf/scanf style function attempted to
reference the argument at position 0 but positional arguments are
indexed at 1 so this is not valid. For example:

    printf(&quot;%0$d&quot;, 3);</c>
    </m>
    <m id="494">
        <c>A format specifier for a printf/scanf style function utilizing
positional arguments contained a reference to a non-existent argument,
which results in undefined behavior. For example:

    printf(&quot;%2$d&quot;, j)

will yield the message:

    data argument position &apos;2&apos; exceeds the number of data arguments (1)</c>
    </m>
    <m id="495">
        <c>A format string for a printf/scanf style function contains a nul
character in the body of the string. The receiving function will not be
able to access the portion of the string after this character and its
inclusion is likely a mistake. For example:

    printf(&quot;%d\0%d&quot;, 1, 2);

will elicit this message.</c>
    </m>
    <m id="496">
        <c>The format string provided to a printf/scanf style function is not
terminated with a nul character, which will cause the function to read
past the end of the string causing undefined behavior.</c>
    </m>
    <m id="497">
        <c>An empty format string was provided to a printf or scanf like function.
Calling these functions with an empty format string is legal but suspect
as there is no effect to doing so.</c>
    </m>
    <m id="498">
        <c>A %s or %[ conversion specifier was encountered in the format string of
a scanf-like function that did not contain a maximum field width. Since
the %s and %[ conversion specifiers read characters into the target
buffer until either the maximum field width is reached or a prescribed
character is encountered, failing to provide a maximum field width can
easily result in buffer overflow. &apos;string&apos; contains the unbounded format
specifier.</c>
    </m>
    <m id="499">
        <c>Within the format for a printf or scanf like function, a length modifier
was combined with a conversion specifier that is not supported by
Standard C.</c>
    </m>
    <m id="501">
        <c>The unary minus operator was applied to an unsigned type. The resulting
value is a positive unsigned quantity and may not be what was intended.</c>
    </m>
    <m id="502">
        <c>Unary ~ being a bit operator would more logically be applied to unsigned
quantities rather than signed quantities.</c>
    </m>
    <m id="503">
        <c>Normally a relational would not have a Boolean as argument. An example
of this is a &lt; b &lt; c, which is technically legal but does not produce
the same result as the mathematical expression, which it resembles.</c>
    </m>
    <m id="504">
        <c>Either the quantity being shifted or the amount by which a quantity is
to be shifted was derived in an unusual way such as with a bit-wise
logical operator, a negation, or with an unparenthesized expression. If
the shift value is a compound expression that is not parenthesized,
parenthesize it.</c>
    </m>
    <m id="505">
        <c>The left argument to the comma operator had no side effects in its
top-most operator and hence is redundant.</c>
    </m>
    <m id="506">
        <c>A value appearing in a Boolean context, such as an operand to &amp;&amp;, ||, or
! or a condition of ?:, if, do, for, or while, was found to have a
constant value and hence will evaluate the same way each time. This
message will not be issued in contexts where a constant is required or
expected, such as a static_assert condition or an array size.
Some special cases are reported using other messages:

-   Message 716: while (1) or while (true)

-   Message 717: do ... while (0) or do ... while (false)

-   Message 2441: result of address-of operator used in Boolean context

-   Message 3416: this pointer used in Boolean context</c>
    </m>
    <m id="507">
        <c>A cast was made to an integral quantity from a pointer and according to
other information given or implied it would not fit. For example, a cast
to an unsigned int was specified and information provided by the options
indicate that a pointer is larger than an int. Two integers are
supplied. The first is the size in bytes of the pointer and the second
is the size in bytes of the integer.</c>
    </m>
    <m id="511">
        <c>A cast was made from an integral type to a pointer and the size of the
quantity was too large to fit into the pointer. For example if a long is
cast to a pointer and if options indicate that a long is larger than a
pointer, this warning would be reported.</c>
    </m>
    <m id="513">
        <c>The specified option is not supported in this version of PC-lint Plus
but may be available in a future version.</c>
    </m>
    <m id="514">
        <c>An argument to an arithmetic operator (+ - / * %) or a bit-wise logical
operator (| &amp; ^) was a Boolean. This can often happen by accident as in:

    if( flags &amp; 4 == 0 )

where the ==, having higher precedence than &amp;, is done first (to the
puzzlement of the programmer).</c>
    </m>
    <m id="517">
        <c>The defined preprocessor directive (which was not present in K&amp;R C) was
employed and the K&amp;R preprocessor flag (+fkp) was set. Either do not set
the flag or do not use defined.</c>
    </m>
    <m id="518">
        <c>sizeof type is not strict C. sizeof(type) or sizeof expression are both
permissible.</c>
    </m>
    <m id="519">
        <c>An attempt was made to cast a pointer to a pointer of unequal size. This
could occur for example in a P model where pointers to functions require
4 bytes whereas pointers to data require only 2. This error message can
be circumvented by first casting the pointer to an integral quantity
(int or long) before casting to a pointer.</c>
    </m>
    <m id="520">
        <c>The first expression of a for clause should either be one of the
privileged operators: assignment, increment, decrement or a call to an
impure function or one modifying its argument(s). See Warning 522.</c>
    </m>
    <m id="521">
        <c>The third expression of a for clause should either be one of the
privileged operators: assignment, increment, decrement or a call to an
impure function or one modifying its argument(s). See Warning 522.</c>
    </m>
    <m id="522">
        <c>If a statement consists only of an expression, it should either be one
of the privileged operators: assignment, increment, decrement or a call
to an impure function or one modifying its argument(s). For example, if
operator * is the built-in operator, the statement *p++; draws this
message with string equal to operator and name equal to *. But note that
p++; does not. This is because the highest operator in the former case
is &apos;*&apos;, which has no side effects whereas p++ does. It is possible for a
function to have no side-effects. Such a function is called pure. See
the discussion of the pure semantic in Section &quot;Possible-Semantics&quot; in
the Reference Manual. For example:

    void f() { int n = 3; n++; }
    void g() { f(); }

will trigger this message with string in the message equal to function
and name equal to f.
The definition of pure and impure functions and function calls that have
side effects are given in the discussion of the pure semantic in Chapter
&quot;Semantics&quot; in the Reference Manual.</c>
    </m>
    <m id="523">
        <c>This message is similar to 522 but is issued only if the entire
statement lacks side effects. For example:

    void foo() {
        int i = 0;
        i++ + 1;
    }

While the operator + lacks side effects, the statement doesn&apos;t so 522
will be issued here but not 523.</c>
    </m>
    <m id="524">
        <c>There is a possible loss of a fraction in converting from a float to an
integral quantity. Use of a cast will suppress this message.</c>
    </m>
    <m id="525">
        <c>The current line was found to be negatively indented (i.e., not indented
as much) from the indicated line. The latter corresponds to a clause
introducing a control structure, and statements and other control
clauses and braces within its scope are expected to have no less
indentation. If tabs within your program are other than 8 blanks you
should use the -t option (See Section &quot;Indentation-Checking&quot; in the
Reference Manual).</c>
    </m>
    <m id="526">
        <c>The named external was referenced but not defined and did not appear
declared in any library header file nor did it appear in a Library
Module. This message is suppressed for unit checkout (-unit_check
option). Please note that a declaration, even one bearing prototype
information is not a definition. See the glossary at the beginning of
this chapter. If the symbol is a library symbol, make sure that it is
declared in a header file that you&apos;re including. Also make sure that the
header file is regarded by PC-lint Plus as a Library Header file.
Alternatively, the symbol may be declared in a Library Module. See
Section &quot;Library-Header-Files&quot; in the Reference Manual and Section
&quot;Library-Modules&quot; in the Reference Manual for a further discussion.</c>
    </m>
    <m id="527">
        <c>A portion of the program cannot be reached. The control mechanism
responsible for unconditionally diverting flow away from the specified
area is given by string.</c>
    </m>
    <m id="528">
        <c>The named static variable or static function was not referenced in the
module after having been declared.</c>
    </m>
    <m id="529">
        <c>The named variable was declared but not referenced in a function.</c>
    </m>
    <m id="530">
        <c>An auto variable was used before it was initialized.</c>
    </m>
    <m id="531">
        <c>The size given for a bit field of a structure exceeds the size of an
int.</c>
    </m>
    <m id="533">
        <c>A function declared as returning non-void either contains a return
statement that is missing an expression or control may reach the end of
the function without a value being returned.</c>
    </m>
    <m id="534">
        <c>A function that returns a value is called just for side effects as, for
example, in a statement by itself or the left-hand side of a comma
operator. Try: (void) function(); to call a function and ignore its
return value.</c>
    </m>
    <m id="537">
        <c>The file whose inclusion within a module is being requested has already
been included in this compilation. The file is processed normally even
if the message is given. If it is your standard practice to repeat
included files then simply suppress this message.</c>
    </m>
    <m id="539">
        <c>The current line was found to be positively indented from a clause that
did not control the line in question. For example:

    if( n &gt; 0 )
        x = 3;
        y = 4;

will result in this warning being issued for y = 4;.</c>
    </m>
    <m id="540">
        <c>A string initializer required more space than what was allocated.</c>
    </m>
    <m id="541">
        <c>The size of a character constant specified with \xddd or \xhhh equaled
or exceeded 2**b where b is the number of bits in a byte (established by
the -sb option). The default is -sb8.</c>
    </m>
    <m id="542">
        <c>An attempt was made to assign a value into a bit field that appears to
be too small.
You may get this message unexpectedly if the base of the bit field is an
int. For example:

    struct { int b : 1 } s;
    s.b = 1; /* Warning -- requires 0 or -1 */

The solution in this case is to use &apos;unsigned&apos; rather than &apos;int&apos; in the
declaration of b.</c>
    </m>
    <m id="544">
        <c>The preprocessor directive #endif should be followed by an end-of-line.
Some compilers specifically allow commentary to follow the #endif. If
you are following that convention simply turn this error message off.</c>
    </m>
    <m id="545">
        <c>An attempt was made to take the address of an array name. At one time
such an expression was officially illegal (K&amp;R C ), was not consistently
implemented, and was, therefore, suspect. However, the expression is
legal in ANSI/ ISO C and designates a pointer to an array. For example,
given

    int a[10];
    int (*p) [10];

Then a and &amp;a, as pointers, both represent the same bit pattern, but
whereas a is a pointer to int, &amp;a is a pointer to an array of 10
integers. Of the two only &amp;a may be assigned to p without complaint. If
you are using the &amp; operator in this way, we recommend that you disable
this message.</c>
    </m>
    <m id="546">
        <c>An attempt was made to take the address of a function name. Since names
of functions by themselves are promoted to address, the use of the &amp; is
redundant and could be erroneous.</c>
    </m>
    <m id="547">
        <c>The indicated symbol had previously been defined (via #define) to some
other value.</c>
    </m>
    <m id="548">
        <c>A construct of the form if(e); was found, and it was not followed by an
else. This is almost certainly an unwanted semi-colon as it inhibits the
if from having any effect.</c>
    </m>
    <m id="549">
        <c>A cast was made from a pointer to some enumerated type or from an
enumerated type to a pointer. This is probably an error. Check your code
and if this is not an error, then cast the item to an intermediate form
(such as an int or a long) before making the final cast.</c>
    </m>
    <m id="550">
        <c>A variable (local to some function) was not accessed. This means that
the value of a variable was never used. Perhaps the variable was
assigned a value but was never used. Note that a variable&apos;s value is not
considered accessed by autoincrementing or autodecrementing unless the
autoincrement/decrement appears within a larger expression, which uses
the resulting value. The same applies to a construct of the form: var +=
expression. If an address of a variable is taken, its value is assumed
to be accessed. However, casting that address to a non-pointer causes
Lint to forget this sense of &quot;accessed-ness.&quot; An array, struct or union
is considered accessed if any portion thereof is accessed.</c>
    </m>
    <m id="551">
        <c>A variable (declared static at the module level) was not accessed though
the variable was referenced. See the explanation under message 550
(above) for a description of &quot;access&quot;.</c>
    </m>
    <m id="552">
        <c>An external variable was not accessed though the variable was
referenced. See the explanation under message 550 above for a
description of &quot;access&quot;.</c>
    </m>
    <m id="553">
        <c>The indicated variable had not previously been defined within a #define
statement and yet it is being used in a preprocessor condition of the
form #if or #elif. Conventionally all variables in preprocessor
expressions should be pre-defined. The value of the variable is assumed
to be 0.</c>
    </m>
    <m id="555">
        <c>The #elif directive was used and the K&amp;R preprocessor flag (+fkp) was
set. Either do not set the flag or do not use #elif.</c>
    </m>
    <m id="557">
        <c>The format string supplied to a printf/scanf style function was not
recognized. It is neither a standard format nor a recognized common
extension (see message 816).</c>
    </m>
    <m id="558">
        <c>The number of arguments supplied to a printf/scanf style function was
less than the number expected. The number of missing arguments is given
by integer. See also message 719.</c>
    </m>
    <m id="559">
        <c>The argument corresponding to a conversion specifier in a printf/scanf
style function was not of the correct type. The format, expected
argument type, argument number, and the type of the data argument
provided are reported. Argument counts begin at 1 and include file,
string, and data arguments. For example:

    extern char * buffer;
    sprintf(buffer, &quot;%f&quot;, 371);

will result in the message:

    format &apos;\%f&apos; specifies type &apos;double&apos; which is inconsistent with
    argument no. 3 of type &apos;int&apos;

For conflicting integer types that differ only in signedness (e.g. int
vs. unsigned int) or exact type (e.g. int vs. long when both are the
same size) 705 is given instead. For conflicting pointer to integer
types that differ only in the signedness or exact type of the pointee,
706 is given.</c>
    </m>
    <m id="563">
        <c>name appeared as a label but there was no statement that referenced this
label.</c>
    </m>
    <m id="564">
        <c>The named variable was both modified and accessed in the same expression
in such a way that the result depends on whether the order of evaluation
is left-to-right or right-to-left. One such example is: n + n++ since
there is no guarantee that the first access to n occurs before the
increment of n. This message is also triggered by the potential
modification of an object by a call to a function whose corresponding
parameter is a non-const reference or a non-const pointer. Volatile
variables are also checked for repeated use in an expression.</c>
    </m>
    <m id="565">
        <c>The named tag appeared in a prototype or in an inner block and was not
previously seen in an outer (file-level) scope. Declare the tag before
the function if the intention is for it to be visible outside the
function.</c>
    </m>
    <m id="566">
        <c>This message is given for format specifiers within formats for the
printf/scanf family of functions. The indicated length modifier or flag
character found in a format specifier either has no effect or is not
allowed to be combined with the provided conversion specifier. For
example:

    printf(&quot;%+u&quot;, 123);

will yield the message:

    inconsistent or redundant flag &apos;+&apos; used with &apos;u&apos; conversion specifier

because the + flag is valid only with signed conversions, its use with
other conversions results in undefined behavior.</c>
    </m>
    <m id="567">
        <c>This message is given for format specifiers within formats for the
printf/scanf family of functions. A numeric field or asterisk was
expected at a particular point in the scanning of the format. For
example: %-d requests left justification of a decimal integer within a
format field. But since no field width is given, the request is
meaningless.</c>
    </m>
    <m id="568">
        <c>Comparisons of the form:

    u &gt;= 0      0 &lt;= u
    u &lt;  0      0 &gt;  u

are suspicious if u is an unsigned quantity or a quantity judged to be
never less then 0. See also message 775.</c>
    </m>
    <m id="569">
        <c>An assignment (or implied assignment, see context) was made from a
constant to an integral variable that is not large enough to hold the
constant. Examples include placing a hex constant whose bit requirement
is such as to require an unsigned int into a variable typed as int. The
number of bits given does not count the sign bit.</c>
    </m>
    <m id="570">
        <c>An assignment (or implied assignment, see context) is being made from a
negative constant into an unsigned quantity. Casting the constant to
unsigned will remove the diagnostic but is this what you want? If you
are assigning all ones to an unsigned, remember that ~0 represents all
ones and is more portable than -1.</c>
    </m>
    <m id="571">
        <c>Usually this warning is issued for casts of the form:

    (unsigned) ch

where ch is declared as char and char is signed. Although the cast may
appear to prevent sign extension of ch, it does not. Following the
normal conversion rules of C, if ch is negative then it cannot be
represented in an unsigned type and so a quantity of 2**n is added to
the signed quantity where n is the number of bits in the destination. If
2**m were added, where m is the number of bits in the source, i.e. ch,
then the sign extension would not occur. To suppress sign extension you
may use:

    (unsigned char) ch

Otherwise, if sign extension is what you want and you just want to
suppress the warning in this instance you may use:

    (unsigned) (int) ch

Although these examples have been given in terms of casting a char, this
message will also be given whenever this cast is made upon a signed
quantity whose size is less than the casted type. Examples include
signed bit fields, expressions involving char, and expressions involving
short when this type is smaller than int or a direct cast of an int to
an unsigned long (if int is smaller than long). This message is not
issued for constants or for expressions involving bit operations.</c>
    </m>
    <m id="572">
        <c>A quantity is being shifted to the right whose precision is equal to or
smaller than the shifted value. For example,

    ch &gt;&gt; 10

will elicit this message if ch is typed char and where char is less than
10 bits wide (the usual case). To suppress the message in this case you
may cast the shifted quantity to a type whose length is at least the
length of the shift value.
The precision of a constant (including enumeration constants) is
determined from the number of bits required in its binary
representation. The precision does not change with a cast so that
(unsigned) 1 &gt;&gt; 3 still yields the message. But normally the only way an
expression such as 1 &gt;&gt; 3 can legitimately occur is via a macro. In this
case use -emacro.</c>
    </m>
    <m id="573">
        <c>one of the operands to / or % was signed and the other unsigned;
moreover the signed quantity could be negative. For example:

    u / n

where u is unsigned and n is signed will elicit this message whereas:

    u / 4

will not, even though 4 is nominally an int. It is not a good idea to
mix unsigned quantities with signed quantities in any case (a 737 will
also be issued) but, with division, a negative value can create havoc.
For example, the innocent looking:

    n = n / u

will, if n is -2 and u is 2, not assign -1 to n but will assign some
very large value.
To resolve this problem, either cast the integer to unsigned if you know
it can never be less than zero or cast the unsigned to an integer if you
know it can never exceed the maximum integer.</c>
    </m>
    <m id="574">
        <c>The four relational operators are:

    &gt;  &gt;=  &lt;  &lt;=

One of the operands to a relational operator was signed and the other
unsigned; also, the signed quantity could be negative. For example:

    if( u &gt; n) ...

where u is unsigned and n is signed will elicit this message whereas:

    if( u &gt; 12 ) ...

will not (even though 12 is officially an int it is obvious that it is
not negative). It is not a good idea to mix unsigned quantities with
signed quantities in any case (a 737 will also be issued) but, with the
four relationals, a negative value can produce obscure results. For
example, if the conditional:

    if( n &lt; 0 ) ...

is true then the similar appearing:

    u = 0;
    if( n &lt; u ) ...

is false because the promotion to unsigned makes n very large.
To resolve this problem, either cast the integer to unsigned if you know
it can never be less than zero or cast the unsigned to an int if you
know it can never exceed the maximum int.</c>
    </m>
    <m id="575">
        <c>For many compilers the value of an enumeration constant is limited to
those values that can fit within a signed or unsigned int.</c>
    </m>
    <m id="576">
        <c>In a brace-enclosed initializer, there are more items than there are
elements of the aggregate, which will result in undefined behavior as
this is a constraint violation in C. For example:

    int array[3] = {1, 2, 3, 4};

In C++, an error is emitted instead.</c>
    </m>
    <m id="578">
        <c>A local symbol has the identical name as a variable or field specified
by detail. This could be dangerous. Was this deliberate? It is usually
best to rename the local symbol.</c>
    </m>
    <m id="579">
        <c>When an ellipsis is used, the type of the parameter immediately
preceding the ellipsis should not be a type that would undergo a default
promotion such as char, short or float, a reference type, or a parameter
declared with the register keyword. The C and C++ standards explicitly
state that attempting to extract variable arguments from a call to such
a function results in undefined behavior. The string parameter is one
of: a promotable integer type, a promotable floating point type,
a reference type, or declared as register.</c>
    </m>
    <m id="580">
        <c>A declaration of a function within a block hides a declaration in an
outer scope in such a way that the inner declaration has no prototype
and the outer declaration does. A common misconception is that the
resulting declaration is a composite of both declarations but this is
only the case when the declarations are in the same scope not within
nested scopes. If you do not care about prototypes you may suppress this
message. You will still receive other type-difference warnings.</c>
    </m>
    <m id="583">
        <c>This message is issued when some form of character is compared against
the EOF macro. EOF is normally defined to be -1. For example:

    while( (ch = getchar()) != EOF ) ...

If ch is defined to be an int all is well. If however it is defined to
be some form of char, then trouble might ensue. If ch is an
unsigned char then it can never equal EOF. If ch is a signed char then
you could get a premature termination because some data character
happened to be all ones.
Note that getchar returns an int. The reason it returns an int and not a
char is because it must be capable of returning 257 different values
(256 different characters plus EOF, assuming an 8-bit character). Once
this value is assigned to a char only 256 values are then possible - a
clear loss of information.</c>
    </m>
    <m id="584">
        <c>This message is issued whenever a trigraph sequence is detected and the
trigraph processing has been turned off (with a -ftg). If this is within
a string (or character) constant then the trigraph nature of the
sequence is ignored. That is, three characters are produced rather than
just one. This is useful if your compiler does not process trigraph
sequences and you want linting to mirror compilation. Outside of a
string we issue this warning but we do translate the sequence since it
cannot make syntactic sense in its raw state.</c>
    </m>
    <m id="585">
        <c>This warning is issued whenever a pair of &apos;?&apos; characters is seen within
a string (or character) constant but that pair is not followed by a
character, which would make the triple a valid Trigraph sequence. Did
the programmer intend this to be a Trigraph sequence and merely err?
Even if no Trigraph were intended it can easily be mistaken by the
reader of the code to be a Trigraph. Moreover, what assurances do we
have that in the future the invalid Trigraph might not become a valid
Trigraph and change the meaning of the string? To protect yourself from
such an event you may place a backslash between the &apos;?&apos; characters.
Alternatively you may use concatenation of string constants. For
example:

    pattern = &quot;(???) ???-????&quot;;           // warning 585
    pattern = &quot;(?\?\?) ?\?\?-?\?\?\?&quot;;    // no warning
    #define Q &quot;?&quot;
    pattern=&quot;(&quot; Q Q Q &quot;) &quot; Q Q Q &quot;-&quot; Q Q Q Q;        //no warning</c>
    </m>
    <m id="586">
        <c>The name has been deprecated by some use of the deprecate option. See
-deprecate. The first string is one of the allowed categories of
deprecation. The trailing string is part of the deprecate option and
should explain why the facility has been deprecated.</c>
    </m>
    <m id="587">
        <c>The predicate, identified by string, cannot possibly be other than what
is indicated by the message. For example:

    unsigned u; ...
    if( (u &amp; 0x10) == 0x11 ) ...

would be greeted with the message that &apos;==&apos; always evaluates to &apos;false&apos;.
See  for more information.</c>
    </m>
    <m id="592">
        <c>A printf/scanf style function received a non-literal format specifier
without trailing arguments. For example:

    char msg[100];
    ...
    printf( msg );

This can easily be rewritten to the relatively safe:

    char msg[100];
    ...
    printf( &quot;%s&quot;, msg );

The danger lies in the fact that msg can contain hidden format codes. If
msg is read from user input, then in the first example, a naive user
could cause a glitch or a crash and a malicious user might exploit this
to undermine system security. Since the unsafe form can easily be
transformed into the safe form, the latter should always be used.</c>
    </m>
    <m id="593">
        <c>This is the &apos;possible&apos; version of message 429. A pointer of auto storage
class was allocated storage and not all paths leading to a return
statement or to the end of the function contained either a free or a
return of the pointer. Hence there is a potential memory leak. For
example:

    void f(int n) {
        int *p = new int;
        if (n) delete p;
    }                      //message 593

In this example an allocation is made and, if n is 0, no delete will
have been made.
Please see message 429 for an explanation of &quot;custodial&quot; and ways of
regulating when pointer variables retain custody of allocations.</c>
    </m>
    <m id="597">
        <c>A construct such as:

    a =- b;

or

    a =+ b;

which is suspect: did the programmer intend to use the -=/+= compound
assignment operator? The message is only issued when there is no space
between the = and the -/+ and when there is a space between the -/+ and
its operand. &apos;string&apos; contains the form of compound assignment that the
expression may be confused for.</c>
    </m>
    <m id="598">
        <c>A quantity is being shifted to the left by a value greater than or equal
to the precision of that quantity or by a negative value. For example,

    i &lt;&lt; 32

will elicit this message if i is typed int and where int is 32 bits wide
or less (the usual case). Such shift results in undefined behavior. To
suppress the message you may cast the shifted quantity to a type whose
length is at least the length of the shift value.</c>
    </m>
    <m id="599">
        <c>A wild card pattern was used where the name of a file was expected but
there were no files found that match the given pattern so it will be
ignored. &apos;string&apos; contains the offending pattern.</c>
    </m>
    <m id="601">
        <c>A declaration did not have an explicit type. int was assumed. Was this a
mistake? This could easily happen if an intended comma was replaced by a
semicolon. For example, if instead of typing:

    double      radius,
                diameter;

the programmer had typed:

    double      radius;
                diameter;

this message would be raised.</c>
    </m>
    <m id="602">
        <c>The sequence /* was found within a comment. Was this deliberate? Or was
a comment end inadvertently omitted? If you want PC-lint Plus to
recognize nested comments you should set the Nested Comment flag using
the +fnc option. Then this warning will not be issued. If it is your
practice to use the sequence:

    /*
    /*              */

then use -e602.</c>
    </m>
    <m id="603">
        <c>The address of the named symbol is being passed to a function where the
corresponding parameter is declared as pointer to const. This implies
that the function will not modify the object. If this is the case then
the original object should have been initialized sometime earlier.</c>
    </m>
    <m id="604">
        <c>The address of the named symbol is being passed back by a function.
Since the object is an auto and since the duration of an auto is not
guaranteed past the return, this is most likely an error. You may want
to copy the value into a global variable and pass back the address of
the global or you might consider having the caller pass an address of
one of its own variables to the callee.</c>
    </m>
    <m id="605">
        <c>This warning is typically caused by assigning a (pointer to const) to an
ordinary pointer. For example:

    int *p;
    const int *q;
    p = q;     /* 605   */

The message will be inhibited if a cast is used as in:

    p = (int *) q;

An increase in capability is indicated because the const pointed to by q
can now be modified through p. This message can be given for the
volatile qualifier as well as the const qualifier and may be given for
arbitrary pointer depths (pointers to pointers, pointers to arrays,
etc.).
If the number of pointer levels exceeds one, things get murky in a
hurry. For example:

    const char ** ppc;
    char ** pp;
    pp = ppc;        /* 605 - clearly not safe */
    ppc = pp;        /* 605 - looks safe but it&apos;s not */

The problem is that after the above assignment, a pointer to a
const char can be assigned indirectly through ppc and accessed through
pp, which can then modify the const char.
The message speaks of an &quot;increase in capability&quot; in assigning to ppc,
which seems counter intuitive because the indirect pointer has less
capability. However, assigning the pointer does not destroy the old one
and the combination of the two pointers represents a net increase in
capability.
The message may also be given for function pointer assignments when the
prototype of one function contains a pointer of higher capability than a
corresponding pointer in another prototype. There is a curious inversion
here whereby a prototype of lower capability translates into a function
of greater trust and hence greater capability (a Trojan Horse). For
example, let

    void warrior( char * );

be a function that destroys its argument. Consider the function:

    void Troy( void (*horse)(const char *) );\\

Troy() will call horse() with an argument that it considers precious
(i.e. not to be modified) believing the horse() will do no harm. Before
compilers knew better and believing that adding in a const to the
destination never hurt anything, earlier compilers allowed the Greeks to
pass warrior() to Troy and the rest, as they say, is history.</c>
    </m>
    <m id="606">
        <c>An escape sequence occurred, within a character or string literal, that
was not on the approved list, which is:
    \&apos; \&quot; \? \\\a \b \f \n \r \t \v
xhex-digits</c>
    </m>
    <m id="608">
        <c>An assignment is being made to a parameter that is typed array. For the
purpose of the assignment, the parameter is regarded as a pointer.
Normally such parameters are typed as pointers rather than arrays.
However if this is your coding style you should suppress this message.</c>
    </m>
    <m id="611">
        <c>Either a pointer to a function is being cast to a pointer to an object
or vice versa. This is regarded as questionable by the language
standards. If this is not a user error, suppress this warning.</c>
    </m>
    <m id="612">
        <c>A declaration contained just a storage class and a type. This is almost
certainly an error since the only time a type without a declarator makes
sense is in the case of a struct, union or enum but in that case you
wouldn&apos;t use a storage class.</c>
    </m>
    <m id="613">
        <c>From information gleaned from earlier statements, it is possible that a
null pointer (a pointer whose value is 0) can be used in a context where
null pointers are inappropriate. Information leading to this
determination is provided as a series of supplemental messages. See also
message 413.</c>
    </m>
    <m id="614">
        <c>Prior to C99, auto aggregate initialization could consist only of
constant expressions. This message is only issued in C89/C90 mode. See
also message 446.</c>
    </m>
    <m id="615">
        <c>This warning is similar to 614. Auto aggregates (arrays, structures and
possibly unions) are normally initialized by a collection of constant
expressions without side-effects. If your compiler supports side-effects
in the initializers of aggregate, you may want to suppress this message.
This message is only issued in C89/C90 mode.</c>
    </m>
    <m id="616">
        <c>It is possible for flow of control to fall into a case statement or a
default statement from above. Was this deliberate or did the programmer
forget to insert a break statement? If this was deliberate then place a
comment immediately before the statement that was flagged as in:

    case &apos;a&apos;: a=0;
        /* fall through */
    case &apos;b&apos;:  a++;

Note that the message will not be given for a case that merely follows
another case without an intervening statement. Also, there must actually
be a possibility for flow to occur from above. See also message 825 and
option -fallthrough.</c>
    </m>
    <m id="618">
        <c>A storage class specifier (static, extern, typedef, register or auto)
was found after a type was specified. This is legal but unusual. Either
place the storage class specifier before the type or suppress this
message.</c>
    </m>
    <m id="620">
        <c>A constant ended in a lower-case letter &apos;l&apos;. Was this intended to be a
one? The two characters look very similar. To avoid misinterpretations,
use the upper-case letter &apos;L&apos;.</c>
    </m>
    <m id="621">
        <c>The -idlen option can be used to specify the number of significant
characters in external, preprocessor, and preprocessor names. Names that
are not unique within the initial characters specified by this option
are said to &quot;clash&quot; and are reported by this message.
For the purpose of this message, identifiers are classified as external
(function and variable names with external linkage), preprocessor (macro
names and macro parameter names), and compiler (all other identifiers,
including those with internal and no linkage, such as fields, tags,
enumeration constants, typedefs, labels, etc). The type of clash is
reported by the first string parameter. The possible values of this
parameter and the cases in which the clashes are reported are detailed
in the following list.

-   field vs field
    The names of two fields clash within the same structure or union.

-   tag vs tag
    The names of two struction, union, or enum tags clash within a
    single translation unit.

-   label vs label
    The names of two labels clash within a single function.

-   internal vs internal, same scope
    Two compiler identifiers clash in the same scope.

-   internal vs external, same scope
    A compiler identifier clashes with an external identifier in the
    same scope.

-   external vs internal, same scope
    An external identifier clashes with a compiler identifier in the
    same scope.

-   internal vs internal, enclosing scope
    A compiler identifier clashes with another compiler identifier in an
    enclosing scope.

-   internal vs external, enclosing scope
    A compiler identifier clashes with an external identifier in an
    enclosing scope.

-   external vs internal, enclosing scope
    An external identifier clashes with a compiler identifier in an
    enclosing scope.

-   external vs external
    Two external identifiers clash (anywhere in the analyzed program).

-   macro vs macro
    The names of two macros in the same translation unit clash.

-   macro vs macro parameter
    The name of a macro clashes with the name of a macro parameter of a
    currently defined macro.

-   macro parameter vs macro parameter
    The name of a macro parameter clashes with the name of a parameter
    of the same macro.

Fields, tags, and labels each exist in their own name spaces and thus
never clash with identifiers in other name spaces. Internal here refers
to compiler identifiers that are not field, tag, or label identifiers.
For clashes between internal and external names, the number of
significant characters for compiler identifiers is used to determine a
clash. Clashes between two external identifiers are reported regardless
of scope. External identifiers in separate modules that clash are
reported during global wrapup.
This message is not issued for C++ modules (all characters in identifier
names are significant and case-sensitive in C++) or for identifiers with
identical spelling.</c>
    </m>
    <m id="629">
        <c>A static storage class specifier was found for a function declaration
within a function. The static storage class specifier is permitted only
for functions in declarations that have file scope (i.e., outside any
function). Either move the declaration outside the function or change
static to extern; if the second choice is made, make sure that a static
declaration at file scope also exists before the extern declaration.</c>
    </m>
    <m id="631">
        <c>The struct, union or enum tag symbol was defined differently in
different scopes. This is not necessarily an error since C permits the
redefinition, but it can be a source of subtle error. It is not
generally a programming practice to be recommended.</c>
    </m>
    <m id="632">
        <c>An assignment (or implied assignment, context indicates which), violates
a Strong type check as requested by a -strong(A...) option. See Chapter
&quot;Strong Types&quot; in the Reference Manual.</c>
    </m>
    <m id="633">
        <c>An assignment (or implied assignment, context indicates which), violates
a Strong type check as requested by a -strong(X...) option. See Chapter
&quot;Strong Types&quot; in the Reference Manual.</c>
    </m>
    <m id="634">
        <c>An equality operation (== or !=) or a conditional operation (? :)
violates a Strong type check as requested by a -strong(J...) option.
This message would have been suppressed using flags &quot;Je&quot;. See Chapter
&quot;Strong Types&quot; in the Reference Manual.</c>
    </m>
    <m id="635">
        <c>The strong parent of the symbol is being reset. This is being done with
a -parent option or by a typedef. Note that this may not necessarily be
an error; you are being alerted to the fact that the old link is being
erased. See Chapter &quot;Strong Types&quot; in the Reference Manual.</c>
    </m>
    <m id="636">
        <c>Pointers are being compared and there is a strong type clash below the
first level. For example,

    /*lint -strong(J, INT) */
    typedef int INT;
    INT *p;  int *q;

    if( p == q ) /*  Warning 636  */

will elicit this warning. This message would have been suppressed using
flags &quot;Je&quot; or &quot;Jr&quot; or both. See Chapter &quot;Strong Types&quot; in the Reference
Manual.</c>
    </m>
    <m id="637">
        <c>This is the message you receive when an inconsistency with the -index
option is recognized. A subscript is not the stipulated type (the first
type mentioned in the message) nor equivalent to it within the hierarchy
of types. See Chapter &quot;Strong Types&quot; in the Reference Manual and also
+fhx.</c>
    </m>
    <m id="638">
        <c>A relational operation ( &gt;= &lt;= &gt; &lt; ) violates a Strong type check as
requested by a -strong(J...) option. This message would have been
suppressed using flags &quot;Jr&quot;. See Chapter &quot;Strong Types&quot; in the Reference
Manual.</c>
    </m>
    <m id="639">
        <c>A binary operation other than an equality or a relational operation
violates a Strong type check as requested by a -strong(J...) option.
This message would have been suppressed using flags &quot;Jo&quot;. See Chapter
&quot;Strong Types&quot; in the Reference Manual.</c>
    </m>
    <m id="640">
        <c>A Boolean context expected a type specified by a -strong(B...) option.
See Chapter &quot;Strong Types&quot; in the Reference Manual.</c>
    </m>
    <m id="641">
        <c>An enumeration type was used in a context that required a computation
such as an argument to an arithmetic operator or was compared with an
integral argument. This warning will be suppressed if you use the
integer model of enumeration (+fie) but you will lose some valuable
type-checking in doing so. An intermediate policy is to simply turn off
this warning. Assignment of int to enum will still be caught.
This warning is not issued for a tagless enum without variables. For
example

    enum {false,true};

This cannot be used as a separate type. PC-lint Plus recognizes this and
treats false and true as arithmetic constants.</c>
    </m>
    <m id="644">
        <c>An auto variable was not necessarily assigned a value before use.</c>
    </m>
    <m id="646">
        <c>A case or default statement was found within a for, do, or while loop.
Was this intentional? At the very least, this reflects poor programming
style.</c>
    </m>
    <m id="647">
        <c>This message is issued when it appears that there may have been an
unintended loss of information during an operation involving int or
unsigned int the result of which is later converted to long. It is
issued only for systems in which int is smaller than long. For example:

    (long) (n &lt;&lt; 8)

might elicit this message if n is unsigned int, whereas

    (long) n &lt;&lt; 8

would not. In the first case, the shift is done at int precision and the
high order 8 bits are lost even though there is a subsequent conversion
to a type that might hold all the bits. In the second case, the shifted
bits are retained.
The operations that are scrutinized and reported upon by this message
are: shift left, multiplication, and bit-wise complementation. Addition
and subtraction are covered by Informational message 776.
The conversion to long may be done explicitly with a cast as shown or
implicitly via assignment, return, argument passing or initialization.
The message can be suppressed by casting. You may cast one of the
operands so that the operation is done in full precision as is given by
the second example above. Alternatively, if you decide there is really
no problem here (for now or in the future), you may cast the result of
the operation to some form of int. For example, you might write:

    (long) (unsigned) (n &lt;&lt; 8)

In this way PC-lint Plus will know you are aware of and approve of the
truncation.</c>
    </m>
    <m id="648">
        <c>Arithmetic overflow was detected while computing a constant expression.
For example, if int is 16 bits then 200 * 200 will result in an
overflow.
To suppress this message for particular constant operations you may have
to supply explicit truncation. For example, if you want to obtain the
low order 8 bits of the integer 20000 into the high byte of a 16-bit
int, shifting left would cause this warning. However, truncating first
and then shifting would be OK. The following code illustrates this where
int is 16 bits.

    20000u &lt;&lt; 8;            /* 648 */
    (0xFF &amp; 20000u) &lt;&lt; 8;   /* OK */

If you truncate with a cast you may make a signed expression out of an
unsigned. For example, the following receives a warning (for 16 bit
int).

    (unsigned char) 0xFFFu &lt;&lt; 8;     /* 648 */

because the unsigned char is promoted to int before shifting. The
resulting quantity is actually negative. You would need to revive the
unsigned nature of the expression with

    (unsigned) (unsigned char) 0xFFF &lt;&lt; 8;     /* OK */</c>
    </m>
    <m id="649">
        <c>During the evaluation of a constant expression, a negative integer was
shifted right causing sign fill of vacated positions. If this is what is
intended, suppress this error, but be aware that sign fill is
implementation-dependent.</c>
    </m>
    <m id="650">
        <c>In a comparison operator or equality test (or implied equality test as
for a case statement), a constant operand was used in a way that is not
appropriate for the constraints on the value of the other operand. For
example, if 300 is compared against a char variable, this warning will
be issued. Moreover, if char is signed (and 8 bits) you will get this
message if you compare against an integer greater than 127. The problem
can be fixed with a cast. For example:

    if( ch == 0xFF ) ...
    if( (unsigned char) ch == 0xFF ) ...

If char is signed (+fcu has not been set) the first receives a warning
and can never succeed. The second suppresses the warning and corrects
the bug.
PC-lint Plus will take into account the limited precision of some
operands such as bit-fields and enumerated types. Also, PC-lint Plus
will take advantage of computations that limit the precision of an
operand. For example,

    if( (n &amp; 0xFF) &gt;&gt; 4 == 16 ) ...}

will receive this warning because the left-hand side is limited to 4
bits of precision.
See  for more information. See also message 2650 for constants that are
out of range for only part of a compound comparison operator.</c>
    </m>
    <m id="651">
        <c>An initializer for a complex aggregate is being processed that contains
some subaggregates that are bracketed and some that are not. ANSI/ISO
recommends either &quot;minimally bracketed&quot; initializers in which there are
no interior braces or &quot;fully bracketed&quot; initializers in which all
interior aggregates are bracketed.</c>
    </m>
    <m id="652">
        <c>A macro is being defined for a symbol that had previously been declared.
For example:

    int n;
    #define n N

will draw this complaint. Prior symbols checked are local and global
variables, functions and typedef symbols, and struct, union and enum
tags. Not checked are struct and union members.</c>
    </m>
    <m id="653">
        <c>When two integers are divided and assigned to a floating point variable
the fraction portion is lost. For example, although

    double x = 5 / 2;

appears to assign 2.5 to x it actually assigns 2.0. To make sure you do
not lose the fraction, cast at least one of the operands to a floating
point type. If you really wish to do the truncation, cast the resulting
divide to an integral (int or long) before assigning to the floating
point variable.</c>
    </m>
    <m id="654">
        <c>The specified option is obsolete and should no longer be used. The
detail parameter contains additional information such as further
explanation or alternatives.</c>
    </m>
    <m id="655">
        <c>A bit-wise operator (one of &apos;|&apos;, &apos;&amp;&apos; or &apos;^&apos;) is used to combine two
compatible enumerations. The type of the result is considered to be the
enumeration. This is considered a very minor deviation from the strict
model and you may elect to suppress this warning.</c>
    </m>
    <m id="656">
        <c>An arithmetic operator (one of &apos;+&apos;, or &apos;-&apos;) is used to combine two
compatible enumerations. The type of the result is considered to be the
enumeration. This is considered a very minor deviation from the strict
model and you may elect to suppress this warning.</c>
    </m>
    <m id="657">
        <c>A struct or union declaration without a declarator was taken to be
anonymous. However, the anonymous union supported by C++ and other
dialects of C require untagged unions. Tagged unions and tagged or
untagged structs are rarely supported, as anonymous.</c>
    </m>
    <m id="658">
        <c>A union without a declarator was found. Was this an attempt to define an
anonymous union? If so, anonymous unions should be activated with the
+fan flag. This flag is activated automatically for C++.</c>
    </m>
    <m id="660">
        <c>A number of options use the &apos;-&apos; prefix to remove and the &apos;+&apos; prefix to
add elements to a list. For example to add (the most unusual) extension
.C++ to designate C++ processing of files bearing that extension, a
programmer should employ the option:

    +cpp(.C++)

However, if a leading &apos;-&apos; is employed (a natural mistake) this warning
will be emitted.</c>
    </m>
    <m id="661">
        <c>An out-of-bounds pointer may have been accessed. See message 415 for a
description of the integer parameter. For example:

    int a[10];
    if( n &lt;= 10 ) a[n] = 0;

Here the programmer presumably should have written n &lt; 10. This message
is similar to message 415 but differs from it by the degree of
probability. See Chapter &quot;Value Tracking&quot; in the Reference Manual.</c>
    </m>
    <m id="662">
        <c>An out-of-bounds pointer may have been created. See message 415 for a
description of the integer parameter. For example:

    int a[10];
    if( n &lt;= 20 ) f( a + n );

Here, it appears as though an illicit pointer is being created, but
PC-lint Plus cannot be certain. See also message 416 and Chapter &quot;Value
Tracking&quot; in the Reference Manual.</c>
    </m>
    <m id="663">
        <c>This warning occurs in the following kind of situation:

    struct x { int a; } y[2];
    ...  y-&gt;a  ...

Here, the programmer forgot to index the array but the error normally
goes undetected because the array reference is automatically and
implicitly converted to a pointer to the first element of the array. If
you really mean to access the first element use y[0].a</c>
    </m>
    <m id="664">
        <c>An exiting function was found on the left hand side of an operator
implying that the right hand side would never be executed. For example:

    if( (exit(0), n == 0) || n &gt; 2 ) ...

Since the exit function does not return, control can never flow to the
right hand operator.</c>
    </m>
    <m id="665">
        <c>An expression was passed to a macro parameter that was not
parenthesized. For example:

    #define mult(a,b) (a*b)
    ...   mult( 100, 4 + 10 )

Here the programmer is beguiled into thinking that the 4+10 is taken as
a quantity to be multiplied by 100 but instead results in: 100*4+10,
which is quite different. The recommended remedy () is to parenthesize
such parameters as in:

    #define mult(a,b) ((a)*(b))

The message is not arbitrarily given for any unparenthesized parameter
but only when the actual macro argument sufficiently resembles an
expression and the expression involves binary operators. The priority of
the operator is not considered except that it must have lower priority
than the unary operators. The message is not issued at the point of
macro definition because it may not be appropriate to parenthesize the
parameter. For example, the following macro expects that an operator
will be passed as argument. It would be an error to enclose op in
parentheses.

    #define check(x,op,y) if( ((x) op (y)) == 0 ) print( ... )</c>
    </m>
    <m id="666">
        <c>A repeated parameter within a macro was passed an argument with
side-effects. For example:

    #define ABS(x) ((x) &lt; 0 ? -(x) : (x))

    ... ABS( n++ )

Although the ABS macro is correctly defined to specify the absolute
value of its argument, the repeated use of the parameter x implies a
repeated evaluation of the actual argument n++ This results in two
increments to the variable n. Any expression containing a function call
is also considered to have side-effects.</c>
    </m>
    <m id="668">
        <c>A NULL pointer is possibly being passed to a function identified by
symbol. The argument in question is given by context. The function is
either a library function designed not to receive a NULL pointer or a
user function dubbed so via the option -function or -sem. See Sections
&quot;Function-Mimicry-(-function)&quot; in the Reference Manual,
&quot;Semantic-Specifications&quot; in the Reference Manual and &quot;Value Tracking&quot;
in the Reference Manual.</c>
    </m>
    <m id="669">
        <c>This message is for data transfer functions such as memcpy, strcpy,
fgets, etc. when the size indicated by the first cited argument (or
arguments) can possibly exceed the size of the buffer area cited by the
second. The message may also be issued for user functions via the
-function or -sem option. See Sections &quot;Function-Mimicry-(-function)&quot; in
the Reference Manual, &quot;Semantic-Specifications&quot; in the Reference Manual
and Chapter &quot;Value Tracking&quot; in the Reference Manual.</c>
    </m>
    <m id="670">
        <c>This message is issued for several library functions (such as fwrite,
memcmp, etc.) wherein there is a possible attempt to access more data
than exist. For example, if the length of data specified in the fwrite
call exceeds the size of the data specified. The function is specified
by symbol and the arguments are identified by argument number. See
Sections &quot;Function-Mimicry-(-function)&quot; in the Reference Manual,
&quot;Semantic-Specifications&quot; in the Reference Manual and Chapter &quot;Value
Tracking&quot; in the Reference Manual.</c>
    </m>
    <m id="671">
        <c>An integral value that may possibly be negative is being passed to a
function that is expecting only positive values for a particular
argument. The message contains the name of the function (symbol), the
questionable value (integer) and the argument number (context). The
function may be a standard library function designed to accept only
positive values such as malloc or memcpy (third argument), or may have
been identified by the user as such through the -function or -sem
options. See message 422 for an example and further explanation.</c>
    </m>
    <m id="672">
        <c>An assignment was made to a pointer variable (designated by symbol),
which may already be holding the address of an allocated object that had
not been freed. The allocation of memory, which is not freed, is
considered a &apos;memory leak&apos;. The memory leak is considered &apos;possible&apos;
because only some lines of flow will result in a leak.</c>
    </m>
    <m id="673">
        <c>This message indicates that a deallocation (delete, delete[], or free)
as specified by the first string parameter may be inappropriate for the
data being freed. The kind of data is described in the second string
parameter. The wording &apos;may not&apos; is used to indicate that only some of
the lines of flow to the deallocation show data inconsistent with the
allocation. See also message 424.</c>
    </m>
    <m id="674">
        <c>The value held by a pointer variable contains the address of an auto
variable. It is normally incorrect to return the address of an item on
the stack because the portion of the stack allocated to the returning
function is subject to being obliterated after return.</c>
    </m>
    <m id="675">
        <c>The -function option is used to transfer semantics from its first
argument to subsequent arguments. However it was found that the first
argument name did not have semantics.</c>
    </m>
    <m id="676">
        <c>An integer whose value was possibly negative was added to an array or to
a pointer to an allocated area (allocated by malloc, operator new,
etc.). This message is not given for pointers whose origin is unknown
since a negative subscript is in general legal.</c>
    </m>
    <m id="677">
        <c>Whereas the use of sizeof during preprocessing is supported by a number
of compilers it is not a part of the ANSI/ISO C or C++ standard. See
Section &quot;Preprocessor sizeof&quot; in the Reference Manual.</c>
    </m>
    <m id="678">
        <c>A bit field was found to be too small to support all the values of an
enumeration (that was used as the base of the bit field). For example:

    enum color { red, green, yellow, blue };
    struct abc { enum color c:2; };

Here, the message is not given because the four enumeration values of
color will just fit within 2 bits. However, if one additional color is
inserted, Warning 678 will be issued informing the programmer of the
undesirable and dangerous condition.</c>
    </m>
    <m id="679">
        <c>This message is issued when it appears that there may have been an
unintended loss of information during an operation involving integrals
before combining with a pointer whose precision is greater than the
integral expression. For example:

    // Assuming 4-byte ints and 8-bytes pointers (-si4 -sp8)
    char *f( char *p, int n, int m ) {
        return p + (n + m); // warning 679
    }

By the rules of C/C++, the addition n+m is performed independently of
its context and is done at integer precision. Any overflow is ignored
even though the larger precision of the pointer could easily accommodate
the overflow. If, on the other hand the expression were: p+n+m, which
parses as (p+n)+m, no warning would be issued.
If the expression were p+n*m then, to suppress the warning, a cast is
needed. If long were the same size as pointers you could use the
expression:

    return p + ((long) n * m);</c>
    </m>
    <m id="680">
        <c>An arithmetic expression was cast to pointer. Moreover, the size of the
pointer is greater than the size of the expression. In computing the
expression, any overflow would be lost even though the pointer type
would be able to accommodate the lost information. To suppress the
message, cast one of the operands to an integral type large enough to
hold the pointer. Alternatively, if you are sure there is no problem you
may cast the expression to an integral type before casting to pointer.
See messages 647, 776, 790 and 679.</c>
    </m>
    <m id="681">
        <c>The controlling expression for a loop (either the expression within a
while clause or the second expression within a for clause) evaluates
initially to 0 and so it appears as though the loop is never entered.</c>
    </m>
    <m id="682">
        <c>If a parameter is typed as an array it is silently promoted to pointer.
Taking the size of such an array will actually yield the size of a
pointer. Consider, for example:

    unsigned f( char a[100] ) { return sizeof(a); }

Here it looks as though function f() will return the value 100 but it
will actually return the size of a pointer, which is usually 4.</c>
    </m>
    <m id="683">
        <c>This message is issued whenever the name of a function with some
semantic association is defined as a macro. For example:

    #define strlen mystrlen

will raise this message. The problem is that the semantics defined for
strlen will then be lost. Consider this message an alert to transfer
semantics from strlen to mystrlen, using -function(strlen, mystrlen).
The message will be issued for built-in functions (with built-in
semantics) or for user-defined semantics. The message will not be issued
if the function is defined to be a function with a similar name but with
underscores either appended or prepended or both. For example:

    #define strlen __strlen

will not produce this message. It will produce Info 828 instead.</c>
    </m>
    <m id="685">
        <c>The first string is one of &apos;&gt;&apos;, &apos;&gt;=&apos;, &apos;&lt;&apos;, or &apos;&lt;=&apos; and identifies the
relational operator. The second string is one of true or false. The
message is given when an expression is compared to a constant and the
precision of the expression indicates that the test will always succeed
or always fail. For example,

    char ch;
    ...
    if( ch &gt;= -128 ) ...

In this example, the precision of char ch is 8 bits signed (assuming the
fcu flag has been left in the OFF state) and hence it has a range of
values from -128 to 127 inclusive. Hence the test is always true.
Note that, technically, ch is promoted to int before comparing with the
constant. For the purpose of this comparison we consider only the
underlying precision. As another example, if u is an unsigned int then

    if( (u &amp; 0xFF) &gt; 0xFF ) ...

will also raise message 685 because the expression on the left hand side
has an effective precision of 16 bits.</c>
    </m>
    <m id="686">
        <c>An option is considered suspicious for one of a variety of reasons. The
reason is designated by detail. At this writing the following reasons
for issuing this message are:

-   unbalanced quotes
    An option was seen with a quote character that was not balanced
    within that same option.

-   backtick preceding non-meta character is superfluous and has been dropped
    A backtick () was seen before a character other than a * or a ?. The
    use of a backtick in this fashion has no effect.

-   upper case characters within extension &apos;string&apos;; these will match lower case when +fff is on; try -fff
    A file extension involving uppercase letters was seen in a +cpp or
    +lnt option while the +fff flag was active or the flag became active
    while there were uppercase extensions registered via +cpp or +lnt.
    If, for example, you intend for .c to indicate a C module and .C to
    indicate a C++ module, turning off the fff flag will help avoid
    unnecessary complaints from PC-lint Plus.

-   extraneous characters following string
    One or more characters were seen immediately following a character
    that is expected to signify the end of an option, such as a closing
    right parenthesis. While the extraneous characters are ignored,
    their presence may indicate a typographical error.

-   the likelihood of causing meaningless output
    An option, such as -elib(*), -wlib(0), or +fce was seen; this
    typically hides a problem in the PC-lint Plus configuration. When
    using a new configuration, it&apos;s common for a user to encounter Error
    messages about Library header code. (This usually does not indicate
    a problem with library headers.) For example, a misconfiguration of
    PC-lint Plus preprocessor is by far the most common source of these
    errors. If you merely suppress basic Syntax Errors (like error 10)
    and/or Fatal Errors (like error 309), the underlying configuration
    problem still exists; as a result, PC-lint Plus will fail to parse
    your code correctly (because your code depends on the aforementioned
    library code). The output from Lint would then seem illogical and/or
    meaningless. Therefore, blanket suppression options like this are
    highly discouraged. Instead, other aspects of the Lint configuration
    should be modified to make Lint&apos;s behavior more similar to that of
    the compiler at (or, typically, before) the point of Error.

-   it is too late to use -incvar as &apos;name&apos; has already been processed as incvar
    This option (-incvar) is used to specify the name of the environment
    variable that contains a list of supplementary directories to be
    searched for headers. This option does not have any effect after
    this environment variable is processed, which occurs when processing
    the first module. To have an effect, the option must be moved to
    before the first module.

-   option has no effect due to zero length zone of transition
    The -w# or -wlib(#) option was seen with the same warning level of
    the previously provided -w# or -wlib(#) option. Because the warning
    level doesn&apos;t change, there is no zone of transition and therefore
    no effect on the message suppression set. For example, in
    -w1 +e714 -w1, the second -w1 does not have any effect, in
    particular, message 714 is not suppressed because there is no zone
    of transition. If the goal is to suppress all messages except for
    errors regardless of messages that have been enabled in the
    meantime, it is necessary to raise the warning level and then lower
    it, e.g. -w4 -w1.

-   modifying the LINT environment variable after startup has no effect; this variable should be set before program startup
    The -setenv option was used to set the LINT environment variable. If
    this variable is set when PC-lint Plus is started, its contents are
    processed as options before the command line options are processed.
    Attempting to set or change the value of this variable after program
    startup has no effect.

-   -max_threads option must appear before first module to have any effect
    -max_threads is used to specify the maximum concurrent linting
    threads to dispatch when performing parallel analysis. This option
    has no effect when it appears after the first module; move the
    option to before the first module is referenced to obtain the
    desired behavior.

-   the size of an incomplete type was requested in a function semantic
    The use of @p was used in a user-defined function return semantic
    but the pointee return type was not complete at the point of the
    call. This is suspicious because if the type is incomplete, PC-lint
    Plus cannot calculate its size from the number of the type&apos;s
    elements. Either use @P to specify size in bytes or make a
    definition of the type visible to PC-lint Plus at the point of the
    call.

-   include path begins with unexpanded tilde prefix
    The path provided to a -i option began with a tilde (~). This was
    likely intended to refer to the user&apos;s home directory, but it is
    interpreted literally unless expanded by the shell.

-   include path is the absolute path of a file rather than a directory
    The path provided to a -i option was a valid absolute path but
    refers to a file rather than a directory.

-   absolute path is not accessible
    The path provided to a -i option unambiguously refers to an absolute
    path on the current platform but the target does not exist.

-   include path resembles a Windows absolute path
    The path provided to a -i option begins with a Windows drive letter
    which has no special meaning on the current platform (and would
    simply refer to a relative directory named after the &quot;drive
    letter&quot;).

-   drive-relative absolute path is not accessible on the current drive
    The path provided to a -i option begins with a slash on Windows.
    This is an &quot;absolute&quot; path relative to the current drive letter (at
    the time that the path is resolved). The target does not exist on
    the current drive. It is possible that the directory could be found
    if PC-lint Plus were launched from a different drive.

-   language standard cannot be changed while processing a module
    A -std (or -A) option was encountered within a configuration file
    opened by -indirect or -subfile while processing a module. This
    option will have no effect in this context but would be valid if the
    configuration file were used outside of a module. Note that an
    attempt to change the language standard directly within a module,
    e.g. using a -std option within a comment, is always invalid and
    error 72 will be reported instead.</c>
    </m>
    <m id="687">
        <c>A comma operator appeared unbraced and unparenthesized in a statement
following an if, else, while or for clause. For example:

    if( n &gt; 0 ) n = 1,
    n = 2;

Thus the comma could be mistaken for a semi-colon and hence be the
source of subtle bugs.
If the statement is enclosed in curly braces or if the expression is
enclosed in parentheses, the message is not issued.</c>
    </m>
    <m id="689">
        <c>The pair of characters &apos;*/&apos; was found not within a comment. As an
example:

    void f( void*/*comment*/ );

This is taken to be the equivalent of:

    void f( void* );

That is, an implied blank is inserted between the &apos;*&apos; and the &apos;/&apos;. To
avoid this message simply place an explicit blank between the two
characters.</c>
    </m>
    <m id="691">
        <c>The backslash character has been used in a way that may produce
unexpected results. Typically this would occur within a macro such as:

    #define A b \ // comment

The coder might be thinking that the macro definition will be continued
on to the next line. The standard indicates, however, that the newline
will not be dropped in the event of an intervening comment. This should
probably be recoded as:

    #define A b /* comment */ \</c>
    </m>
    <m id="692">
        <c>A string was found that contains an &apos;8&apos; or &apos;9&apos; after an octal escape
sequence with no more than two octal digits, e.g.

    &quot;\079&quot;

contains two characters: Octal seven (ASCII BEL) followed by &apos;9&apos;. The
casual reader of the code (and perhaps even the programmer) could be
fooled into thinking this is a single character. If this is what the
programmer intended he can also render this as

    &quot;\07&quot; &quot;9&quot;

so that there can be no misunderstanding. On the other hand,

    &quot;\1238&quot;

will not raise a message because it is assumed that the programmer knows
that octal escape sequences cannot exceed four characters (including the
initial backslash).</c>
    </m>
    <m id="693">
        <c>A string was found that looks suspiciously like (but is not) a
hexadecimal escape sequence; rather, it is a null character followed by
letter &quot;x&quot; followed by some hexadecimal digit, e.g.:

    &quot;\0x62&quot;

was found where the programmer probably meant to type &quot;\x62&quot;. If you
need precisely this sequence you can use:

    &quot;\0&quot; &quot;x62&quot;

and this warning will not be issued.</c>
    </m>
    <m id="695">
        <c>In C99, the result of a call to a function declared with &apos;inline&apos; but
not &apos;static&apos; or &apos;extern&apos; is unspecified.
Example: Let the following text represent two translation units:
module1.c

    void f() { }

module2.c

    inline void f() { }
    void g() { f(); }   /* which f() is called? */

The C99 Standard dictates that the above call to f() from g() in
module2.c may result in the execution of either f().
The programmer may avoid confusion and improve portability by using the
keyword &apos;static&apos; in addition to &apos;inline&apos;. The keyword &apos;extern&apos; can also
be used along with the &apos;inline&apos; to resolve this ambiguity; however, we
recommend using &apos;static&apos; because, as of this writing, more compilers
correctly interpret &apos;static inline&apos;.</c>
    </m>
    <m id="696">
        <c>The variable is being compared (using one of the 6 comparison
operations) with some other expression called the comperand. The
variable has a value that is out of the range of values of this
comperand. For example consider:

    void f(unsigned char ch) {
        int n = 1000;
        if (ch &lt; n)     // Message 696
        ...
    }

Here a message 696 will be issued stating that n has a value of 1000
that is out of range because 1000 is not in the set of values that ch
can hold (assuming default sizes of scalars).</c>
    </m>
    <m id="697">
        <c>A quasi-boolean value is being compared (using either != or ==) with a
value that is not the literal zero. A quasi-boolean value is any value
whose type is a strong boolean type and that could conceivably be
something other than zero or one. This is significant because in C, all
non-zero values are equally true. Example:

    /*lint -strong(AJXb, B) */
    typedef int B;
    #define YES ((B)1)
    #define NO ((B)0)

    B f( B a, B b ) {
        B c = ( a == NO);           /*OK, no Warning here*/
        B d = ( a == (b != NO) );   /* Warning 697 for == but not for != */
        B e = ( a == YES );         /* Warning 697 here */
        return d == c;              /* Warning 697 here */
    }

Note that if a and b had instead been declared with true boolean types,
such as &apos;bool&apos; in C++ or &apos;_Bool&apos; in C99, this diagnostic would not have
been issued.</c>
    </m>
    <m id="698">
        <c>A statement of the form:

    v = realloc( v, ... );

has been detected. Note the repeated use of the same variable. The
problem is that realloc can fail to allocate the necessary storage. In
so doing it will return NULL. But then the original value of v is
overwritten resulting in a memory leak.</c>
    </m>
    <m id="701">
        <c>Shifts are normally accomplished on unsigned operands. This message is
only emitted if sizeof(type) &lt;= sizeof(int).</c>
    </m>
    <m id="702">
        <c>Shifts are normally accomplished on unsigned operands. Shifting an int
right is machine dependent (sign fill vs. zero fill). This message is
only emitted if sizeof(type) &lt;= sizeof(int).</c>
    </m>
    <m id="703">
        <c>Shifts are normally accomplished on unsigned operands. This message is
only emitted if sizeof(type) &gt; sizeof(int).</c>
    </m>
    <m id="704">
        <c>Shifts are normally accomplished on unsigned operands. Shifting a long
to the right is machine dependent (sign fill vs. zero fill). This
message is only emitted if sizeof(type) &gt; sizeof(int).</c>
    </m>
    <m id="705">
        <c>The argument corresponding to a conversion specifier in a printf/scanf
style function was not of the correct type but was the same size as the
expected integer type. The format, expected argument type, argument
number, and the type of the data argument provided are reported.
Argument counts begin at 1 and include file, string, and data arguments.
For example:

    extern char * buffer;
    sprintf(buffer, &quot;%u&quot;, 371);

will elicit the message:

    format &apos;%u&apos; specifies type &apos;unsigned int&apos; which is nominally
    inconsistent with argument no. 3 of type &apos;int&apos;

In addition to differences in signedness of same-sized integers, two
types that are the same size and signedness but distinct types are also
reported by this message. For example, if int and long are the same
size, passing a long argument to %d will elicit this message.</c>
    </m>
    <m id="706">
        <c>The argument corresponding to a conversion specifier in a printf/scanf
style function was not of the correct type but was a pointer to a type
that is the same size as the expected pointee integer type. The format,
expected argument type, argument number, and the type of the data
argument provided are reported. Argument counts begin at 1 and include
file, string, and data arguments. For example:

    int j;
    scanf(&quot;%u&quot;, &amp;j);

will result in the message:

    format &apos;%u&apos; specifies type &apos;unsigned int *&apos; whose pointee type
    is nominally inconsistent with argument no. 2 of type &apos;int *&apos;

In addition to differences in signedness of same-sized integers,
pointers to types that are the same size and signedness but distinct
types are also reported by this message. For example, if int and long
are the same size, passing a long * argument to %d will elicit this
message.</c>
    </m>
    <m id="707">
        <c>The following is an example of a mixing of narrow and wide string
literals.

    const wchar_t *s = &quot;abc&quot; L&quot;def&quot;;

The concatenation of narrow and wide string literals results in
undefined behavior for C90 and C++2003. If your compiler supports such
combinations or you use a C/C++ dialect that supports such, you may
either suppress this message or consider making the concatenands match.</c>
    </m>
    <m id="708">
        <c>A union was initialized without explicitly specifying which member to
initialize. While the C and C++ standards state that the first member of
the union is initialized in such cases, other members may not have fully
initialized values. For example:

    union U { int a; int * p; };
    U u1 = { 0 };

On a system where int is 4 bytes and pointers are 8 bytes, the int
member of u1 is initialized to 0 but the bytes of p that do not overlap
with a are not initialized, which may come as a surprise, especially
since the behavior is dependent on the order in which the union members
are declared and on the size of pointers relative to ints.</c>
    </m>
    <m id="709">
        <c>Two -pch options were seen without an intervening module. This is
suspicious because the first -pch option has no effect in such a case as
only one PCH file can be used per module.</c>
    </m>
    <m id="712">
        <c>An assignment (or implied assignment, see context) is being made from a
source type (the first type) to a destination type (the second type) and
the first type is larger than the second type. A cast will suppress this
message.</c>
    </m>
    <m id="713">
        <c>An assignment (or implied assignment, see context) is being made from an
unsigned quantity to a signed quantity, that will result in the possible
loss of one bit of integral precision, such as converting from
unsigned int to int. A cast will suppress the message.</c>
    </m>
    <m id="714">
        <c>The named external variable or external function was defined but not
referenced. This message is suppressed for unit checkout (-unit_check
option).</c>
    </m>
    <m id="715">
        <c>The named formal parameter was not referenced.</c>
    </m>
    <m id="716">
        <c>A construct of the form while (1) or while (true) was found. While this
represents a constant value in a context expecting a Boolean - typically
reported by message 506 - it may reflect a programming policy to
indicate an intentional infinite loop. It is therefore given a separate
number and has been placed in the informational category. Some may
prefer to denote such loops using for (;;) instead.</c>
    </m>
    <m id="717">
        <c>A construct of the form do ... while (0) or do ... while (false) was found.
While this represents a constant value in a context expecting a Boolean
- typically reported by message 506 - it is probably a deliberate
attempt on the part of the programmer to encapsulate a sequence of
statements into a single statement. It is therefore given a separate
number and has been placed in the informational category .</c>
    </m>
    <m id="718">
        <c>A function was referenced without having been declared or defined within
the current module. Such implicit function declarations were removed in
C99 although some compilers still allow them. These implicit function
declarations were never allowed in C++ and referencing an undeclared
function in a C++ module will instead result in an error. Note that by
adding a declaration to another module, you will not suppress this
message. It can only be suppressed by placing a declaration within the
module being processed.</c>
    </m>
    <m id="719">
        <c>The number of data arguments passed to a printf/scanf style function was
more than what is specified in the format. This message is similar to
Warning 558, which alerts users to situations in which there were too
few arguments for the format. It receives a lighter Informational
classification because the additional arguments are simply ignored
whereas passing too few arguments results in undefined behavior.</c>
    </m>
    <m id="720">
        <c>An assignment was found in a context that requires a Boolean (such as
the condition of an if or while statement). This may be legitimate or it
could have resulted from a mistaken use of = for ==. If the assignment
was intentional, placing additional parenthesis around the assignment
(e.g. if ((a = b))) will suppress this message.</c>
    </m>
    <m id="721">
        <c>A semi-colon was found immediately to the right of a right parenthesis
in a construct of the form if(e);. As such it may be overlooked or
confused with the use of semi-colons to terminate statements. The
message will be inhibited if the &apos;;&apos; is separated by at least one blank
from the &apos;)&apos;. Better, place it on a separate line. See also message 548.</c>
    </m>
    <m id="722">
        <c>A semi-colon was found immediately to the right of a right parenthesis
in a construct of the form while(e); or for(e;e;e); As such it may be
overlooked or confused with the use of semi-colons to terminate
statements. The message will be inhibited if the &apos;;&apos; is separated by at
least one blank from the &apos;)&apos;. Better, place it on a separate line.</c>
    </m>
    <m id="723">
        <c>A preprocessor definition began with an = sign. For example:

    #define LIMIT = 50

Was this intentional? Or was the programmer thinking of assignment when
he wrote this?</c>
    </m>
    <m id="725">
        <c>The current line was found to be aligned with, rather than indented with
respect to, the indicated line. The indicated line corresponds to a
clause introducing a control structure and statements within its scope
are expected to be indented with respect to it. If tabs within your
program are other than 8 blanks you should use the -t option (See
Section &quot;Indentation-Checking&quot; in the Reference Manual).</c>
    </m>
    <m id="726">
        <c>A comma followed by a right-brace within an enumeration is not a valid
ANSI/ISO construct. The comma is ignored. This message is only emitted
in C90 and C++03 modes as later versions allow this construct.</c>
    </m>
    <m id="727">
        <c>The named static variable (local to a function) was not explicitly
initialized before use. The following remarks apply to messages 728 and
729 as well as 727. By no explicit initialization we mean that there was
no initializer present in the definition of the object, no direct
assignment to the object (or any of its elements or members), and no
address operator applied to the object or, if the address of the object
was taken, it was assigned to a pointer to const. Arrays are also
considered to be explicitly initialized if the result of array to
pointer decay is assigned to a non-const pointer.
These messages do not necessarily signal errors since the implicit
initialization for static variables is 0. However, the messages are
helpful in indicating those variables that you had forgotten to
initialize to a value. To extract the maximum benefit from the messages
we suggest that you employ an explicit initializer for those variables
that you want to initialize to 0. For example:

    static int n = 0;

For variables that will be initialized dynamically, do not use an
explicit initializer as in:

    static int m;

This message will be given for any array, class, struct or union if no
member or element has been assigned a value. The fde flag controls how
initialization using a default constructor is interpreted in C++.</c>
    </m>
    <m id="728">
        <c>The named intra-module variable (static variable with file scope) was
not explicitly initialized. See the comments on message 727 for more
details.</c>
    </m>
    <m id="729">
        <c>The named inter-module variable (external variable) was not explicitly
initialized. See the comments on message 727 for more details. This
message is suppressed for unit checkout (-unit_check) and will not
report C++ classes.</c>
    </m>
    <m id="730">
        <c>A Boolean was used as an argument to a function. Was this intended? Or
was the programmer confused by a particularly complex conditional
statement? Experienced C programmers often suppress this message. This
message is given only if the associated parameter is not declared bool.</c>
    </m>
    <m id="731">
        <c>A Boolean operator was used as an argument to == or !=. For example:

    if( (a &gt; b) == (c &gt; d) )     ...

tests to see if the inequalities are of the same value. This could be an
error as it is an unusual use of a Boolean (see Warnings 503 and 514)
but it may also be deliberate since this is the only way to efficiently
achieve equivalence or exclusive or. Because of this possible use, the
construct is given a relatively mild &apos;informational&apos; classification. If
the Boolean argument is cast to some type, this message is not given.
Additionally, this message is not necessarily given just because one of
the arguments to == or != is a Boolean type but only if at least one of
the arguments is expressed using a Boolean operator. For example, if e
and f are of type bool, the clause:

    if( e == f ) ...

will not prompt this message. However,

    if( e == !f ) ...

will.</c>
    </m>
    <m id="732">
        <c>An assignment (or implied assignment, see context) is made from a signed
quantity to an unsigned quantity. Also, it could not be determined that
the signed quantity had no sign. For example:

    u = n;     /* Info 732 */
    u = 4;     /*  OK      */

where u is unsigned and n is not, warrants a message only for the first
assignment, even though the constant 4 is nominally a signed int.
Make sure that this is not an error (that the assigned value is never
negative) and then use a cast (to unsigned) to remove the message.</c>
    </m>
    <m id="733">
        <c>The address of an auto variable is valid only within the block in which
the variable is declared. An address to such a variable has been
assigned to a variable that has a longer life expectancy. There is an
inherent danger in doing this.</c>
    </m>
    <m id="734">
        <c>An assignment is being made into an object smaller than an int. The
information being assigned is derived from another object or combination
of objects in such a way that information could potentially be lost. The
number of bits given does not count the sign bit. For example if ch is a
char and n is an int then:

    ch = n;

will trigger this message whereas:

    ch = n &amp; 1;

will not. To suppress the message a cast can be made as in:

    ch = (char) n;

You may receive notices involving multiplication and shift operators
with subinteger variables. For example:

    ch = ch &lt;&lt; 2;
    ch = ch * ch;

where, for example, ch is an unsigned char. These can be suppressed by
using the flag +fpm (precision of an operator is bound by the maximum of
its operands).</c>
    </m>
    <m id="735">
        <c>An assignment (or implied assignment, see context) is made from a
long double to a double. Using a cast will suppress the message. The
number of bits includes the sign bit.</c>
    </m>
    <m id="736">
        <c>An assignment (or implied assignment, see context) is being made to a
float from a value or combination of values that appear to have higher
precision than a float. You may suppress this message by using a cast.
The number of bits includes the sign bit.</c>
    </m>
    <m id="737">
        <c>An unsigned quantity was joined with a signed quantity in a binary
operator (or 2nd and 3rd arguments to the conditional operator) and the
signed quantity is implicitly converted to unsigned. The message will
not be given if the signed quantity is an unsigned constant, a Boolean,
or an expression involving bit manipulation. For example,

    u &amp; ~0xFF

where u is unsigned does not draw the message even though the operand on
the right is technically a signed integer constant. It looks enough like
an unsigned to warrant not giving the message.
This mixed mode operation could also draw Warnings 573 or 574 depending
upon the operator involved.
You may suppress the message with a cast but you should first determine
whether the signed value could ever be negative or whether the unsigned
value can fit within the constraints of a signed quantity.</c>
    </m>
    <m id="738">
        <c>The named static local variable was not initialized before being passed
to a function whose corresponding parameter is declared as pointer to
const. Is this an error or is the programmer relying on the default
initialization of 0 for all static items? By employing an explicit
initializer you will suppress this message. See also message numbers 727
and 603.</c>
    </m>
    <m id="739">
        <c>The indicated Trigraph (three-character) sequence was found within a
string. This trigraph reduces to a single character according to the
ANSI/ISO standards. This represents a &quot;Quiet Change&quot; from the past where
the sequence was not treated as exceptional. If you had no intention of
mapping these characters into a single character you may precede the
initial &apos;?&apos; with a backslash. If you are aware of the convention and you
intend that the Trigraph be converted you should suppress this
informational message.</c>
    </m>
    <m id="742">
        <c>A character constant was found that contained multiple characters, e.g.,
&apos;ab&apos;. This is legal C but the numeric value of the constant is
implementation defined. It may be safe to suppress this message because,
if more characters are provided than what can fit in an int, message
number 25 is given.</c>
    </m>
    <m id="743">
        <c>A character constant was specified whose value is some negative integer.
For example, on machines where a byte is 8 bits, the character constant
&apos;\xFF&apos; is flagged because its value (according to the ANSI/ISO standard)
is -1 (its type is int). Note that its value is not 0xFF.</c>
    </m>
    <m id="744">
        <c>A switch statement has no section labeled default. Was this an
oversight? It is standard practice in many programming groups to always
have a default: case. This can lead to better (and earlier) error
detection. One way to suppress this message is by introducing a vacuous
default break; statement. If you think this adds too much overhead to
your program, think again. In all cases tested so far, the introduction
of this statement added absolutely nothing to the overall length of
code. If you accompany the vacuous statement with a suitable comment,
your code will at least be more readable.
This message is not given if the control expression is an enumerated
type. In this case, all enumerated constants are expected to be
represented by case statements, else 787 will be issued.</c>
    </m>
    <m id="746">
        <c>A call to a function is not made in the presence of a prototype. This
does not mean that PC-lint Plus is unaware of any prototype; it means
that a prototype is not in a position where a compiler will see it. If
you have not adopted a strict prototyping convention you will want to
suppress this message with -e746.</c>
    </m>
    <m id="749">
        <c>A member (name provided as symbol) of an enum was defined in a module
but was not otherwise used within that module. A &apos;local&apos; member is one
that is not defined in a header file. Compare with messages 754 and 769.</c>
    </m>
    <m id="750">
        <c>A &apos;local&apos; macro is one that is not defined in a header file. The macro
is not referenced throughout the module in which it is defined.</c>
    </m>
    <m id="751">
        <c>A &apos;local&apos; typedef symbol is one that is not defined in any header file.
It may have file scope or block scope but it was not used through its
scope.</c>
    </m>
    <m id="752">
        <c>A &apos;local&apos; declarator symbol is one declared in a declaration appearing
in the module file itself as opposed to a header file. The symbol may
have file scope or may have block scope. But it wasn&apos;t referenced.</c>
    </m>
    <m id="753">
        <c>string is one of struct, class, union, or enum and symbol is the name of
the tag. A &apos;local&apos; tag is one not defined in a header file. Since its
definition appeared, why was it not used? Use of a tag is implied by the
use of any of its members.</c>
    </m>
    <m id="754">
        <c>A member (name provided as symbol) of a struct, class, or union (as
indicated in string) was defined in a module but was not otherwise used
within that module. A &apos;local&apos; member is one that is not defined in a
header file. See message 768.</c>
    </m>
    <m id="755">
        <c>A &apos;global&apos; macro is one defined in a header file. The macro is not used
in any of the modules comprising the program. This message is suppressed
for unit checkout (-unit_check option).</c>
    </m>
    <m id="756">
        <c>This message is given for a typedef symbol declared in a non-library
header file. The symbol is not used in any of the modules comprising a
program. This message is suppressed for unit checkout (-unit_check
option).</c>
    </m>
    <m id="757">
        <c>A &apos;global&apos; declarator is one defined in a header file. This message is
given for objects declared in non-library header files that have not
been used in any module comprising the program being checked. The
message is suppressed for unit checkout (-unit_check).</c>
    </m>
    <m id="758">
        <c>A &apos;global&apos; tag is one that is defined in a header file. This message is
given for struct, union and enum tags that have been defined in
non-library header files and that have not been used in any module
comprising the program. The message is suppressed for unit checkout
(-unit_check).</c>
    </m>
    <m id="759">
        <c>This message is given for declarations, within non-library header files,
that are not referenced outside the defining module. Hence, it can be
moved inside the module and thereby &apos;lighten the load&apos; on all modules
using the header. This message is given only when more than one module
is being linted.</c>
    </m>
    <m id="760">
        <c>The given macro was defined earlier in the same way and is hence
redundant.</c>
    </m>
    <m id="761">
        <c>A typedef symbol has been declared earlier and is redundant. Although
the declarations are consistent you should probably remove the second.</c>
    </m>
    <m id="764">
        <c>A switch statement has been found that does not have a case statement
associated with it (it may or may not have a default statement). This is
normally a useless construct.</c>
    </m>
    <m id="765">
        <c>An external symbol was referenced in only one module. It was not
declared static. Some programmers like to make static every symbol they
can, because this lightens the load on the linker. It also represents
good documentation.</c>
    </m>
    <m id="767">
        <c>Two macros processed in two different modules had inconsistent
definitions.</c>
    </m>
    <m id="768">
        <c>A member (name provided as symbol) of a struct or union appeared in a
non-library header file but was not used in any module comprising the
program. This message is suppressed for unit checkout. Since a struct
may be replicated in storage, finding an unused member can pay handsome
storage dividends. However, many structures merely reflect an agreed
upon convention for accessing storage and for any one program, many
members are unused. In this case, receiving this message can be a
nuisance. One convenient way to avoid unwanted messages (other than the
usual -e and -esym) is to always place such structures in library header
files. Alternatively, you can place the struct within a ++flb ... -flb
sandwich to force it to be considered library.</c>
    </m>
    <m id="769">
        <c>A member (name provided as symbol) of an enum appeared in a non-library
header file but was not used in any module comprising the program. This
message is suppressed for unit checkout. There are reasons why a
programmer may occasionally want to retain an unused enum and for this
reason this message is distinguished from 768 (unused member). See
message 768 for ways of selectively suppressing this message.</c>
    </m>
    <m id="770">
        <c>The struct, union, or enum tag symbol was defined identically in
different locations (usually two different files). This is not an error
but it is not necessarily good programming practice either. It is better
to place common definitions of this kind in a header file where they can
be shared among several modules. If you do this, you will not get this
message. Note that if the tag is defined differently in different
scopes, you will receive warning 631 rather than this message.</c>
    </m>
    <m id="773">
        <c>A macro that appeared to be an expression contained unparenthesized
binary operators and therefore may result in unexpected associations
when used with other operators. For example,

    #define A B + 1

may be used later in the context:

    f( A * 2 );

with the surprising result that B+2 gets passed to f and not the
(B+1)*2. Corrective action is to define A as:

    #define A (B + 1)

Highest precedence binary operators are not reported upon. Thus:

    #define A s.x

does not elicit this message because this case does not seem to
represent a problem. Also, unparenthesized unary operators (including
casts) do not generate this message.</c>
    </m>
    <m id="774">
        <c>The indicated clause (detail is one of if, while or for (2nd
expression)) has an argument that appears to always evaluate to either
&apos;true&apos; or &apos;false&apos; (as indicated in the message). Information is gleaned
from a variety of sources including prior assignment statements and
initializers. Compare this with message 506, which is based on testing
constants or combinations of constants. Also compare with the Elective
Note 944, which can sometimes provide more detailed information. See
Chapter &quot;Value Tracking&quot; in the Reference Manual.</c>
    </m>
    <m id="775">
        <c>A non-negative quantity is being compared for being &lt;=0. This is a
little suspicious since a non-negative quantity can be equal to 0 but
never less than 0. The non-negative quantity may be of type unsigned or
may have been promoted from an unsigned type or may have been judged not
to have a sign by virtue of it having been AND&apos;ed with a quantity known
not to have a sign bit, an enum that may not be negative, etc. See also
Warning 568.</c>
    </m>
    <m id="776">
        <c>An int expression (signed or unsigned) involving addition or subtraction
is converted to long implicitly or explicitly. Moreover, the precision
of a long is greater than that of int. If an overflow occurred,
information would be lost. Either cast one of the operands to some form
of long or cast the result to some form of int.
See Warning 647 for a further description and an example of this kind of
error. See also messages 790 and 942.</c>
    </m>
    <m id="777">
        <c>This message is issued when the operands of operators == and != are some
form of floating type (float, double, or long double). Testing for
equality between two floating point quantities is suspect because of
round-off error and the lack of perfect representation of fractions. If
your numerical algorithm calls for such testing turn the message off.
The message is suppressed when one of the operands can be represented
exactly, such as 0 or 13.5.</c>
    </m>
    <m id="778">
        <c>A constant expression involving addition, subtraction, multiplication,
shifting, or negation resulted in a 0. This could be a purposeful
computation but could also have been unintended. If this is intentional,
suppress the message. If one of the operands is 0, Elective Note 941 may
be issued rather than a 778.</c>
    </m>
    <m id="779">
        <c>A string constant appeared as an argument to a comparison operator. For
example:

    if( s == &quot;abc&quot; ) ...

This is usually an error. Did the programmer intend to use strcmp? It
certainly looks suspicious. At the very least, any such comparison is
bound to be machine-dependent. If you cast the string constant, the
message is suppressed.</c>
    </m>
    <m id="783">
        <c>This message is issued when an input line is not terminated by a
new-line or when a NUL character appears within an input line. If your
editor is in the habit of not appending new-lines onto the end of the
last line of the file then suppress this message. Otherwise, examine the
file for NUL characters and eliminate them.</c>
    </m>
    <m id="784">
        <c>During initialization of an array with a string constant there was not
enough room to hold the trailing NUL character. For example:

    char a[3] = &quot;abc&quot;;

would evoke such a message. This may not be an error since the easiest
way to do this initialization is in the manner indicated. It is more
convenient than:

    char a[3] = { &apos;a&apos;, &apos;b&apos;, &apos;c&apos; };

On the other hand, if it really is an error it may be especially
difficult to find.</c>
    </m>
    <m id="785">
        <c>The number of initializers in a brace-enclosed initializer was less than
the number of items in the aggregate. Default initialization is taken.
An exception is made with the initializer {0}. This is given a separate
message number in the Elective Note category (943). It is normally
considered to be simply a stylized way of initializing all members to 0.
See also 9068.</c>
    </m>
    <m id="786">
        <c>Although it is perfectly &apos;legal&apos; to concatenate string constants within
an initializer, this is a frequent source of error. Consider:

    char *s[] = { &quot;abc&quot; &quot;def&quot; };

Did the programmer intend to have an array of two strings but forget the
comma separator? Or was a single string intended?</c>
    </m>
    <m id="787">
        <c>A switch expression is an enumerated type and at least one of the
enumerated constants was not present as a case label. Moreover, no
default case was provided.</c>
    </m>
    <m id="788">
        <c>A switch expression is an enumerated type and at least one of the
enumerated constants was not present as a case label. However, unlike
Info 787, a default case was provided. This is a mild form of the case
reported by Info 787. The user may thus elect to inhibit this mild form
while retaining Info 787.</c>
    </m>
    <m id="789">
        <c>The address of an auto variable (symbol) is being assigned to a static
variable. This is dangerous because the static variable will persist
after return from the function in which the auto is declared but the
auto will be, in theory, gone. This can prove to be among the hardest
bugs to find. If you have one of these, make certain there is no error
and use -esym to suppress the message for a particular variable.</c>
    </m>
    <m id="790">
        <c>This message is issued when it appears that there may have been an
unintended loss of information during an operation involving integrals,
the result of which is later converted to a floating point quantity. The
operations that are scrutinized and reported upon by this message are:
shift left and multiplication. Addition and subtraction are covered by
note 942. See also messages 647 and 776.</c>
    </m>
    <m id="791">
        <c>A temporary message suppression option (one having the form: !e...)
followed a regular option. Was this intended?</c>
    </m>
    <m id="792">
        <c>A void expression has been cast to void. Was this intended?</c>
    </m>
    <m id="793">
        <c>An ANSI/ISO minimum translation limit has been exceeded. These limits
are described under the heading &quot;Translation limits&quot; in the ANSI/ISO C
Standards and under the heading &quot;Implementation Quantities&quot; in the C++
standards. Programs exceeding these limits are not considered maximally
portable. However, they may work for individual compilers.
The integer parameter indicates the numeric value that was exceeded and
string provides a textual description of the limit in question.
Say a large program exceeds the ANSI/ISO limit of 4095 external
identifiers. This will result in the message:

    793 ANSI/ISO minimum translation limit of 4095 &apos;external identifiers&apos;
        exceeded, processing is unaffected

It may not be obvious how to inhibit this message for identifiers while
leaving other limits in a reportable state. The second parameter of the
message is designated string and so the -estring may be used. Because
the string contains a blank, quotes must be used. The option becomes:

    -estring(793,&quot;external identifiers&apos;)

See &quot;Language Limits&quot; in the Reference Manual for additional information
and a list of supported limits.</c>
    </m>
    <m id="798">
        <c>The indicated character is redundant and can be eliminated from the
input source. A typical example is a backslash on a line by itself.</c>
    </m>
    <m id="799">
        <c>An integral constant was found to be larger than the largest value
allowed for unsigned long quantities. By default, an unsigned long is 4
bytes but can be respecified via the option -sl#. If the long long type
is permitted (see option +fll) this message is automatically suppressed.
See also message 417.</c>
    </m>
    <m id="801">
        <c>A goto was detected. Use of the goto is not considered good programming
practice by most authors and its use is normally discouraged. There are
a few cases where the goto can be effectively employed but often these
can be rewritten just as effectively without the goto. The use of goto
statements can have a devastating effect on the structure of large
functions creating a mass of spaghetti-like confusion. For this reason
its use has been banned in many venues.</c>
    </m>
    <m id="805">
        <c>An initializer for a wide character array or pointer did not use a
preceding &apos;L&apos;. For example:

    wchar_t a[] = &quot;abc&quot;;

was found whereas

    wchar_t a[] = L&quot;abc&quot;;

was expected.</c>
    </m>
    <m id="806">
        <c>A small bit field (less than an int wide) was found and the base type is
signed rather than unsigned. Since the most significant bit is a sign
bit, this practice can produce surprising results. For example,

    struct { int b:1; } s;
    s.b = 1;
    if( s.b &gt; 0 ) /* should succeed but actually fails */
        ...</c>
    </m>
    <m id="808">
        <c>An explicit type was missing in a declaration. Unlike Warning 601, the
declaration may have been accompanied by a storage class or modifier
(qualifier) or both. For example:

    extern f(void);

will draw message 808. Had the extern not been present, a 745 would have
been raised.
The keywords unsigned, signed, short and long are taken to be explicit
type specifiers even though int is implicitly assumed as a base.</c>
    </m>
    <m id="809">
        <c>The value held by a pointer variable may have been the address of an
auto variable. It is normally incorrect to return the address of an item
on the stack because the portion of the stack allocated to the returning
function is subject to being obliterated after return.</c>
    </m>
    <m id="810">
        <c>We define the custodial variable as that variable directly receiving the
result of a malloc or new or equivalent call. It is inappropriate to
modify such a variable because it must ultimately be free&apos;ed or
delete&apos;ed. You should first make a copy of the custodial pointer and
then modify the copy. The copy is known as an alias.</c>
    </m>
    <m id="812">
        <c>The amount of storage for a static symbol has reached or exceeded a
value that was specified in a -size option.</c>
    </m>
    <m id="813">
        <c>The amount of storage for an auto symbol has reached or exceeded a value
that was specified in a -size option.</c>
    </m>
    <m id="814">
        <c>A tagless struct was declared without a declarator. For example:

    struct { int n; };

Such a declaration cannot very well be used.</c>
    </m>
    <m id="815">
        <c>An allocation expression (malloc, calloc, new) is not immediately
assigned to a variable but is used as an operand in some expression.
This would make it difficult to free the allocated storage. For example:

    p = new X[n] + 2;

will elicit this message. A preferred sequence is:

    q = new X[n];
    p = q+2;

In this way the storage may be freed via the custodial pointer q.
Another example of a statement that will yield this message is:

    p = new (char *) [n];

This is a gruesome blunder on the part of the programmer. It does NOT
allocate an array of pointers as a novice might think. It is parsed as:

    p = (new (char *)) [n];

which represents an allocation of a single pointer followed by an index
into this &apos;array&apos; of one pointer.</c>
    </m>
    <m id="816">
        <c>A non-standard format specifier was found in a format-processing
function such as printf or scanf. The format was recognized as being a
common extension. If the format was not recognized, a more severe
warning (557) would have been issued. The non-ISO conversion specifiers
that are recognized are:

  ---- ------------------------------ ---------------------------------------------------
  %C   wchar_t                        XSI/MS extension, equivalent to %lc
  %D   int                            Apple extension, synonym for %d
  %O   unsigned int                   Apple extension, synonym for %o
  %S   wchar_t *                      XSI/MS extension, equivalent to %ls
  %U   unsigned int                   Apple extension, synonym for %u
  %Z   ANSI_STRING / UNICODE_STRING   MS extension
  %m   none                           Glibc extension, prints output of strerror(errno)
  ---- ------------------------------ ---------------------------------------------------</c>
    </m>
    <m id="818">
        <c>As an example:

    int f( int *p ) { return *p; }

can be redeclared as:

    int f( const int *p ) { return *p; }

Declaring a parameter a pointer to const offers advantages that a mere
pointer does not. In particular, you can pass to such a parameter the
address of a const data item. In addition it can offer better
documentation.
Other situations in which a const can be added to a declaration are
covered in messages 952, 953, 954 and 1764.</c>
    </m>
    <m id="820">
        <c>A Boolean test was made on the result of an assignment and, moreover,
the assignment was parenthesized. For example:

    if ( (a = b) ) ...  // Info 820

will draw this informational whereas

    if ( a = b )  ...  // Info 720

(i.e. the unparenthesized case) will, instead, draw Info 720. We, of
course, do not count the outer parentheses, required by the language,
that always accompany the if clause.
The reason for partitioning the messages in this fashion is to allow the
programmer to adopt the convention, advanced by some compilers (in
particular gcc), of always placing a redundant set of parentheses around
any assignment that is to be tested. In this case you can suppress Info
820 (via -e820) while still enabling Info 720.</c>
    </m>
    <m id="821">
        <c>An assignment operator was found having one of the following forms:

    a = b || c
    a = b &amp;&amp; c
    a = b ? c : d

Moreover, the assignment appeared in a context where a value was being
obtained. For example:

    f( a = b ? c : d );

The reader of such code could easily confuse the assignment for a test
for equality. To eliminate any such doubts we suggest parenthesizing the
right hand side as in:

    f( a = (b ? c : d) );</c>
    </m>
    <m id="823">
        <c>The last token in the replacement text of the specified macro was a
semi-colon. In addition to limiting the places where the macro can be
used, this can result in unintentional behavior when the macro is used
in what appears to be a larger expression. For example, in:

    #define SUM(x, y) ((x) + (y));
    void foo(int a, int b) {
        int result = SUM(a, b) + 1;
    }

result will be the sum of a and b without the + 1.</c>
    </m>
    <m id="825">
        <c>A common programming mistake is to forget a break statement between case
statements of a switch. For example:

    case &apos;a&apos;: a = 0;
    case &apos;b&apos;: a++;

Is the fall through deliberate or is this a bug? To signal that this is
intentional use the -fallthrough option within a lint comment as in:

    case &apos;a&apos;: a = 0;
        //lint -fallthrough
    case &apos;b&apos;:  a++;

This message is similar to Warning 616 (&quot;control flows into
case/default&quot;) and is intended to provide a stricter alternative.
Warning 616 is suppressed by any comment appearing at the point of the
fallthrough. Thus, an accidental omission of a break can go undetected
by the insertion of a neutral comment. This can be hazardous to
well-commented programs.</c>
    </m>
    <m id="826">
        <c>A pointer was converted into another either implicitly or explicitly.
The area pointed to by the destination pointer is larger than the area
that was designated by the source pointer. For example:

    long *f( char *p ) { return (long *) p; }</c>
    </m>
    <m id="827">
        <c>A loop structure (for, while, or do) could not be reached. Was this an
oversight? It may be that the body of the loop has a labeled statement
and that the plan of the programmer is to jump into the middle of the
loop through that label. It is for this reason that we give an
Informational message and not the Warning (527) that we would normally
deliver for an unreachable statement. But please note that jumping into
a loop is a questionable practice in any regard.</c>
    </m>
    <m id="828">
        <c>A function with built-in semantics or user-defined semantics was
#define&apos;d to be some other function with a similar name formed by
prepending or appending underscores. For example:

    #define strcmp(a,b) __strcmp__(a,b)

will cause Info 828 to be issued. As the message indicates, the
semantics will be automatically transferred to the new function.</c>
    </m>
    <m id="829">
        <c>Some coding standards discourage or even prohibit the use of certain
header files. PC-lint Plus can guard against their use by activating the
lint option +headerwarn(file). Later, if the file is used, we will then
issue this message.</c>
    </m>
    <m id="831">
        <c>This message provides supplemental value tracking history information
and is attached to a proceeding value tracking message. Multiple 831
messages may be provided for single value tracking message and the exact
verbiage will vary depending on the situation. For example:

    short f(short x, short y) {
        if (x &gt;= 10 &amp;&amp; x &lt;= 20) {
            return y / (x - 15);
        }
        ....

results in:

    warning 414: possible division by zero
            return y / (x - 15);
                     ^ ~~~~~~~~
    supplemental 831: operator - yields -5:5
            return y / (x - 15);
                        ~~^~~~
    supplemental 831: integral conversion yields 10:20
            return y / (x - 15);
                        ^
    supplemental 831: inference yields 10:20
        if (x &gt;= 10 &amp;&amp; x &lt;= 20) {
        ^              ~~~~~~~
    supplemental 831: inference yields 10:32767
        if (x &gt;= 10 &amp;&amp; x &lt;= 20) {
        ^   ~~~~~~~

The main message is 414 - &quot;possible division by zero&quot; and the 831
messages show the steps that lead PC-lint Plus to make this
determination. Starting from the bottom up, the last message indicates
the left-hand side of the &amp;&amp; operator resulted in an inference that the
lower bound of x must be 10. The right-hand side served to constrain the
upper bound of x. At the point of the return statement, PC-lint Plus
knows that the value of x is between 10 and 20, inclusive. The value of
the expression x - 15 therefore is between -5 and 5. Since this is a
constrained range that contains the value zero and is being used as a
divisor, message 414 is issued.</c>
    </m>
    <m id="832">
        <c>In an old-style function definition a parameter was not explicitly
declared. To illustrate:

    void f( n, m )
         int n;
         { ...

This is an example of an old-style function definition with n and m the
parameters. n is explicitly declared and m is allowed to default to int.
An 832 will be issued for m.</c>
    </m>
    <m id="834">
        <c>Some combinations of operators seem to be confusing. For example:

    a = b - c - d;
    a = b - c + d;
    a = b / c / d;
    a = b / c * d;

tend to befuddle the reader. To reduce confusion we recommend using
parentheses to make the association of these operators explicit. For
example:

    a = (b - c) - d;
    a = (b - c) + d;
    a = (b / c) / d;
    a = (b / c) * d;

in place of the above.</c>
    </m>
    <m id="835">
        <c>A 0 has been provided as an operand to an arithmetic operator. The name
of the operator is provided in the message as well as the side of the
operator (left or right) that had the unusual value. For example:

    n = n + 0 - m;

will produce a message that the right hand operand of operator &apos;+&apos; is
zero. In general the operators examined are the binary operators:

    + - * / % | &amp; ^ &lt;&lt; &gt;&gt;

and the unary operators - and +. An enumeration constant whose value is
0 is permitted with operators:

    + - &gt;&gt; &lt;&lt;

Otherwise a message is issued. For example:

    enum color { red,
               blue = red+100,      /* ok */
               green = red*0x10     /* 835 */
               };

The assignment operators that have an arithmetic or bitwise component,
such as |=, are also examined. The message given is equivalent to that
given with the same operator without the assignment component.</c>
    </m>
    <m id="837">
        <c>The condition of a switch statement is a constant expression as in:

    switch(5) {
        ...
    }

While legal, this is suspect since the point of a switch statement is
usually to specify different actions depending on the value of a
variable.</c>
    </m>
    <m id="838">
        <c>An assignment statement was encountered that apparently obliterated a
previously assigned value that had never had the opportunity of being
used. For example, consider the following code fragment:

    y = 1;
    if( n &gt; 0 ) y = 2;
    y = 4;              // Informational 838 ...

Here we can report that the assignment of 4 to y obliterates previously
assigned values that were not used. We, of course, cannot report
anything unusual about the assignment of 2. This will assign over a
prior value of 1 that so far had not been used but the existence of an
alternative path means that the value of 1 can still be employed later
in the code and is accepted for the time being as reasonable. It is only
the final assignment that raises alarm bells. See also Warning message
438.</c>
    </m>
    <m id="839">
        <c>A declaration for a symbol that was previously declared static in the
same module was found without the &apos;static&apos; specifier. For example:

    static void f();
    extern void f();    // Info 839
    void f() {}         // Info 839

By the rules of the language &apos;static&apos; wins and the symbol is assumed to
have internal linkage. This could be the definition of a previously
declared static function (as in line 3 of the above example) in which
case, by adding the static specifier, you will inhibit this message.
This could also be a redeclaration of either a function or a variable
(as in line 2 of the above example) in which case the redeclaration is
redundant.</c>
    </m>
    <m id="840">
        <c>A nul character was found in a string literal. This is legal but
suspicious and may have been accidental. This is because a nul character
is automatically placed at the end of a string literal and because
conventional usage and most of the standard library&apos;s string functions
ignore information past the first nul character.</c>
    </m>
    <m id="843">
        <c>A variable of static storage duration is initialized but never modified
thereafter. Was this an oversight? If the intent of the programmer is to
not modify the variable, it could and should be declared as const . See
also message 844.</c>
    </m>
    <m id="844">
        <c>The data pointed to by a pointer of static storage duration is never
changed (at least not through that pointer). It therefore would be
better if the variable were typed pointer to const . See also message
843.</c>
    </m>
    <m id="845">
        <c>An operand that can be deduced to always be 0 has been presented to an
arithmetic operator in a context that arouses suspicion. The name of the
operator is provided in the message as well as the side of the operator
(left or right) that had the unusual value. For example:

    n = 0;
    k = m &amp; n;

will produce a message that the right hand operand of operator &apos;&amp;&apos; is
certain to be zero.
The operands examined are the right hand sides of operators

    + - | ||

the left hand sides of operators

    / %

and both sides of operators

    * &amp; &lt;&lt; &gt;&gt; &amp;&amp;

The reason that the left hand side of operator + (and friends) is not
examined for zero is that zero is the identity operation for those
operators and hence is often used as an initializing value. For example:

    sum = 0;
    for( ... )
        sum = sum + what_ever;   // OK, no message

The message is not issued for arithmetic constant zeros. Message 835 is
issued in that instance.
The message is also suspended when the expression that evaluates to zero
contains side-effects. For example:

    i = 0;
    *(buf + i++) = &apos;A&apos;;     /* Okay */</c>
    </m>
    <m id="846">
        <c>A bit-field was defined with a non-Boolean non-enumeral integer type
without an explicit signed or unsigned specifier. E.g.:

    int a:5;

Most bit fields are more useful when they are unsigned. If you want to
have a signed bit field you must explicitly indicate this as follows:

    signed int a:5;

The same also holds for typedef&apos;s. For example,

    typedef int INT;
    typedef signed int SINT;
    struct  {
            INT a:16;    // info 846
            SINT b:16;   // OK
            }:

It is unusual in C or C++ to distinguish between signed int and plain
int; this is one of those rare cases. Note that this message will not be
issued within a C++ module using C++14 or later .</c>
    </m>
    <m id="849">
        <c>Two enumerators have the same value. For example:

    enum colors { red, blue, green = 1 };

will elicit this informational message. This is not necessarily an error
and you may want to suppress this message for selected enumerators.</c>
    </m>
    <m id="850">
        <c>A for loop with an identifiable loop index variable was programmed in
such a way that the loop body also modifies the index variable. For
example:

    void foo(int *a) {
        for (int i = 0; i &lt; 100; i++) {
            a[i++] = 0;
        }
    }

In general it is better to restrict modifications of for loop index
variables to the for clause if at all possible. If this is not possible,
you can prefix the for loop with an appropriate lint comment such as:

    /*lint -e{850} i is modified in the body of the for loop */</c>
    </m>
    <m id="853">
        <c>A &apos;/*&apos; sequence was encountered inside of a C-style comment while the
fnc (nested comments) flag was ON. Since nested comments have been
enabled, the next &apos;*/&apos; sequence that is encountered will only terminate
the nested comment, not the containing comment. The purpose of this
message is to alert you of this fact.</c>
    </m>
    <m id="854">
        <c>This message is issued when trigraphs are enabled and a trigraph
sequence is replaced.</c>
    </m>
    <m id="855">
        <c>Positional arguments are a POSIX extension to C and will not behave as
expected on systems that do not support this extension. PC-lint Plus
understands and will diagnose misuse specific to positional arguments
via messages 493, 494, 2401, and 2404.</c>
    </m>
    <m id="856">
        <c>Within a format string for a printf or scanf like function, a
combination of flags was used in which one of the flags has no effect in
the presence of the other. For example:

    extern int i;
    printf(&quot;%-0d&quot;, i);

Will elicit the message:

    flag &apos;0&apos; is ignored when flag &apos;-&apos; is present

because a left-justified field (requested via the &apos;-&apos; flag), cannot be
padded with zeroes (requested via the &apos;0&apos; flag). Such combinations do
not result in undefined behavior but likely represent a programming
error.</c>
    </m>
    <m id="857">
        <c>The first two arguments in a call to memcmp, memmove, or memcpy are not
compatible. Using these functions to compare or copy data between
different types may have unexpected results.</c>
    </m>
    <m id="865">
        <c>Message 865 is issued as a result of the -message option. For example:

    #ifndef N
    //lint -message(Please supply a definition for N)
    #endif

will issue the message only if N is undefined. See option -message.</c>
    </m>
    <m id="866">
        <c>An expression used as an argument to sizeof() counts as &quot;unusual&quot; if it
is not a constant, a symbol, a function call, a member access, a
subscript operation (with indices of zero or one), or a dereference of
the result of a symbol, scoped symbol, array subscript operation, or
function call. Also, since unary &apos;+&apos; could legitimately be used to
determine the size of a promoted expression, it does not fall under the
category of &quot;unusual&quot;. Example:

    char A[10];
    unsigned end = sizeof(A - 1);           // 866: was &apos;sizeof(A) - 1&apos; intended?
    size_of_promoted_char = sizeof(+A[0]);  // OK, + makes a difference
    size_t s1 = sizeof( end+1 );            // 866: use +end to get promoted type
    size_t s2 = sizeof( +(end+1) );         // OK, we won&apos;t complain
    struct B *p;                            // B is some POD.
    B b1;

    memcpy( p, &amp;b1, sizeof(&amp;b1) );          // 866: sizeof(b1)intended?

    size_t s3 = sizeof(A[0]);               // OK, get the size of an element.
    size_t s4 = sizeof(A[2]);               // 866: Not incorrect, but unusual ...</c>
    </m>
    <m id="868">
        <c>A degenerate switch was encountered. This is a braceless switch. E.g.:
Now why, you might wonder, would one want such a thing. That would be to
create a region of code from which you can breakout at any point. E.g.:

    REGION {
           alpha();
           if( n &lt; 10 ) break;
           beta();
           if( n &lt; 25 ) break;
           gamma();
           }

If REGION is a suitably defined macro then each break taken will take
you to just below the region. In this simple example there is not that
much of an advantage. But when if conditions explode in complexity this
is a very nice feature to have.
To obtain this effect you can define REGION as

    #define REGION switch(1) case 1:

To automatically suppress this message in this case use:

    -emacro( 868, REGION )</c>
    </m>
    <m id="870">
        <c>This message is issued at the end of processing if multiple modules were
processed but no -max_threads option was used to specify how many
concurrent linting threads to employ. By default, PC-lint Plus processes
all modules using a single thread. If your hardware has multiple cores
or processors, you may be able to substantially speed up the processing
time by employing multiple threads using the -max_threads option. If a
single thread is explicitly requested using -max_threads=1, this message
will be suppressed.</c>
    </m>
    <m id="879">
        <c>This message is emitted for function calls encountered while the fsf
flag is enabled. It lists the different ways that the function that was
called can be specified within a -sem, -printf, or -scanf option.
Overloaded functions and function templates can have multiple ways of
being specified in these options. For example, given a function with
multiple overloads, it is possible to specify a semantic that applies to
all overloads or just one, similarly for function templates. See also
&quot;Overload-Specific Semantics&quot; in the Reference Manual</c>
    </m>
    <m id="882">
        <c>The sizeof operator was used with a pointer parameter that was declared
using array syntax without a size. Using sizeof in this way will yield
the size of the pointer, not the size of the array. If an array size if
provided, message 682 is issued instead.</c>
    </m>
    <m id="886">
        <c>A deprecated preprocessor directive (see the -deprecate option) was
encountered in a conditionally excluded region. For example:

    //lint -deprecate(ppw, pragma)
    #if 0
    #pragma BLAH
    #endif

will cause this message to be issued for the #pragma directive.</c>
    </m>
    <m id="891">
        <c>This supplemental message is used to convey additional information for a
previous message at a different location. For example, this message may
be used to reference an earlier declaration, a conflicting definition,
etc.</c>
    </m>
    <m id="892">
        <c>Provides supplemental information about a Strong Type mismatch when it
appears that a forgotten conversion factor may be responsible for a
dimensional type difference.</c>
    </m>
    <m id="893">
        <c>This supplemental message is given when a message is issued with a
location that was the result of a macro expansion. It specifies the
macro from which the expansion occurred.</c>
    </m>
    <m id="894">
        <c>This supplemental message is issued when a value tracking message is
issued during a specific walk and provides additional information about
the walk. The location of the call, name of the called function, and the
arguments passed will be displayed. This information is rendered as
described in section [subsec:valuedisplayformat].</c>
    </m>
    <m id="896">
        <c>This supplemental message is issued when there is an error processing a
semantic that contains a macro expansion. It provides information about
the macro that was expanded.</c>
    </m>
    <m id="897">
        <c>This supplemental message is issued when a message is given within a
template instantiation. It provides details of the relevant
instantiation.</c>
    </m>
    <m id="900">
        <c>This message exists to provide some way of ensuring that an output
message is always produced, even if there are no other messages. This is
required for some windowing systems and can be useful to distinguish
successful completion from premature termination. The message can also
be useful for ensuring that all emitted messages have been accounted
for. This message can be enable with +e900.</c>
    </m>
    <m id="901">
        <c>The definition of the mentioned variable contained no initializer. While
the use of an uninitialized variable is caught by warning 530, some
style guidelines insist that variables should be initialized at
definition. For example, see .</c>
    </m>
    <m id="902">
        <c>A function declaration was found inside a source module and not in a
header file. One common programming practice is to place all function
declarations in headers.</c>
    </m>
    <m id="904">
        <c>A return statement was found before the end of a function definition.
Many programming standards require that functions contain a single exit
point located at the end of the function. This can enhance readability
and may make subsequent modification less error prone.</c>
    </m>
    <m id="905">
        <c>A printf/scanf style function received a non-literal format specifier
but, unlike the case covered by Warning 592 the function also received
additional arguments. E.g.

    char *fmt;
    int a, b;
    ...
    printf( fmt, a, b );

Variable formats represent a very powerful feature of C/C++ but they
need to be used judiciously. Unlike the case covered by Warning 592,
this case cannot be easily rewritten with an explicit visible format.
But this Elective Note can be used to examine code with non-literal
formats to make sure that no errors are present and that the formats
themselves are properly constructed and contain no user-provided data.
See Warning 592.</c>
    </m>
    <m id="907">
        <c>A pointer whose type is not void* is being assigned to a variable (or
passed to a parameter) whose type is void*. This is permitted in both C
and C++. But the practice is potentially dangerous and this Elective
Note allows one to see where this takes place. See also Note 908.</c>
    </m>
    <m id="908">
        <c>A pointer whose type is void* is being assigned to a variable (or passed
to a parameter) whose type is not void*. This conversion is not
permitted in C++ (where Error message 64 is given in lieu of this
message). But the conversion is permitted in C. Like the implicit
conversion described by Message 907, the practice is potentially
dangerous and this Elective Note allows one to see where this takes
place.</c>
    </m>
    <m id="909">
        <c>A non-bool was tested as a Boolean. For example, in the following
function:

    int f(int n) {
         if (n) return n;
         else return 0;
    }

the programmer tests &apos;n&apos; directly rather than using an explicit Boolean
expression such as &apos;n != 0&apos;. Some shops prefer the explicit test.</c>
    </m>
    <m id="910">
        <c>A pointer was assigned (or initialized) with a 0. Some programmers
prefer other conventions such as NULL or nil. This message will help
such programmers root out cavalier uses of 0. This is relatively easy in
C since you can define NULL as follows:

    #define NULL (void *)0

However, in C++, a void* cannot be assigned to other pointers without a
cast. Instead, assuming that NULL is defined to be 0, use the option:

    --emacro((910),NULL)

This will inhibit message 910 in expressions using NULL.
This method will also work in C. Both methods assume that you expressly
turn on this message with a +e910 or equivalent.</c>
    </m>
    <m id="911">
        <c>Notes whenever a sub-integer expression such as a char, short, enum, or
bit-field is promoted to int for the purpose of participating in some
arithmetic operation or function call.</c>
    </m>
    <m id="912">
        <c>Notes whenever a binary operation (other than assignment) requires a
type balancing. A smaller range type is promoted to a larger range type.
For example: 3 + 5.5 will trigger such a message because int is
converted to double.</c>
    </m>
    <m id="915">
        <c>Notes whenever an assignment, initialization or return implies an
arithmetic conversion (context specifies which).</c>
    </m>
    <m id="916">
        <c>Notes whenever an assignment, initialization or return implies an
implicit pointer conversion (context specifies which).</c>
    </m>
    <m id="917">
        <c>Notes whenever an implicit arithmetic conversion takes place as the
result of a prototype. For example:

    double sqrt(double);
    ... sqrt(3); ...

will elicit this message because 3 is quietly converted to double.</c>
    </m>
    <m id="919">
        <c>A lower precision quantity was assigned to a higher precision variable
as when an int is assigned to a double.</c>
    </m>
    <m id="920">
        <c>A cast is being made to void.</c>
    </m>
    <m id="921">
        <c>A cast is being made from one integral type to another.</c>
    </m>
    <m id="922">
        <c>A cast is being made to or from one of the floating types (float,
double, long double).</c>
    </m>
    <m id="923">
        <c>A cast is being made from a pointer to a non-pointer or from a
non-pointer to a pointer.</c>
    </m>
    <m id="925">
        <c>A cast is being made between pointers wherein the source or destination
type is a pointer to void.</c>
    </m>
    <m id="926">
        <c>A cast is being made between pointers to (possibly signed or unsigned)
char.</c>
    </m>
    <m id="927">
        <c>A cast is being made from pointer to (possibly signed or unsigned) char
to a pointer to another type.</c>
    </m>
    <m id="928">
        <c>A cast is being made to pointer to (possibly signed or unsigned) char
from a pointer to another type.</c>
    </m>
    <m id="929">
        <c>A cast is being made between pointers that does not fall under the
purview of 920, 922, 923, 925, 927, 928.</c>
    </m>
    <m id="930">
        <c>A cast is being made to or from an enumeration type.</c>
    </m>
    <m id="931">
        <c>Indicates when both sides of an expression have side-effects. An example
is n++ + f(). This is normally benign. The really troublesome cases such
as n++ + n are caught via Warning 564. Also, if the function f()
modifies n then this will be reported in pass 2 as Warning 591.</c>
    </m>
    <m id="935">
        <c>This Note helps to locate non-portable data items within struct&apos;s. If
instead of containing int&apos;s and unsigned int&apos;s, a struct were to contain
short&apos;s and long&apos;s then the data would be more portable across machines
and memory models. Note that bit fields and union&apos;s do not get
complaints.</c>
    </m>
    <m id="936">
        <c>An &quot;old-style&quot; function definition is one in which the types are not
included between parentheses. Only names are provided between
parentheses with the type information following the right parenthesis.
This is the only style allowed by K&amp;R.</c>
    </m>
    <m id="937">
        <c>An &quot;old-style&quot; function declaration is one without type information for
its arguments.</c>
    </m>
    <m id="940">
        <c>An initializer for a subaggregate does not have braces. For example:

    int a[2][2] = { 1, 2, 3, 4 };

This is legal C but may violate local programming standards. The worst
violations are covered by Warning 651.</c>
    </m>
    <m id="941">
        <c>The result of a constant evaluation is 0 owing to one of the operands of
a binary operation being 0. This is less severe than Info 778 wherein
neither operand is 0. For example, expression (2&amp;1) yields a 778 whereas
expression (2&amp;0) yields a 941.</c>
    </m>
    <m id="942">
        <c>An integral expression (signed or unsigned) involving addition or
subtraction is converted to a floating point number. If an overflow
occurred, information would be lost. See also messages 647, 776 and 790.</c>
    </m>
    <m id="943">
        <c>The initializer {0} was used to initialize an aggregate of more than one
item. Since this is a very common thing to do, it is given a separate
message number, which is normally suppressed. See 785 for more flagrant
abuses.</c>
    </m>
    <m id="944">
        <c>The indicated operator (which is either &amp;&amp;, ||, or !) has an argument
that appears to always evaluate to either true or false. Information is
gleaned from a variety of sources including prior assignment statements
and initializers. Compare this with message 506, which is based on
testing constants or combinations of constants.</c>
    </m>
    <m id="945">
        <c>Some compilers refuse to process declarations of the form:

    extern struct X s;

where struct X is not yet defined. This note can alert a programmer
porting to such platforms.</c>
    </m>
    <m id="946">
        <c>A relational operator (one of &gt;, &gt;=, &lt;, &lt;=) or the subtract operator has
been applied to a pair of pointers. The reason this is of note is that
when large model pointers are compared (in one of the four ways above)
or subtracted, only the offset portion of the pointers is subject to the
arithmetic. It is presumed that the segment portion is the same. If this
presumption is not accurate then disaster looms. By enabling this
message you can focus in on the potential trouble spots.</c>
    </m>
    <m id="947">
        <c>An expression of the form p - q was found where both p and q are
pointers. This is of special importance in cases where the maximum
pointer can overflow the type that holds pointer differences. For
example, suppose that the maximum pointer is 3 Gigabytes -1, and that
pointer differences are represented by a long, where the maximum long is
2 Gigabytes -1. Note that both of these quantities fit within a 32 bit
word. Then subtracting a small pointer from a very large pointer will
produce an apparent negative value in the long representing the pointer
difference. Conversely, subtracting a very large pointer from a small
pointer can produce a positive quantity.
The alert reader will note that a potential problem exists whenever the
size of the type of a pointer difference equals the size of a pointer.
But the problem doesn&apos;t usually manifest itself since the highest
pointer values are usually less than what a pointer could theoretically
hold. For this reason, the message cannot be given automatically based
on scalar types and hence has been made an Elective Note.
Compare this Note with that of 946, which was designed for a slightly
different pointer difference problem.</c>
    </m>
    <m id="948">
        <c>The operator named in the message is one of four relational operators or
two equality operators in the list:

    &gt;   &gt;=   &lt;   &lt;=
    ==  !=

The arguments are such that it appears that the operator always
evaluates to either true or to false (as indicated in the message). This
is similar to message 944. Indeed there is some overlap with that
message. Message 944 is issued in the context where a Boolean is
expected (such as the left hand side of a ? operator) but may not
involve a relational operator. Message 948 is issued in the case of a
relational (or equality) operator but not necessarily in a situation
that requires a Boolean.</c>
    </m>
    <m id="952">
        <c>A parameter is not modified by a function. For example:

    int f( char *p, int n ) { return *p = n; }

can be redeclared as:

    int f( char * const p, const int n ) { return *p = n; }

There are few advantages to declaring an unchanging parameter a const.
It signals to the person reading the code that a parameter is
unchanging, but, in the estimate of most, reduces legibility. For this
reason the message has been given an Elective Note status.
However, there is a style of programming that encourages declaring
parameters const. For the above example, this style would declare f as

    int f( char *p, int n);

and would use the const qualifier only in the definition. Note that the
two forms are compatible according to the standard. The declaration is
considered the interface specification where const does not matter. The
const does matter in the definition of the function, which is considered
the implementation. Message 952 could be used to support this style.
Marking a parameter as const does not affect the type of argument that
can be passed to the parameter. In particular, it does not mean that
only const arguments may be passed. This is in contrast to declaring a
parameter as pointer to const or reference to const. For these
situations, Informational messages are issued (818 and 1764
respectively) and these do affect the kinds of arguments that may be
passed. See also messages 953 and 954.</c>
    </m>
    <m id="953">
        <c>A local auto variable was initialized and referenced but never modified.
Such a variable could be declared const. One advantage in making such a
declaration is that it can furnish a clue to the program reader that the
variable is unchanging. Other situations in which a const can be added
to a declaration are covered in messages 818, 843, 844, 952, 954 and
1764.</c>
    </m>
    <m id="954">
        <c>The data pointed to by a pointer is never changed (at least not through
that pointer). It may therefore be better, or at least more descriptive,
if the variable were typed pointer to const. For example:

    {
    char *p = &quot;abc&quot;;
    for( ; *p; p++ ) print(*p);
    }

can be redeclared as:

    {
    const char *p = &quot;abc&quot;;
    for( ; *p; p++ ) print(*p);
    }

It is interesting to contrast this situation with that of pointer
parameters. The latter is given Informational status (818) because it
has an effect of enhancing the set of pointers that can be passed into a
function. Other situations in which a const can be added to a
declaration are covered in messages 952, 953 and 1764.</c>
    </m>
    <m id="955">
        <c>In a function declaration a parameter name is missing. For example:

    void f(int);

will raise this message. This is perfectly legal but misses an
opportunity to instruct the user of a library routine on the nature of
the parameter. For example:

    void f(int count);

would presumably be more meaningful.
This message is not given for function definitions, only function
declarations.</c>
    </m>
    <m id="956">
        <c>This check has been advocated by programmers whose applications are
multi-threaded. Software that contains modifiable data of static
duration is often non-reentrant. That is, two or more threads cannot run
the code concurrently. By &apos;static duration&apos; we mean variables declared
static or variables declared external to any function. For example:

    int count = 0;
    void bump() { count++; }
    int get_count() { return count; }

If the purpose is to obtain a count of all the bump()&apos;s by a given
thread then this program clearly will not do since the global variable
count sums up the bump()&apos;s from all the threads. Moreover, if the
purpose of the code is to obtain a count of all bump()&apos;s by all threads,
it still may contain a subtle error (depending on the compiler and the
machine). If it is possible to interrupt a thread between the access of
count and the subsequent store, then two threads that are bump()&apos;ing at
the same time, may register an increase in the count by just one.
Please note that not all code is intended to be re-entrant. In fact most
programs are not designed that way and so this Elective Note need not be
enabled for the majority of programs. If the program is intended to be
re-entrant, all uses of non-const static variables should be examined
carefully for non-reentrant properties.</c>
    </m>
    <m id="957">
        <c>A function was defined without a prototype in scope. It is usually good
practice to declare prototypes for all functions in header files and
have those header files checked against the definitions of the function
to assure that they match.
If you are linting all the files of your project together such cross
checking will be done in the natural course of things. For this reason
this message has been given a relatively low urgency of Elective Note.</c>
    </m>
    <m id="958">
        <c>This message is given whenever padding is necessary within a struct to
achieve a required member alignment. symbol designates that which is
being aligned. Consider:

    struct A { char c; int n; };

Assuming that int must be aligned on a 4-byte boundary and assuming the
size of a char to be 1, then this message will be issued indicating that
there will be a padding of 3 bytes to align the number.
The alignment requirements vary with the compiler, the machine and,
sometimes, compiler options. When separately compiled programs need to
share data at the binary level it helps to remove any artificially
created padding from any of the structures that may be shared.</c>
    </m>
    <m id="959">
        <c>The alignment of a structure (or union) is equal to the maximum
alignment of any of its members. When an array of structures is
allocated, the compiler ensures that each structure is allocated at an
address with the proper alignment. This will require padding if the size
of the structure is not an even multiple of its maximum alignment. For
example:

    struct A { int n; char ch; } a[10];

Assuming the size and alignment of int is 4 then the size of each struct
is 5 but its alignment is 4. As a result each struct in the array will
be padded with 3 bytes.
Alignment can vary with the compiler and the machine. If binary data is
to be shared by separately compiled modules, it is safer to make sure
that all shared structures and unions are explicitly padded.</c>
    </m>
    <m id="963">
        <c>The declarations in the following example are equivalent:

    //lint +e963 report on qualifier-type inversion
    extern const char *p;
    extern char const *p;   // Note 963

The qualifiers &apos;const&apos; and &apos;volatile&apos; may appear either before or after
or even between other declaration specifiers. Many programmers prefer a
consistent scheme such as always placing the qualifier before the type.
If you enable 963 (using +e963) this is what you will get by default.
The message will contain the word &apos;follows&apos; rather than the word
&apos;precedes&apos;.
There is a diametrically opposite convention, viz. that of placing the
qualifier after the type. As the message itself reminds the user, you
will obtain the reverse test if you turn off the fqb (place qualifiers
before types) flag. Thus

    //lint -fqb turn off the Qualifiers Before types flag
    //lint +e963 report on type-qualifier inversion
    extern const char *p; // Note 963
    extern char const *p;

Note that the use of this flag will cause &apos;follows&apos; in the message to be
replaced by &apos;precedes&apos; and the alternative option mentioned within the
&apos;use&apos; clause is changed to its opposite orientation.
Dan Saks and Vandevoorde and Josuttis, , section 1.4, provide convincing
evidence that this alternative convention is indeed the better one.</c>
    </m>
    <m id="967">
        <c>You may protect against the repeated inclusion of headers by means of a
standard include guard having the following form:

    #ifndef Name
    #define Name
    ...
    #endif

or

    #if !defined(Name)
    #define Name
    ...
    #endif

The header file cited in the message does not have such a guard. It is
standard practice in many organizations to always place include guards
within every header.
See message 451 for more information about header include guards. This
message is not issued for headers that employ #pragma once.</c>
    </m>
    <m id="970">
        <c>Some standards require the use of type names (defined in typedef&apos;s) in
preference to raw names used within the text of the program. For example
they may want you to use INT32 rather than int where INT32 is defined
as:

    typedef int INT32;

This message is normally issued for the standard intrinsic types: bool,
char, wchar_t, int, float, double, and for modifiers unsigned, signed,
short and long. You may enable this message and then suppress the
message for individual types to obtain special effects. For example, the
following will enable the message for all but bool.

    +e970 -estring(970,bool)</c>
    </m>
    <m id="971">
        <c>The &apos;char&apos; type was specified without an explicit modifier to indicate
whether the char was signed or unsigned. The plain char type can be
regarded by the compiler as identifying a signed or an unsigned
quantity, whichever is more efficient to implement. Because of this
ambiguity, some standards do not like the use of char without an
explicit modifier to indicate its signedness.</c>
    </m>
    <m id="972">
        <c>An unusual character was found in a character or string literal. It is
identified in the message by its hexadecimal encoding. Characters are
considered to be unusual if they are outside the standard C and C++
source character set. For example:

    char ch = &apos;\`&apos;; // Unusual character &apos;\x60&apos;

The backtick character being assigned above is considered unusual. To
suppress this message for this character use the option:

    -estring( 972, &quot;\x60&quot; )</c>
    </m>
    <m id="973">
        <c>A unary operator appearing in an expression-like macro was found to be
not parenthesized. For example:
    #define N -1
The user may prefer to parenthesize such things as:
    #define N (-1)
This has been placed in the elective note category because we cannot
find an instance when this really produces a problem. The important case
of unparenthesized binary operators is covered with message 773.</c>
    </m>
    <m id="974">
        <c>This message, issued at global wrap-up, will report on the function that
requires the most stack. The stack required consists of the amount of
auto storage the function requires plus the amounts required in any
chain of functions called. The worst case chain is always reported.
To obtain a report of all the functions, use the +stack option.
Reasonable allowances are made for function call overhead and the stack
requirements of external functions. These assumptions can be controlled
via the +stack option.
If recursion is detected it will be reported here, as this is considered
worse than any finite case. The next worst case is that the stack can&apos;t
be determined because a function makes a call through a function
pointer. The function is said to be non-deterministic. If neither of
these conditions prevail, the function that heads the worst case chain
of calls will be reported upon.
The message will normally provide you with the name of a called
function. If the function is recursive this will provide you with the
first call of a recursive loop. To determine the full loop, you will
need a full stack report as obtained with the +stack option. You need a
suboption of the form &amp;file=file to specify a file that will contain a
record for each function for which a definition was found. You will be
able to follow the chain of calls to determine the recursive path.
If you can assure yourself through code analysis that there is an upper
bound to the amount of stack utilized by some recursive function, then
you can employ the +stack option to specify the bound for this function.
The function will no longer be considered recursive but rather finite.
In this way, possibly through a sequence of options, you can
progressively eliminate apparent recursion and in that way arrive at a
safe upper bound for stack usage. Similar considerations apply for
non-deterministic functions.</c>
    </m>
    <m id="975">
        <c>The first identifier after #pragma is considered the name of the pragma.
If the name is unrecognized then the remainder of the line is ignored.
Since the purpose of #pragma is to allow for compiler- dependent
communication, it is not really expected that all pragmas will be
understood by all third-party processors of the code. Thus, this message
does not necessarily indicate that there is anything wrong and could
easily be suppressed entirely.
Moreover, if the pragma occurs in a library header, this message would
not normally be issued because the option -wlib(1) would be in effect
(this option is present in all of our compiler options files).
But, if the pragma occurs in user code, then it should be examined to
see if there is something there that might interest a lint processor.
There are a variety of facilities to deal with pragmas; in particular,
they can be mapped into linguistic constructs or lint options or both.
See Section &quot;Pragmas&quot; in the Reference Manual.</c>
    </m>
    <m id="977">
        <c>This message is issued when a non-literal expression of non-boolean type
is assigned to a boolean. This can occur through direct assignment,
initialization, as an argument in a function call, or a return
expression. For example, the function below returns true if there is a
remainder when x is divided by y but the type of the value before
conversion is int:

    _Bool foo(int y, int z) {
         return y % z;       // Note 977
    }

The message won&apos;t be issued for:

    _Bool foo(int y, int z) {
         return y % z != 0;  // Okay, != implies boolean context
    }

A cast can also be used to suppress this message.</c>
    </m>
    <m id="978">
        <c>The C Standard specifies a variety of naming patterns reserved for
future use. For example, names starting with is, to, or str followed by
a lowercase letter are reserved to the implementation. This message
reports on symbols declared with names that match one of these patterns.
The name of the offending symbol is provided along with the reserved
pattern that the name matches. For example:

    int strmin;

will elicit:

    note 978: the name &apos;strmin&apos; matches a pattern reserved to the compiler because
        it begins with &apos;str&apos; and a following lowercase letter
    int strmin;
        ^</c>
    </m>
    <m id="979">
        <c>The specified function was analyzed and determined to be eligible for
the pure semantic but no -sem option was used to specify that this
function was pure. Since functions are considered to be impure by
default when the definition is not visible from the current module,
specifying this function as pure could improve analysis related to
side-effects and purity.</c>
    </m>
    <m id="980">
        <c>The C Standard specifies a variety of macro naming patterns reserved by
the implementation. These patterns include a name starting with &apos;E&apos;
followed by a digit or upper case letter, names starting with &apos;SIG&apos; or
&apos;SIG_&apos; followed by an uppercase letter, and macros that begin with &apos;PRI&apos;
or &apos;SCN&apos; followed by either &apos;X&apos; or a lowercase letter. The message
includes both the name of the offending macro and the reserved pattern
that it matches. For example:

    #define LC_END

will be greeted with:

    note 980: macro name &apos;LC_END&apos; matches a pattern reserved to the compiler
        because it begins with &apos;LC_&apos; and a following uppercase letter
    #define LC_END
            ^

Note that some patterns are reserved only in certain versions of C and
will be diagnosed only when the language mode specified corresponds to
the version in which the pattern is applicable. For example, names
starting with INT and ending in _C are diagnosed only in C99 and later.</c>
    </m>
    <m id="981">
        <c>A cast is being performed on an expression that is already of the type
being cast to making the cast redundant. This message is not issued for
casting enumerations to their underlying type or within template
instantiations.</c>
    </m>
    <m id="983">
        <c>A dash (-) was encountered within the scan list in a %[ conversion
specifier in the call to a scanf-like function. Furthermore the dash was
not the first character (or the second character where the first
character is ^) or the last character, e.g. %[A-Z]. The behavior of a
dash in this position is implementation defined, some implementations
interpret this as a range of characters to include in the scan set (e.g.
all characters from A to Z) while others treat it literally.</c>
    </m>
    <m id="986">
        <c>This message is issued when a type that has been deprecated using the
-deprecate option with a category of type is used as a target in a
typedef definition. This is to provide notification that the underlying
deprecated type may be used through a typedef later, which will not be
diagnosed. To diagnose uses of a type through a typedef, the basetype
deprecation category can be used. See the -deprecate option for more
information.</c>
    </m>
    <m id="987">
        <c>This message is a weaker form of message 578 for cases where a field is
shadowed by a constructor parameter.</c>
    </m>
    <m id="999">
        <c>The -max_threads=n option can be used to specify the number of
concurrent linting threads for parallel analysis. If n is specified as
0, PC-lint Plus attempts to query the hardware to determine the optimal
value for n. This message serves to inform the programmer of the value
that was selected.</c>
    </m>
    <m id="1001">
        <c>In an expression of the form X::Y, X must be a class name.</c>
    </m>
    <m id="1002">
        <c>The keyword this refers to the class being passed implicitly to a member
function. It is invalid outside a class member function.</c>
    </m>
    <m id="1003">
        <c>A static member function receives no this pointer.</c>
    </m>
    <m id="1004">
        <c>The .* and -&gt;* operators require pointer to members on the right hand
side.</c>
    </m>
    <m id="1005">
        <c>While expecting a declaration a &apos;~&apos; character was encountered. This was
presumed to be the start of a destructor. However no class was
specified.</c>
    </m>
    <m id="1008">
        <c>Some nonstandard extensions to C++ allow integers to follow &apos;=&apos; for
declarations of member functions. If you are using such extensions,
simply suppress this message. If only library headers are using this
extension, use -elib(1008).</c>
    </m>
    <m id="1012">
        <c>The return type of a function introduced with &apos;operator type&apos; is type
and may not be preceded with the same or any other type.</c>
    </m>
    <m id="1013">
        <c>The second operand of a scope operator or a &apos;.&apos; or &apos;-&gt;&apos; operator is not
a member of the class (struct or union) expressed or implied by the left
hand operand.</c>
    </m>
    <m id="1020">
        <c>A class template specialization is generally preceded by a &apos;template&apos;
clause as in:

    template&lt; class T &gt; class A { };   // a template
    template&lt;&gt; class A&lt;int&gt; { };       // a specialization

If the &apos;template&lt;&gt;&apos; is omitted you will get this message but it will
still be interpreted as a specialization. Before the standardization of
template syntax was completed, a template specialization did not require
this clause and its absence is still permitted by some compilers.</c>
    </m>
    <m id="1022">
        <c>There are four operators not to be defined except as class members.
These are:

    = () [] -&gt;

The parameter symbol indicates which it is.</c>
    </m>
    <m id="1023">
        <c>A call to an overloaded function or operator is ambiguous. The
candidates of choice are provided in the message.</c>
    </m>
    <m id="1024">
        <c>A call to an overloaded function could not be resolved successfully
because no function is declared with the same number of arguments as in
the call.</c>
    </m>
    <m id="1027">
        <c>Default arguments need to be consecutive. For example

    void f(int i=0, int j, int k=0);

is illegal.</c>
    </m>
    <m id="1029">
        <c>A default value for a given argument for a given function should be
given only once.</c>
    </m>
    <m id="1031">
        <c>Default values for arguments may not use local variables.</c>
    </m>
    <m id="1032">
        <c>There was an attempt to call a non-static member function without
specifying or implying an object that could serve as the basis for the
this pointer. If the member name is known at compile time it will be
printed with the message.</c>
    </m>
    <m id="1033">
        <c>You may not declare a static member function virtual.</c>
    </m>
    <m id="1034">
        <c>This can come as a surprise to the novice C++ programmer. The word
&apos;static&apos; within a class definition is used to describe a member that is
alone and apart from any one object of a class. But such a member has
program scope not file scope. The word &apos;static&apos; outside a class
definition implies file scope not program scope.</c>
    </m>
    <m id="1036">
        <c>There is more than one constructor that can be used to make a desired
conversion.</c>
    </m>
    <m id="1037">
        <c>There is more than one conversion function (of the form operator type ()
) that will perform a desired conversion.</c>
    </m>
    <m id="1038">
        <c>We have found what appears to be a reference to a type but no such type
is in scope. We have, however, been able to locate a type buried within
another class. Is this what the user intended? If this is what is
intended, use full scoping. If your compiler doesn&apos;t support the
scoping, suppress with -esym.</c>
    </m>
    <m id="1040">
        <c>A declaration of the symbol X::Y appears within a class definition
(other than for class X). It is not a friend declaration. Therefore it
is in error.</c>
    </m>
    <m id="1042">
        <c>In defining (or declaring) an operator you must have at least one class
as an operand.</c>
    </m>
    <m id="1043">
        <c>An expression being delete&apos;d is a non-pointer, non-array. You may only
delete what was created with an invocation of new.</c>
    </m>
    <m id="1046">
        <c>The symbol is a non-static member of a class and hence requires a class
instantiation. None is in sight.</c>
    </m>
    <m id="1049">
        <c>There are more arguments in the template class-name than there were
parameters in the original template declaration.</c>
    </m>
    <m id="1050">
        <c>The name of a class template identified by symbol was used without
specifying a template argument list.</c>
    </m>
    <m id="1051">
        <c>Whereas it is possible to overload a function name by giving it two
different parameter lists, it is not possible to overload a name in any
other way. In particular, a function name may not also be used as a
variable name.</c>
    </m>
    <m id="1055">
        <c>Whereas in C you may call a function without a prior declaration, in C++
you must supply such a declaration. For C programs you would have
received an Informational message (718) in this event.</c>
    </m>
    <m id="1057">
        <c>The indicated member referenced via scope operator cannot be used in the
absence of a this pointer.</c>
    </m>
    <m id="1063">
        <c>A constructor for a class closely resembles a copy constructor. A copy
constructor for class X is typically declared as:

    X(const X &amp;)

If you leave off the &apos;&amp;&apos; then a copy constructor would be needed just to
copy the argument into the copy constructor. This is a runaway
recursion.</c>
    </m>
    <m id="1069">
        <c>Within a constructor initialization list, a name was found that did not
correspond to either a direct base class of the class being defined or a
member of the class.</c>
    </m>
    <m id="1071">
        <c>Constructors and destructors may not be declared with a return type, not
even void. See ARM</c>
    </m>
    <m id="1072">
        <c>A reference variable must have an initializer at the point of
declaration.</c>
    </m>
    <m id="1074">
        <c>In a declaration of the form:
    namespace name = scoped-identifier
the scoped-identifier must identify a namespace.</c>
    </m>
    <m id="1075">
        <c>Two namespaces contain the same name. A reference to such a name could
not be disambiguated. You must fully qualify this name in order to
indicate the name intended.</c>
    </m>
    <m id="1076">
        <c>Anonymous unions need to be declared static. This is because the names
contained within are considered local to the module in which they are
declared.</c>
    </m>
    <m id="1079">
        <c>The default value for a template parameter appears to be malformed. For
example, suppose the user mistakenly substituted a &apos;]&apos; for a &apos;&gt;&apos;
producing the following:

    template &lt;class T = A&lt; int ] &gt;
        class X
        {
        };

This will cause PC-lint Plus to process to the end of the file looking
(in vain) for the terminating pointy bracket. Not finding it will cause
this message to be printed. Fortunately, the message will bear the
location of the malformed template.</c>
    </m>
    <m id="1083">
        <c>If the 2nd operand can be converted to match the type of the 3rd, and
the 3rd operand can be converted to match the type of the 2nd, then the
conditional expression is considered ill-formed.</c>
    </m>
    <m id="1088">
        <c>This error is issued when a using-declaration references a name without
the :: scope resolution operator; e.g.:

    class A {
    protected:
        int n;
    };

    class B : public A {
    public:
        using n; // Error 1088: should be &apos;using A::n;&apos;
    };

See .</c>
    </m>
    <m id="1089">
        <c>This error is issued when the rightmost part of the qualified-id in a
using-declaration is the name of a namespace. E.g.:

    namespace N {
        namespace Q {
            void g();
        }
    }

    void f() {
        using ::N::Q; // Error 1089
        Q::g();
    }

Instead, use a namespace-alias-definition:

    namespace N {
        namespace Q {
            void g();
        }
    }

    void f() {
        namespace Q = ::N::Q;    // OK
        Q::g();                  // OK, calls ::N::Q::g().
    }

See , Issue 460.</c>
    </m>
    <m id="1090">
        <c>This error is issued when the rightmost part of the qualified-id in a
using-declaration is a template-id. E.g.:

    template &lt;class T&gt; class A {
    protected:
        template &lt;class U&gt; class B {};
    };

    struct D : public A&lt;int&gt; {
    public:
        using A&lt;int&gt;::B&lt;char *&gt;; // Error 1090
    };

    D::B&lt;char *&gt; bc;

Instead, refer to the template name without template arguments:

    template &lt;class T&gt; class A {
    protected:
        template &lt;class U&gt; class B {};
    };

    struct D : public A&lt;int&gt; {
    public:
        using A&lt;int&gt;::B; // OK
    };

    D::B&lt;char *&gt; bc;     // OK

See , 7.3.3 namespace.udecl.</c>
    </m>
    <m id="1091">
        <c>This error is issued when the nested-name-specifier of the qualified-id
in a using-declaration does not name a base class of the class
containing the using-declaration; e.g.:

    struct N {
        void f();
    };

    class A {
    protected:
        void f();
    };

    class B : A {
    public:
        using N::f;     // Error 1091
    };

See , Issue 400.</c>
    </m>
    <m id="1092">
        <c>This error is issued when the nested-name-specifier of the qualified-id
in a using-declaration names a class but the using-declaration does not
appear where class members are declared. E.g.:

    struct A {
        void f();
    };

    struct B : A {
        void g() { using A::f; }    // Error 1092
    };

See , 7.3.3 namespace.udecl.</c>
    </m>
    <m id="1093">
        <c>A pure specifier (= 0) should not be placed on a function unless the
function had been declared &quot;virtual&quot;.</c>
    </m>
    <m id="1096">
        <c>C++11 requires that if a constructor delegates to another constructor,
then the mem-initializer (the region between the colon and the function
body) must contain only one item, and that item must be a call to
another constructor (which is called the &quot;target constructor&quot;). Example

    struct A {
        int n;
        A(int);
        A(const A &amp;p) : A(p.n) { }   // OK
        A() : n(42), A(32) { }       // Error 1096
    };</c>
    </m>
    <m id="1097">
        <c>The specified constructor is a delegating constructor that contains a
delegation cycle, either directly by delegating to itself or indirectly
by calling another delegating constructor that eventually delegates back
to the original constructor. If multiple constructors are in the cycle,
the other constructors are provided via subsequent 891 supplemental
messages. For example:

    struct A {
        int n;
        A(int x) : A(x, 0) { }              // Error 1097
        A(int x, int y) : A(x, y, 0) { }
        A(int x, int y, int z) : A(x) { }
    };</c>
    </m>
    <m id="1098">
        <c>This message is issued for a declaration where the user apparently
intended to name a specialization of a function template (e.g., in an
explicit specialization, an explicit instantiation or a friend
declaration of specialization), but no previously-declared function
template is matched. Example:

    template&lt;class T&gt; void f( const T&amp; ); // #1

    struct A{};
    template&lt;&gt; void f( const A&amp; );        // Ok
    // (A is the deduced argument to T.)

    struct B{};
    template&lt;&gt; void f( const B );         // Error 1098.
    // (A template argument cannot be deduced for T.)</c>
    </m>
    <m id="1099">
        <c>This message is issued for a declaration where the user apparently
intended to name a specialization of a function template (e.g., in an
explicit specialization, an explicit instantiation or a friend
declaration of specialization), but the specialization matches multiple
function templates, and none of the matched templates is more
specialized than all of the other matching templates. The candidates
(i.e., the matching templates) are provided in the message. Example:

    template&lt;class T&gt; struct A {};

    template&lt;class T, class U&gt; void f( T*, U   ); // #1
    template&lt;class T, class U&gt; void f( T, A&lt;U&gt; ); // #2

    struct B{};
    template&lt;&gt; void f( B, A&lt;B&gt; );                 // Ok
    // #1 does not match but #2 does.

    template&lt;&gt; void f( char*, A&lt;int&gt; );           // Error 1099
    // Both #1 and #2 match and neither is more specialized than the other.

This situation can be avoided in at least a couple of ways. One way is
to explicitly specify one or more template arguments. Example

    // continuing from above...
    template&lt;&gt; void f&lt;char*&gt;( char*, A&lt;int&gt; ); // Ok
    // #1 does not match but #2 does.

Another way is to use SFINAE (Substitution Failure Is Not An Error)
tactics in the declaration of one or more function templates, e.g. with
boost::enable_if.</c>
    </m>
    <m id="1101">
        <c>Example:

    int f(void);
    int f(char*);
    auto n = f; // Error

In terms of deduction, this is equivalent to:

    int f(void);
    int f(char *);
    template &lt;class T&gt; void g(const T &amp;);

    void h(void) {
        g(f);  // Error
    }

Here, &apos;f&apos; refers to multiple overloaded functions, so it is an ambiguous
reference and T cannot be deduced. (Code like this could still be
well-formed however, e.g. if g is overloaded with a non-template
function whose parameter type is &apos;ptr-to-function returning int taking
char*&apos;.)</c>
    </m>
    <m id="1102">
        <c>When multiple variables are defined in the same declaration, and when
that declaration uses the keyword auto as the type-specifier, the type
for which auto is a placeholder must be the same for each variable.
Example:

    float g(void);
    char* s();
    auto a = 42;           // Ok, auto is &apos;int&apos;
    auto b = g();          // Ok, auto is &apos;float&apos;
    auto c = &apos;q&apos;,
         *d = s();         // Ok, auto is &apos;char&apos; (for both c and d)
    auto x = 42, y = g();  // Error 1102 here</c>
    </m>
    <m id="1103">
        <c>When an enumeration type is declared with an explicit underlying type,
that type must be integral. Example:

    enum A : bool;                // ok
    enum B : short;               // ok
    enum C : unsigned long long;  // ok
    enum D : float;               // Error 1103</c>
    </m>
    <m id="1105">
        <c>If an explicit ref qualifier (&apos;&amp;&apos; or &apos;&amp;&amp;&apos;) of a nonstatic member
function is employed, an explicit ref qualifier needs to be used with
every member of the overload set. Thus:

    class A {
        void f(int)&amp;;
        void f(int);
        void f(double);
        void g(int);
        void g(double);
    };</c>
    </m>
    <m id="1107">
        <c>Two string literals that different types are being concatenated.
Examples:

    char *s = u&quot;abc&quot; U&quot;def&quot;;
    char *q = L&quot;ghi&quot; u&quot;jkl&quot;;

This message is issued for mixing strings of char16_t, char32_t, and/or
wchar_t (as shown). Literal string concatenation of any of these with an
ordinary character literal is permitted and will receive Informational
707.</c>
    </m>
    <m id="1108">
        <c>This message is issued when a deleted or otherwise unavailable function
is used. For example:

    void f( int ) = delete;
    void f( double );
    void g( double d, int n ) {
        f( d ); // Ok
        f( n ); // Error
    }</c>
    </m>
    <m id="1110">
        <c>When an overloaded operator-&gt; is used as in

    a-&gt;b

it is effectively expanded to:

    a.operator-&gt;()-&gt;b

And this expansion repeats until an operator-&gt; is found that does not
yield a class type. But in the process of evaluating this expansion, it
might be found that one of the operators returns a class type for which
an overloaded operator-&gt; was already expanded; in that case, Error 1110
is triggered. Example:

    struct B;
    struct A { struct B&amp; operator-&gt;(); };
    struct B { struct A&amp; operator-&gt;(); };
    int f( A &amp; p ) { p-&gt;g(); }            // Error</c>
    </m>
    <m id="1111">
        <c>This message is issued at the beginning of each explicit
specialization/instantiation that does not appear at namespace scope.
Example:

    struct A {
        template&lt;typename U&gt; struct B {};

        // template&lt;&gt; // Would be ill-formed by ISO C++.
        //     struct B&lt;int&gt; {};
    };
    template&lt;&gt; struct A::B&lt;int&gt; {}; // Ok.

There is an additional limitation with member class templates of class
templates. As with members of a non-template class, one cannot write a
specialization at class scope. Example:

    template&lt;typename T&gt; struct G {
        template&lt;typename U&gt; struct H {};
        // template &lt;&gt; // Would be ill-formed by ISO C++
        //     struct H&lt;int&gt; {};
    };

But the language specification does not even allow this to be expressed
in a namespace-scope definition; there is no way to write an explicit
specialization that is a member of a class template. Example:

    template&lt;typename T&gt; struct J {
        template&lt;typename U&gt; struct K {};
    };
    // template&lt;typename T&gt;
    //     template&lt;&gt; // Would be ill-formed by ISO C++;
    //         struct J&lt;T&gt;::K&lt;int&gt; {};

This is because the rules for explicit specializations say that
&apos;template&lt;&gt;&apos; is not allowed to appear after a non-empty
template-parameter-list within the same declaration. However, one may
write an explicit specialization that is a member of an
implicitly-instantiated specialization of a class template. Example:

    template&lt;typename T&gt; struct L {
        template&lt;typename U&gt; struct M {};
    };
    template&lt;&gt; template &lt;&gt; struct L&lt;char&gt;::M&lt;int&gt; {}; // Ok

Here, the body of the class L&lt;char&gt; is automatically generated by
implicit instantiation (otherwise the reference to L&lt;char&gt;::M would be
ill-formed), while the body of L&lt;char&gt;::M&lt;int&gt; is provided in the
explicit specialization.
In March of 2009, the ISO C++ committee reviewed a report submitted
against this example:

    struct A {
      template&lt;class T&gt; struct B;
      template&lt;class T&gt; struct B&lt;T*&gt; { };  // well-formed
      template&lt;&gt; struct B&lt;int*&gt; { };       // ill-formed
    };

While it might seem odd that one is able to write the partial
specialization but not the full specialization, the committee (which at
the time was in a &quot;feature-freeze&quot; mode and trying to finalize a draft
for the next International Standard) decided that this capability would
need to be regarded as an &quot;extension&quot;, meaning that it could be
considered as a new feature in a future standard but not as a bug-fix
for C++0x.
Note that the Microsoft compiler implements this extension. For that
reason, the option

    -elib(1111)

appears in recent versions of our configuration files for Microsoft
compilers.</c>
    </m>
    <m id="1112">
        <c>or example, if you want to declare that f returns a pointer-to-int, you
must write:

    auto f() -&gt; int *;

... and not:

    auto *f() -&gt; int;

This also applies to a type-id (e.g., in a cast to a
pointer-to-function, or as an argument to a template type-parameter).</c>
    </m>
    <m id="1116">
        <c>A derived class attempted to override a virtual function that is marked
with the final virt-specifier in a base class.</c>
    </m>
    <m id="1117">
        <c>A virt-specifier (final or override) was supplied to a non-virtual
function.</c>
    </m>
    <m id="1118">
        <c>A virt-specifier (final or override) was encountered multiple times for
the specified virtual function.</c>
    </m>
    <m id="1119">
        <c>A virtual function was marked with the override keyword but does not
override a base class function.</c>
    </m>
    <m id="1120">
        <c>An incomplete type was used as a range expression in a range-based for
statement. A range expression must be a complete type.</c>
    </m>
    <m id="1121">
        <c>A non-array range expression used in a range-based for statement has no
viable begin or end function.</c>
    </m>
    <m id="1122">
        <c>The type of a range expression used in a range-based for statement has
either a begin or end member function but not both.</c>
    </m>
    <m id="1123">
        <c>A class that was marked with the final class-virt-specifier was used as
a base class in a class declaration.</c>
    </m>
    <m id="1124">
        <c>A digit separator character was encountered within a numeric literal at
a point where digit separators are not allowed. Digit separators are
only allowed between digits of a numeric literal and cannot be adjacent
to each other.</c>
    </m>
    <m id="1125">
        <c>The definition of a type appeared in a friend declaration, this is not
legal.
Example:

    class A {
        friend struct B;    // ok
        friend struct C {}; // error
    };</c>
    </m>
    <m id="1127">
        <c>A catch handler appeared following a catch(...) in the same try-catch
statement, which invokes undefined behavior.</c>
    </m>
    <m id="1301">
        <c>An attempt was made to instantiate the built-in template
__make_integer_seq with a negative length.</c>
    </m>
    <m id="1302">
        <c>An attempt was made to instantiate the built-in template
__make_integer_seq with a non-integral type. As the name implies,
__make_integer_seq generates a sequence of integers.</c>
    </m>
    <m id="1401">
        <c>The indicated non-static data member was not initialized by the
specified constructor. Specifically, this means that the member does not
have an in-class initializer and was neither directly initialized or
assigned a value in the constructor nor did the constructor call any
function that appeared to initialize this member.</c>
    </m>
    <m id="1404">
        <c>The following situation was detected:

    class X; ... X *p; ... delete p;

That is, a placeholder declaration for a class is given and an object of
that type is deleted before any definition is seen. This may or may not
be followed by the actual class definition:

    class X { ... };

A delete before the class is defined as dangerous because, among other
things, any operator delete that may be defined within the class could
be ignored.</c>
    </m>
    <m id="1405">
        <c>According to Section 5.2.8 (para 6) of the C++ standard , &quot;If the header
&lt;typeinfo&gt; (18.5.1) is not included prior to a use of typeid, the
program is ill-formed.&quot; A typeid was found in the program but the
required include was not.</c>
    </m>
    <m id="1407">
        <c>An increment operator was applied to an object of bool type; such use
has been deprecated since C++98. The same effect can be obtained by
assigning the value true to the object. Note the decrementing an object
of bool type has never been allowed in Standard C++ and will instead be
greeted with an error.</c>
    </m>
    <m id="1411">
        <c>A member function has the same name as a virtual member of a derived
class but it has a different signature (different parameter list). This
is legal but suspicious because it looks as though the function would
override the virtual function but doesn&apos;t. You should either adjust the
parameters of the member so that the signatures conform or choose a
different name. See also message 1511.</c>
    </m>
    <m id="1413">
        <c>It appears that a function (identified as symbol in the message)
declared to return a reference is returning a temporary. The C++
standard (Section 12.2), in addressing the issue of binding temporary
values to references, says &quot;A temporary bound to the returned value in a
function return statement ... persists until the function exits&quot;. Thus
the information being returned is not guaranteed to last longer than the
function being called.
It would probably be better to return by value rather than reference.
Alternatively, you may return a static variable by reference. This will
have validity at least until the next call upon the same function.</c>
    </m>
    <m id="1414">
        <c>The address of an auto variable was taken and assigned to a this member
in a member function. For example:

    struct A {
        char *x;
        void f() {
            char y[10];
            x = y;       // warning 1414
        }
    };

Here, the address of y is being passed to member x but this is dangerous
(if not ridiculous) since when the function returns the storage
allocated for y is deallocated and the pointer could very easily harm
something.</c>
    </m>
    <m id="1415">
        <c>A non-POD class is one that goes beyond containing just Plain Old Data
(POD). In particular, it may have private or protected data or it may
have constructors or a destructor or a copy assignment. All of these
things disqualify it from being a POD. A POD is fully defined in the C++
standard (Clause 9).
Some functions (such as memcpy, memcmp, memmove, etc.) are expected to
be given only pointers to POD objects. The reason is that only POD
objects have the property that they can be copied to an array of bytes
and back again with a guarantee that they will retain their original
value. (See Section 3.9 of the C++ standard ). See also Semantic pod(i).</c>
    </m>
    <m id="1416">
        <c>This message is usually issued when a reference to a member of a class
is used to initialize a reference to another member of the same class
before the first member was initialized. For example:

    class C {
        int &amp;n, &amp;m;
        C(int &amp;k) : n(m), m(k) { /* ... */ }
    };

Here m is initialized properly to be identical to k. However, the
initialization of n, taking place, as it does, before m is so
initialized, is erroneous. It is undefined what location n will
reference.</c>
    </m>
    <m id="1417">
        <c>This message is issued when a reference data member of a class does not
appear in a mem-initializer. For example, the following code will result
in a Warning 1417 for symbol m since a mem-initializer is the only way
that m can be reference initialized.

    class C {
        int &amp;n, &amp;m;
        C(int &amp;k) : n(k) { /* ... */ }
    };</c>
    </m>
    <m id="1419">
        <c>The macro NULL was passed to a throw expression. Since C++11, the NULL
macro can be defined as expanding to either an integer literal with a
zero value or nullptr, the choice of which is implementation defined.
The handler that catches the exception may depend on how the NULL macro
is defined. Prior to C++11, NULL could only be defined as an integer
type and will not be caught by an exception handler expecting a pointer
type, which may not be obvious.</c>
    </m>
    <m id="1420">
        <c>C++ expressly forbids the use of the mutable keyword on a reference
type. Despite this, at least one vendor&apos;s compiler not only supports
this use but relies on the ability to do so in their own library
headers. If your compiler supports this use, you can suppress this
message.</c>
    </m>
    <m id="1421">
        <c>C++ explicitly forbids redefining the default argument of a template
parameter. If your compiler allows this, you can suppress this message.</c>
    </m>
    <m id="1422">
        <c>This message is issued when the default constructor for a class is
declared within its class definition and then defaulted outside of the
class definition. C++ performs initialization of classes with user
supplied default constructors (declared but not defaulted in the class
definition) differently than classes without a user provided default
constructor.</c>
    </m>
    <m id="1423">
        <c>The C++ Standard specifies the conversions that can be performed using
reinterpret_cast. A conversion was attempted using reintepret_cast that
was not included in this list which will result in undefined behavior.</c>
    </m>
    <m id="1501">
        <c>A data member had zero size. It could be an array of zero length or a
class with no data members. Check your code to make sure this is not an
error. Some libraries employ clever templating, which will elicit this
message. In such a case it is necessary for you to inhibit the message
outright (using -e1501) or through a judicious use of -esym(1501,...).

    struct A {
      int b[0];   // warning 1501
    };</c>
    </m>
    <m id="1502">
        <c>A variable (symbol) is being instantiated that belongs to a class (name)
that contains no data members (either directly or indirectly through
inheritance). Note that this message can be suppressed using -esym of
either the object name or the class name.</c>
    </m>
    <m id="1504">
        <c>An untagged struct declaration appeared within a struct/union and has no
declarator. It is not treated like an anonymous union. Was this
intended?</c>
    </m>
    <m id="1505">
        <c>A base class specifier provides no access specifier (public, private or
protected). An explicit access specifier is always recommended since the
default behavior is often not what is expected. For example:

    class A : B { int a; };

would make B a private base class by default.

    class A : private B { int a; };

is preferred if that&apos;s what you want.</c>
    </m>
    <m id="1506">
        <c>A call to a virtual function was found in a constructor or a destructor
of a class; such a call will not consider overrides from derived classes
(as they have not been constructed yet, or have already been destroyed).
This message will not be issued in any of the following cases:

-   The call was qualified explicitly using the scope operator,
    inhibiting the virtual call mechanism.

-   The virtual function was declared with the final specifier.

-   The class of the constructor or destructor was declared with the
    final specifier.</c>
    </m>
    <m id="1507">
        <c>The type of an object to be delete&apos;d is usually a pointer. This is
because operator new always returns a pointer and delete may only delete
that allocated via new. Perhaps this is a programmer error attempting to
delete a local or global array?</c>
    </m>
    <m id="1509">
        <c>The indicated class is a base class for some derived class. It has a
non-virtual destructor. Was this a mistake? It is conventional to
virtualize destructors of base classes so that it is safe to delete a
base class pointer.</c>
    </m>
    <m id="1510">
        <c>The indicated class is a base class for some derived class that has a
destructor. The base class does not have a destructor. Is this a
mistake? The difficulty that you may encounter is this; if you represent
(and manipulate) a heterogeneous collection of possibly derived objects
via a pointer to the base class then you will need a virtual base class
destructor to invoke the derived class destructor.</c>
    </m>
    <m id="1511">
        <c>The named member of a derived class hides a similarly named member of a
base class. Moreover, the base class member is not virtual. Is this a
mistake? Was the base member supposed to have been declared virtual? By
unnecessarily using the same name, confusion could be created.</c>
    </m>
    <m id="1513">
        <c>A class member was declared with the extern or register storage class
specifier. Member declarations are not allowed to be declared as extern
or register.</c>
    </m>
    <m id="1516">
        <c>A data member of a class happens to have the same name as a member of a
base class. Was this deliberate? Identical names can cause confusion. To
inhibit this message for a particular symbol or for an identifiable set
of symbols use -esym().</c>
    </m>
    <m id="1520">
        <c>More than one assignment operator of the same kind (given in detail as
copy, move, or non-copy non-move) has been declared for a given class.
For example, for class X there may have been declared:

    void operator=(X);
    void operator=(X) const;

Which is to be used for assignment?</c>
    </m>
    <m id="1521">
        <c>For a given class, more than one function was declared that could serve
as a copy or move constructor. Typically, this means that you declared
both X( X&amp; ) and X( const X&amp; ) for the same class. This is probably a
mistake.</c>
    </m>
    <m id="1524">
        <c>A call to new has been found in a constructor for a class for which no
explicit destructor has been declared. A destructor was expected because
how else can the storage be freed?</c>
    </m>
    <m id="1526">
        <c>A non-private member function (named in the message) of a non-library
class was not defined. This message is suppressed for unit checkout
(-unit_check option).</c>
    </m>
    <m id="1527">
        <c>A static data member (named in the message) of a non-library class was
not defined. In addition to its declaration within the class, it must be
defined in some module.</c>
    </m>
    <m id="1529">
        <c>The assignment operator does not appear to be checking for assignment of
the value of a variable to itself (assignment to this). Specifically,
PC-lint Plus is looking for the first statement of the assignment
operator be an if statement which compares this to either &amp;argument or
std::addressof(argument) using either == or !=.

It is important to check for a self assignment so as to know whether the
old value should be subject to a delete operation. This is often
overlooked by a class designer since it is counter-intuitive to assign
to oneself. But, through the magic of aliasing (pointers, references,
function arguments) it is possible for an unsuspecting programmer to
stumble into a disguised self-assignment.
If you are currently using the following test

    if( arg == *this)

we recommend you replace this with the more efficient:

    if( &amp;arg == this || arg == *this)</c>
    </m>
    <m id="1531">
        <c>A member allocation function (operator new or delete, including array
forms) was declared within a non-final class and does not appear to
utilize the dynamic size of the allocation. The size parameter may have
been omitted entirely (in the case of operator delete) or was never
referenced within the function. Because the enclosing class is not
final, another class could derive from this class and inherit a member
allocation function that relies on a fixed size appropriate only for the
base class.</c>
    </m>
    <m id="1532">
        <c>A member operator delete should check its argument for NULL as it is
unspecified whether deallocation functions are invoked when a null
pointer is deleted.</c>
    </m>
    <m id="1533">
        <c>A friend declaration for a particular symbol (class or function) was
repeated in the same class. Usually this is a harmless redundancy.</c>
    </m>
    <m id="1534">
        <c>A static variable (symbol) was found within an inline function within a
header file. This can be a source of error since the static variable
will not retain the same value across multiple modules. Rather each
module will retain its own version of the variable. If multiple modules
need to use the function then have the function refer to an external
variable rather than a static variable. Conversely, if only one module
needs to use the function then place the definition of the function
within the module that requires it.</c>
    </m>
    <m id="1535">
        <c>A member function is returning an address being held by the indicated
member symbol (presumably a pointer). The member&apos;s access (such as
private or protected) is lower than the access of the function returning
the address.</c>
    </m>
    <m id="1536">
        <c>A member function is returning the non-const address of a member either
directly or via a reference. Moreover, the member&apos;s access (such as
private or protected) is lower than the access of the function returning
the address. For example:

    class X {
    private:
        int a;
    public:
        int *f() { return &amp;a; }
    };

This looks like a breach of the access system . You may lower the access
rights of the function, raise the accessibility of the member, or make
the return value a const pointer or reference. In the above example you
could change the function to:

    const int *f() { return &amp;a; }</c>
    </m>
    <m id="1537">
        <c>A const function is behaving suspiciously. It is returning a pointer
data member (or equivalently a pointer to data that is pointed to by a
data member). For example,

    class X {
        int *p;
        int *f() const { return p; }
    };

Since f is supposedly const and since p is presumptively pointing to
data that is logically part of class X, we certainly have the potential
for a security breach. Either return a pointer to const or remove the
const modifier to the function. This message will not be issued when
returning a function pointer.
Note, if a const function returns the address of a data member then a
605 (capability increase) is issued.</c>
    </m>
    <m id="1538">
        <c>The indicated base class did not appear in the initializer list for a
copy or move constructor. Was this an oversight? If the initializer list
does not contain an initializer for a base class, the default
constructor is used for the base class. This is not normally appropriate
for a copy or move constructor. The following is more typical:

    class B { ... };
    class D : public B {
        D( const D &amp;arg ) : B( arg ) { ... }
        ...
    };</c>
    </m>
    <m id="1539">
        <c>The indicated symbol was not assigned by an assignment operator. Was
this an oversight? It is not strictly necessary to initialize all
members in an assignment operator because the &apos;this&apos; class is presumably
already initialized. But it is easy to overlook the assignment of
individual members. It is also easy to overlook your responsibility to
assign base class members. This is not done for you automatically.
The message is not given for const members or reference members. If you
have a member that is deliberately not initialized you may suppress the
message for that member only using -esym.</c>
    </m>
    <m id="1540">
        <c>The indicated member is a non-static pointer member of a class that was
apparently not freed by the class destructor. Was this an oversight? By
freeing, we mean either a call to the free() function or use of the
delete operator. If the pointer is intended only to point to static
information during its lifetime then, of course, it never should be
freed. In that case you should signal closure by assigning it the NULL
pointer (0).</c>
    </m>
    <m id="1541">
        <c>The indicated non-static data member may not have been initialized by
the specified constructor. Specifically, this means that the member does
not have an in-class initializer, was not present in the
member-initializer list, and was assigned a value (directly or
indirectly by a called function) in only some of the paths that the
constructor takes.</c>
    </m>
    <m id="1544">
        <c>A variable (identified by symbol) was used in the run-time
initialization of a static variable. However this variable itself was
initialized at run-time. Since the order of initialization cannot be
predicted this is the source of a possible error.
Whereas addresses are completely known at initialization time, values
may not be. Whether the value or merely the address of a variable is
used in the initialization of a second variable is not an easy thing to
determine when an argument is passed by reference or via pointer. For
example, given struct X defined as:

    struct X {
        X(const X &amp;);
        X();
    };

a module containing the definition:

    extern X x1;
    X x2 = x1;

and another module that defines x1, PC-lint Plus will issue a message
similar to:

    warning 1544: value of variable &apos;x2&apos; is indeterminate due to run
        time initialization of &apos;x1&apos;
    X x2 = x1;
      ^

It is theoretically possible, but unlikely, that the constructor X() is
interested only in the address of its argument and not its current
value. If so, it only means you will be getting a spurious report, which
you can suppress based on variable name. However, if the const is
missing when passing a reference parameter (or a pointer parameter) then
we cannot easily assume that values are being used. In this case no
report will be issued. The moral is that if you want to get the checking
implied by this message you should make your constructor reference
arguments const.</c>
    </m>
    <m id="1546">
        <c>The body of a destructor (signature provided within the message)
contains a throw not within a try block. This is dangerous because
destructors are themselves triggered by exceptions in sometimes
unpredictable ways. The result can be a perpetual loop.</c>
    </m>
    <m id="1547">
        <c>An assignment from an array of a derived class to a pointer to a base
class was detected. For example:

    class B { };
    class D : public B {};
    D a[10];
    B *p = a;         // Warning 1547
    B *q = &amp;a [0];    //OK

In this example p is being assigned the address of the first element of
an array. This is fraught with danger since access to any element other
than the zeroeth must be considered an error (we presume that B and D
actually have or have the potential to have different sizes).
We do not warn about the assignment to q because it appears that the
programmer realizes the situation and wishes to confine q to the base
object of the zeroeth element of a only. As a further precaution against
inappropriate array access, out of bounds warnings are issued for
subsequent references to p[1] and q[1].</c>
    </m>
    <m id="1548">
        <c>The exception specification of a function begins with the keyword
&apos;throw&apos; and follows the prototype. Two declarations were found for the
same function with inconsistent exception specifications.</c>
    </m>
    <m id="1549">
        <c>An exception was thrown (i.e., a throw was detected) within a function
and not within a try block; more over the function contains a throw
specification but the exception thrown was not on the list. If you
provide an exception specification, include all the exception types you
potentially will throw.</c>
    </m>
    <m id="1550">
        <c>A function was called (first symbol) that was declared as throwing an
exception. The call was not made from within a try block and the
function making the call (second symbol) had an exception specification
that did not include one of the types specified in the called function&apos;s
exception specification. Either add the exception to the calling
function&apos;s exception list, or place the call inside a try block and
catch the throw.</c>
    </m>
    <m id="1551">
        <c>A call to a function (given by the first symbol) was made from within a
destructor given by the second symbol. The called function was declared
as potentially throwing an exception. Such exceptions need to be caught
within a try block because destructors should never throw exceptions. .</c>
    </m>
    <m id="1552">
        <c>This warning is similar to Warning 1547 and is sometimes given in
conjunction with it. It uses value tracking to determine that an array
(that could be dynamically allocated) is being assigned to a base class
pointer. For example,

    Derived *d = new Derived[10];
    Base *b;
    b = d;       // Warning 1552
    b = &amp;d[0];   //OK

This case is an issue because if one tries to access b[i], where i is an
index value, the compiler will attempt to access the object with the
address i * sizeof(Base) from b. However, since the size of Derived is
almost certain to be larger than the size of Base, this object is not
the i-th Derived object.
 Also, see the article by Mark Nelson (Bug++ of the Month, Windows
Developer&apos;s Journal, May 1997, pp. 43-44).</c>
    </m>
    <m id="1554">
        <c>In a copy constructor a pointer was merely copied rather than recreated
with new storage. This can create a situation where two objects have the
same data and this, in turn, causes problems when these objects are
deleted or modified. For example, the following class will draw this
warning:

    class X {
        char *p;
        X(const X &amp;x) { p = x.p; }
    };

Here, member p is expected to be recreated using new or some variant.</c>
    </m>
    <m id="1555">
        <c>In a copy assignment operator a pointer was merely copied rather than
recreated with new storage. This can create a situation where two
objects have the same data and this, in turn, causes problems when these
objects are deleted or modified. For example, the following class will
draw this warning:

    class X {
        char *p;
        X &amp;operator=(const X &amp;x) { p = x.p; }
    };

Here, member p is expected to be recreated using new or some variant.</c>
    </m>
    <m id="1556">
        <c>A new expression had the form new T(integer) where type T has no
constructor. For example:

    new int(10);

will draw this warning. The expression allocates an area of storage
large enough to hold one integer. It then initializes that integer to
the value 10. Could this have been a botched attempt to allocate an
array of 10 integers? Even if it was a deliberate attempt to allocate
and initialize a single integer, a casual inspection of the code could
easily lead a reader astray.
The warning is only given when the type T has no constructor. If T has a
constructor then either a syntactic error will result because no
constructor matches the argument or a match will be found. In the latter
case no warning will or should be issued.</c>
    </m>
    <m id="1558">
        <c>The function declared both virtual and inline has been detected. An
example of such a situation is as follows:

    class C {
        virtual inline void f();
    };

Virtual functions by their nature require an address and so inlining
such a function seems contradictory. We recommend that the inline
function specifier be removed.</c>
    </m>
    <m id="1559">
        <c>The named exception occurred within a try block and was either not
caught by any handler or was caught but then thrown from the handler.
Destructors should normally not throw exceptions.</c>
    </m>
    <m id="1560">
        <c>A direct or indirect throw of the named exception occurred within a try
block and was either not caught by any handler or was rethrown by the
handler. Moreover, the function has an exception specification and the
uncaught exception is not on the list. Note that a function that fails
to declare a list of thrown exceptions is assumed to potentially throw
any exception.</c>
    </m>
    <m id="1562">
        <c>The first symbol is that of an overriding virtual function for the
second symbol. The exception specification for the first was found not
to be a subset of the second. For example, it may be reasonable to have:

    struct B   { virtual void f() throw(B); };
    struct D:B { virtual void f() throw(D); };

Here, although the exception specifications are not identical, the
exception D is considered a subset of the base class B.
It would not be reasonable for D::f() to throw an exception outside the
range of those thrown by B::f() because in general the compiler will
only see calls to B::f() and it should be possible for the compiler to
deduce what exceptions could be thrown by examining the static call.</c>
    </m>
    <m id="1563">
        <c>The third argument to ?: contained an unparenthesized assignment
operator such as

    p ? a : b = 1

If this is what was intended you should parenthesize the third argument
as in:

    p ? a : (b = 1)

Not only is the original form difficult to read but C, as opposed to
C++, would parse this as:

    (p ? a : b) = 1</c>
    </m>
    <m id="1564">
        <c>An integer constant expression other than the integer literal 0 or 1 was
implicitly converted to bool. It may have been unintended that the value
will essentially be discarded as the result of the expression will
depend only on whether or not it was zero. If the Boolean use of this
expression was intentional it could be explicitly compared != 0 to
clarify the intent (note that Boolean comparison against integral values
other than 0 is discouraged because all non-zero values are equally true
- see message 697).</c>
    </m>
    <m id="1565">
        <c>A function dubbed &apos;initializer&apos; by a -sem option is not initializing
(i.e., assigning to) every data member of a class. const members
theoretically can be initialized only via the constructor so that these
members are not candidates for this message.</c>
    </m>
    <m id="1566">
        <c>A class data member (whose name and location are indicated in the
message) was not directly initialized by a constructor. It may have been
initialized by a separately called member function. If this is the case
you may follow the advice given in the message and use a semantic option
to inform PC-lint Plus that the separately called function is in fact an
&apos;initializer&apos;. For example:

    class A {
        int a;
    public:
        void f();
        A() { f(); }
    };

Here f() is presumably serving as an initializer for the constructor
A::A(). To inform PC-lint Plus of this situation, use the option:

    -sem( A::f, initializer )

This will suppress Warning 1566 for any constructor of class A that
calls A::f.</c>
    </m>
    <m id="1570">
        <c>In a constructor initializer, a reference class member is being
initialized to bind to an auto variable. Consider:

    class X { int &amp;n; X(int k) :n(k) {} };

In this example member n is being bound to variable k, which although a
parameter, is nonetheless placed into auto storage. But the lifetime of
k is only the duration of the call to the constructor, whereas the
lifetime of n is the lifetime of the class object constructed.</c>
    </m>
    <m id="1571">
        <c>A function that is declared to return a reference is returning an auto
variable (that is not itself a reference). The auto variable is not
guaranteed to exist beyond the lifetime of the function. This can result
in unreliable and unpredictable behavior.</c>
    </m>
    <m id="1572">
        <c>A static variable has a lifetime that will exceed that of the auto
variable that it has been bound to. Consider

    void f( int n ) { static int&amp; r = n; ... }

The reference r will be permanently bound to an auto variable n. The
lifetime of n will not extend beyond the life of the function. On the
second and subsequent calls to function f the static variable r will be
bound to a non-existent entity.</c>
    </m>
    <m id="1576">
        <c>An explicit specialization of a function template was found to be
declared in a file other than the one in which the corresponding
function template is declared. Two identical calls in two different
modules on the same function template could then have two differing
interpretations based on the inclusion of header files. The result is
undefined behavior.
As if this wasn&apos;t enough, if the explicit specialization could match two
separate function templates then the result you obtain could depend upon
which function templates are in scope.
See also the next message.</c>
    </m>
    <m id="1578">
        <c>The indicated member is a non-static data member of a class that was
apparently not cleared by a function that had previously been given the
cleanup semantic. By clearing we mean that the pointer was either zeroed
or the storage associated with the pointer released via the free
function or its semantic equivalent or some form of delete. See also
Warning 1540.</c>
    </m>
    <m id="1579">
        <c>A class data member (whose name and location are indicated in the
message) was not directly freed by the class destructor. There was a
chance that it was cleared by a separately called member function. If
this is the case you may follow the advice given in the message and use
a semantic option to inform PC-lint Plus that the separately called
function is in fact a &apos;cleanup&apos; function. For example:

    class A {
        int *p;
    public:
        void release_ptrs();
        ~A() { release_ptrs(); }
    };

Here release_ptrs() is presumably serving as a cleanup function for the
destructor ~A::A(). To inform PC-lint Plus of this situation, use the
option:

    -sem( A::release_ptrs, cleanup )

A separate message (Warning 1578) will be issued if the cleanup function
fails to clear all pointers. See also Warning 1566.</c>
    </m>
    <m id="1705">
        <c>A static class member was accessed using a class object and -&gt; or .
notation. For example:

    s.member

or

    p-&gt;member

But an instance of the object is not necessary. It could just as easily
have been referenced as:

    X::member

where X is the class name.</c>
    </m>
    <m id="1706">
        <c>Class members within a class are not normally declared with the scope
operator. For example:

    class X { int X::n; };

will elicit this message. If the (redundant) class specification (X::)
were replaced by some different class specification and the declaration
was not friend an error (1040) would be issued.</c>
    </m>
    <m id="1707">
        <c>operator new() and operator delete(), when declared as member functions,
should be declared as static. They do not operate on an object
instantiation (implied this pointer).</c>
    </m>
    <m id="1710">
        <c>This message is issued when the standard requires the use of &apos;typename&apos;
to disambiguate the syntax within a template where it may not be clear
that a name is the name of a type or some non-type. (See C++ Standard ,
Section temp.res, Para 2). Consider:

    template &lt;class T&gt;
    class A {
        T::N x;   // Info 1710
    };

while technically ill-formed, some compilers will accept this construct
since the only interpretation consistent with valid syntax is that T::N
represents a type. (But if the &apos;x&apos; weren&apos;t there it would be taken as an
access declaration and more frequently would be a non-type.)</c>
    </m>
    <m id="1711">
        <c>The given class has a virtual function but is not the base class of any
derivation. Was this a mistake? There is no advantage to making member
functions virtual unless their class is the base of a derivation tree.
In fact, there is a disadvantage because there is a time and space
penalty for virtual functions. This message is not given for library
classes and is suppressed for unit checkout.</c>
    </m>
    <m id="1714">
        <c>A non-private member function was not referenced. This message is
automatically suppressed for unit checkout (-unit_check) and for members
of a library class.</c>
    </m>
    <m id="1715">
        <c>A static data member of a class was not referenced. This message is
automatically suppressed for unit checkout (-unit_check) and for members
of a library class.</c>
    </m>
    <m id="1719">
        <c>The typical assignment operator for a class is of the form:

    X&amp; operator =(const X &amp;)

If the argument is not a reference then your program is subject to
implicit function calls and less efficient operation.</c>
    </m>
    <m id="1720">
        <c>The typical assignment operator for a class is of the form:

    X&amp; operator =(const X &amp;)

If the argument is not const then your program will not be diagnosed as
completely as it might otherwise be.</c>
    </m>
    <m id="1721">
        <c>Class assignment operators typically have one of the following forms:

    X&amp; operator=(const X &amp;);  // copy assignment
    X&amp; operator=(X &amp;&amp;);       // move assignment

A member function whose name is operator= but does not have one of these
forms is unusual and may be a subtle source of bugs. If this is not an
error you may selectively suppress this message for the given class.</c>
    </m>
    <m id="1722">
        <c>The typical assignment operator for a class X is of the form:

    X&amp; operator =(const X &amp;);

The reason for returning a reference to class is to support multiple
assignment as in:

    a = b = c

See also messages 9409 and 9412.</c>
    </m>
    <m id="1724">
        <c>The parameter for a copy constructor is generally declared as a
reference to const. This signature is not only standard practice but is
also the way a compiler-provided copy constructor is generated. Using a
reference that is not to const will prevent it from accepting rvalues,
including temporary objects (although an applicable move constructor
would take precedence if available). The omission of const can also
cause unexpected results when a copy constructor is declared as deleted,
for example:

    struct A {
        A(int) { }
        operator bool() { }
        A(A&amp;) = delete; // should be const A&amp;
    };
    void f() {
        A b = A(5); // compiles even though the copy constructor is deleted
    }

If the copy constructor in this example had been declared to take a
reference to const, the temporary would have triggered the selection of
the copy constructor and led to the compilation error that would
probably be expected when attempting an operation resembling copy
construction. Without const, the compiler does not consider the copy
constructor because the parameter type cannot accept an xvalue, and
instead a circuitous and perhaps unexpected conversion sequence is
chosen.</c>
    </m>
    <m id="1726">
        <c>The delete operator was applied to either a pointer to const or an array
of const. While permitted by the C++ standard, the practice is
questioned. If a function didn&apos;t have the capability of writing into the
area designated by a pointer why would we suppose it to be ok to delete
the area?</c>
    </m>
    <m id="1727">
        <c>A function declared or defined inline was not previously declared
inline. Was this intended? If this is your standard practice then
suppress this message.</c>
    </m>
    <m id="1728">
        <c>A function was previously declared or defined inline. The inline
modifier is absent from the current declaration or definition. Was this
intended? If this is your standard practice then suppress this message.</c>
    </m>
    <m id="1729">
        <c>In a constructor initializer the order of evaluation is determined by
the member order not the order in which the initializers are given. At
least one of the initializers was given out of order. Was there a reason
for this? Did the programmer think that by changing the order that
he/she would affect the order of evaluation? Place the initializers in
the order of their occurrence within the class so that there can be no
mistaken assumptions.</c>
    </m>
    <m id="1730">
        <c>An object is declared both with the keyword class and with the keyword
struct. Though this is legal it is suspect.</c>
    </m>
    <m id="1731">
        <c>A class member function was declared both public and virtual. Some
authors, see , have advocated avoiding public virtual functions because
such functions are both part of the public interface and a customization
point, aspects often with conflicting motives and audiences. Rather than
make the virtual function public consider making it protected. This way
members of the hierarchy may still customize behavior.</c>
    </m>
    <m id="1732">
        <c>Within a constructor for the cited class, there appeared a new. However,
no assignment operator was declared for this class. Presumably some
class member (or members) points to dynamically allocated memory. Such
memory is not treated properly by the default assignment operator.
Normally a custom assignment operator would be needed. Thus, if x and y
are both of type symbol

    x = y;

will result in pointer duplication. A later delete would create chaos.</c>
    </m>
    <m id="1733">
        <c>Within a constructor for the cited class, there appeared a new. However,
no copy constructor was declared for this class. Presumably, because of
the new, some class member (or members) points to dynamically allocated
memory. Such memory is not treated properly by the default copy
constructor. Normally a custom copy constructor would be needed.</c>
    </m>
    <m id="1735">
        <c>A virtual function was detected with a default parameter. For example:

    class B {
        virtual void f( int n = 5 );
        ...
    };

The difficulty is that every virtual function f overriding this virtual
function must contain a default parameter and its default parameter must
be identical to that shown above. If this is not done, no warnings are
issued but behavior may have surprising effects. This is because when
f() is called through a base class pointer (or reference) the function
is determined from the actual type (the dynamic type) and the default
argument is determined from the nominal type (the static type). .</c>
    </m>
    <m id="1736">
        <c>An access specifier (one of public, private, or protected as shown in
string) is redundant. That is, the explicitly given access specifier did
not have to be given because an earlier access specifier of the same
type is currently active. This message is NOT given for an access
specifier that is the first item to appear in a class definition. Thus,

    class abc { private: ...

does not draw this message. The reason this message is issued is because
it is very easy to make the following mistake.

    class A {
    public:
        ...
    public:
        ...
    }

In general there are no compiler warnings that would result from such an
unintentional botch.</c>
    </m>
    <m id="1738">
        <c>In an initializer list for a copy constructor, a base class constructor
was invoked. However, this base class constructor was not itself a copy
constructor. We expect that copy constructors will invoke copy
constructors. Was this an oversight or was there some good reason for
choosing a different kind of constructor? If this was deliberate,
suppress this message. See also message 1538.</c>
    </m>
    <m id="1746">
        <c>The indicated parameter is a candidate to be declared as a const
reference. For example:

    void f( X x ) {
         // x not modified.
    }

Then the function definition can be replaced with:

    void f( const X &amp;x ) {
        // x not modified.
    }

The result may be more efficient since less information needs to be
placed onto the stack and a constructor need not be called.
The message is only given with class-like arguments (including structs
and unions) and only if the parameter is not subsequently modified or
potentially modified by the function. The parameter is potentially
modified if it is passed to a function whose corresponding parameter is
a reference (not const) or if its address is passed to a non-const
pointer. .
This message is not issued for extern C functions, which presumably
cannot employ references.</c>
    </m>
    <m id="1747">
        <c>An operator-like function was found to be returning a reference. For
example:

    X &amp;operator+ ( X &amp;, X &amp; );

This is almost always a bad idea. . You normally can&apos;t return a
reference unless you allocate the object, but then who is going to
delete it. The usual way this is declared is:

    X operator+ ( X &amp;, X &amp; );</c>
    </m>
    <m id="1748">
        <c>Through indirect means, a given class was included at least twice as a
base class for another class. At least one of these is not virtual.
Although legal, this may be an oversight. Such base classes are usually
marked virtual resulting in one rather than two separate instances of
the base class. This is done for two reasons. First, it saves memory;
second, references to members of such a base class will not be
ambiguous.</c>
    </m>
    <m id="1749">
        <c>The designated base class is a direct base class of the second class and
the derivation was specified as &apos;virtual&apos;. But the base class was not
doubly included (using this link) within any class in the entire
project. Since a virtual link is less efficient than a normal link this
may well be an unenlightened use of &apos;virtual&apos;. . The message is
inhibited if unit checkout (-unit_check) is selected.</c>
    </m>
    <m id="1751">
        <c>An unnamed namespace was used in a header file.</c>
    </m>
    <m id="1752">
        <c>This message is issued for every catch parameter that is not a reference
and is not numeric. The problem with pointers is a problem of ownership
and delete responsibilities; the problem with a non-ref object is the
problem of slicing away derivedness .</c>
    </m>
    <m id="1753">
        <c>This message is issued whenever an attempt is made to declare one of
these operators as having some user-defined meaning:

    operator ||
    operator &amp;&amp;
    operator ,

The difficulty is that the working semantics of the overloaded operator
is bound to be sufficiently different from the built-in operators, as to
result in possible confusion on the part of the programmer. With the
built-in versions of these operators, evaluation is strictly
left-to-right. With the overloaded versions, this is not guaranteed.
More critically, with the built-in versions of &amp;&amp; and ||, evaluation of
the 2nd argument is conditional upon the result of the first. This will
never be true of the overloaded version. .</c>
    </m>
    <m id="1754">
        <c>The first symbol is of the form: operator op= where op is a binary
operator. A binary operator op was declared for type X where X is
identified by the second symbol. For example, the appearance of:

    X operator+( const X &amp;, const X &amp; );

somewhere in the program would suggest that a += version appear as a
member function of class X. This is not only to fulfill reasonable
expectations on the part of the programmer but also because operator+=
is likely to be more efficient than operator+ and because operator+ can
be written in terms of operator+=.
The message is also given for member binary operators. In all cases the
message is not given unless the return value matches the first argument
(this is the implicit argument in the case of a member function).</c>
    </m>
    <m id="1756">
        <c>A variable with either static or thread storage duration (the string
parameter indicates which) was declared with a non-POD type. C++ doesn&apos;t
define the order in which static or thread storage duration variables in
different modules are initialized which can be a source of subtle
errors. This message isn&apos;t issued for constexpr variables.</c>
    </m>
    <m id="1757">
        <c>A postfix increment or postfix decrement operator was used in a context
in which the result of the operation was discarded. For example:

    X a;
    ...
    a++;

In such contexts it is just as correct to use prefix
decrement/increment. For example this could be replaced with:

    X a;

    ...
    ++a;

The prefix form is (or should be) more efficient than the postfix form
because, in the case of user-defined types, it should return a reference
rather than a value (see 1758 and 1759). This presumes that the side
effects of the postfix form are equivalent to those of the prefix form.
If this is not the case then either make them equivalent (the preferred
choice) or turn this message off. See also 2902, which is issued for
non-class types. .</c>
    </m>
    <m id="1758">
        <c>To conform with most programming expectations, a prefix
increment/decrement operator should return a reference. Returning a
reference is both more flexible and more efficient .
The expected form is as shown below:

    class X {
        X &amp; operator++();
        X operator++( int );
        ...
    };</c>
    </m>
    <m id="1759">
        <c>To conform with most programming expectations, a postfix
increment/decrement operator should return a value as opposed to a
reference. . See example in message 1758.</c>
    </m>
    <m id="1762">
        <c>The indicated (non-static) member function did not modify member data
and did not call non-const functions. Moreover, it does not make any
deep modification to the class member. A modification is considered deep
if it modifies information indirectly through a class member pointer.
Therefore, it could and probably should be declared as a const member
function.</c>
    </m>
    <m id="1763">
        <c>The designated symbol is a member function declared as const. Though
technically valid, the const may be misleading because the member
function modifies (or exposes) information indirectly referenced by the
object. For example:

    class X {
        char *pc;
        char &amp;get(int i) const { return pc[i]; }
    };

results in Info 1763 for function X::get. This is because the function
exposes information indirectly held by the class X.
Experts recommend that a pair of functions be made available in this
situation:

    class X {
        char *pc;
        const char &amp; get(int i) const { return pc[i]; }
        char &amp; get(int i) { return pc[i]; }
    };

In this way, if the object is const then only the const function will be
called, which will return the protected reference. Related messages are
also 1762 and 1962. See also for a further description.</c>
    </m>
    <m id="1764">
        <c>As an example:

    int f( int &amp; k ) { return k; }

can be redeclared as:

    int f( const int &amp; k ) { return k; }

Declaring a parameter a reference to const offers advantages that a mere
reference does not. In particular, you can pass constants, temporaries
and const types into such a parameter where otherwise you may not. In
addition it can offer better documentation.
Other situations in which a const can be added to a declaration are
covered in messages 818, 952, 953 and 954.</c>
    </m>
    <m id="1766">
        <c>An ellipsis was used in a catch handler resulting in a handler that will
catch any exception. This &quot;catch-all&quot; handler was not preceded by one or
more catch handlers in the same try block meaning that this handler will
be responsible for processing all exceptions. Catch-all exception
handlers are generally considered a bad practice due to the inability to
distinguish between different types of exceptions and the potential to
hide serious issues. The somewhat less serious use of an exception
handler with preceding catch clauses is diagnosed by message 1966.</c>
    </m>
    <m id="1768">
        <c>An overriding virtual function has an access (public, protected or
private) in the derived class different from the access of the
overridden virtual function in the base class. Was this an oversight?
Since calls to the overriding virtual function are usually made through
the base class, making the access different is unusual (though legal).</c>
    </m>
    <m id="1771">
        <c>This message is given for operator new and operator delete (and for
their [] cousins) when a definition for one of these functions is found.
Redefining the built-in version of these functions is not considered
sound programming practice.</c>
    </m>
    <m id="1772">
        <c>The assignment operator should return *this. This is to allow for
multiple assignments as in:

    a = b = c;

It is also better to return the object that has just been modified
rather than the argument.</c>
    </m>
    <m id="1773">
        <c>An attempt was made to cast away const. This can break the integrity of
the const system. This message will be suppressed if you use const_cast.
Thus:

    char *f(const char *p) {
        if (test())
            return (char *)p;              // Info 1773
        else
            return const_cast&lt;char *&gt;(p);  // OK
    }

See .</c>
    </m>
    <m id="1774">
        <c>The result of a cast between two pointer types, other than a
dynamic_cast, was tested for null. Only dynamic_cast can indicate
failure with a null result. The failure of other casts at runtime
produces undefined or implementation-defined behavior.
If the objective was simply to determine if the original pointer was
null before accessing it through a different type then this could be
clarified by testing if the original pointer is null before casting it.
Casting a null pointer from one pointer type to another will generally
produce a valid null pointer in the destination type, but testing this
result for null may mislead the reader that this will, e.g., catch
conversions from a pointer to base class to a pointer to a derived class
that does not match the actual type of the object like a dynamic_cast.
While this message is not restricted to casts involving class types, it
is only issued in C++ modules as there is no expectation in C that any
cast would ever perform the runtime checking associated with
dynamic_cast.</c>
    </m>
    <m id="1775">
        <c>A catch handler does not seem to catch any exceptions. For example:

    try { f(); }
    catch( B&amp; ) {}
    catch( D&amp; ) {}       // Info 1775
    catch( ... ) {}
    catch( char * ) {}   // Info 1775

If f() is declared to throw type D, and if B is a public base class of
D, then the first catch handler will process that exception and the
second handler will never be used. The fourth handler will also not be
used since the third handler will catch all exceptions not caught by the
first two.
If f() is declared to not throw an exception then Info 1775 will be
issued for all four catch handlers.</c>
    </m>
    <m id="1776">
        <c>A string literal, according to Standard C++ is typed an array of
const char. This message is issued when such a literal is assigned to a
non-const pointer. For example:

    char *p = &quot;string&quot;;

will trigger this message. This pointer could then be used to modify the
string literal and that could produce some very strange behavior.
Such an assignment is legal but &quot;deprecated&quot; by the C++ Standard. The
reason for not ruling it illegal is that numerous existing functions
have their arguments typed as char * and this would break working code.
Note that this message is only given for string literals. If an
expression is typed as pointer to const char in some way other than via
string literal, then an assignment of that pointer to a non-const
pointer will receive a more severe warning.</c>
    </m>
    <m id="1777">
        <c>It is possible to write a recursive template that will contain a
recursive invocation without an escape clause. For example:

    template &lt;class T&gt; class A { A&lt; A &gt; x; };
    A&lt;int&gt; a;

This will result in attempts to instantiate:

    A&lt;int&gt;
    A&lt;A&lt;int&gt;&gt;
    A&lt;A&lt;A&lt;int&gt;&gt;&gt;
    ...

Using the -vt option (turning on template verbosity) you will see the
sequence in action. Accordingly, we have devised a scheme to break the
recursion when an arbitrary depth of recursion has been reached (at this
writing 75). This depth is reported in the message. As the message
suggests, this limit can be adjusted so that it equals some other value.
When recursion is broken, a complete type is not used in the definition
of the last specialization in the list but processing goes on.</c>
    </m>
    <m id="1778">
        <c>This message is issued when a string literal is assigned to a variable
whose type is a non-const pointer. For example:

    char *p;  p = &quot;abc&quot;;

The message is issued automatically (i.e. by default) for C++. For C, to
obtain the message, you need to enable the Strings-are-Const flag
(+fsc). This message is similar to message 1776 except that it is issued
whenever a string constant is being assigned to a named destination.</c>
    </m>
    <m id="1779">
        <c>A virtual function was declared in a class marked as final but does not
override any base class virtual function. Since the class is final it
cannot be a base class and the virtual function cannot be overridden in
a derived class. If the intention is for this function to override a
virtual function in a base class, mark the base class function as
virtual. Otherwise either remove the final specifier on the class or the
virtual specifier on the function.</c>
    </m>
    <m id="1780">
        <c>The address of a parameter that has been declared as being a reference
to a const is being returned from a function. The danger of this is that
the reference may designate a temporary variable that will not persist
long after the call. For example:

    const int *f( const int &amp; n )
        { return &amp;n; }
    int g();
    const int *p = f( g() );

Here, p points to a temporary value whose duration is not guaranteed. If
the reference is not const then you will get Elective Note 1940.
This is an example of the Linton Convention as described by Murray .</c>
    </m>
    <m id="1781">
        <c>The address of a parameter that has been declared as being a reference
to a const is being assigned to a place outside the function. The danger
of this is that the reference may designate a temporary variable that
will not persist long after the call. For example:

    void f( const int &amp; n, const int **pp )
        { *pp = &amp;n; }
    int g();
    const int *p;
    ... f( g(), &amp;p );

Here, p will be made to point to a temporary value whose duration is not
guaranteed. If the reference is not const then you will get Elective
Note 1940.
This is an example of the Linton Convention as described by Murray .</c>
    </m>
    <m id="1782">
        <c>The address of a parameter that has been declared as being a reference
to a const is being assigned to a static variable. The danger of this is
that the reference may designate a temporary variable that will not
persist long after the call. For example:

    const int *p;
    void f( const int &amp; n )
        { p = &amp;n; }
    int g();
    ... f( g() );

Here, p will be made to point to a temporary value whose duration is not
guaranteed. If the reference is not const then you will get Elective
Note 1940.
This is an example of the Linton Convention as described by Murray .</c>
    </m>
    <m id="1784">
        <c>A symbol is being redeclared in the same module. Whereas earlier it had
been declared with an extern C linkage, in the cited declaration no such
linkage appears. E.g.

    extern &quot;C&quot; void f(int);
    void f(int);             // Info 1784

In this case the extern C prevails and hence this inconsistency probably
represents a benign redeclaration. Check to determine which linkage is
most appropriate and amend or remove the declaration in error.</c>
    </m>
    <m id="1785">
        <c>A Boolean expression was assigned (via assignment, return, argument
passing or initialization) to an object of some other type. Was this the
programmer&apos;s intent? The use of a cast will prevent this message from
being issued.</c>
    </m>
    <m id="1786">
        <c>A non-Boolean expression was assigned (via assignment, return, argument
passing or initialization) to an object of type Boolean. Was this the
programmer&apos;s intent? The use of a cast will prevent this message from
being issued.</c>
    </m>
    <m id="1787">
        <c>The C++ Standard ( section 7.3.3) specifically deprecates the use of
access declarations. The preferred syntax is the using declaration. For
example:

    class D : public B {
        B::a;         // message 1787
        using B::a;   // preferred form and no message
    };

In C++11, support for access declarations were removed completely. In
C++11 and later modes, this message is replaced with an error.</c>
    </m>
    <m id="1788">
        <c>A variable has not been referenced other than by the constructor that
formed its initial value or by its destructor or both. The location of
the symbol and also its type is given in the message. For example:

    struct A {
        A();
    };
    void f() { A a; }

will produce a 1788 for variable &apos;a&apos; and for type &apos;A&apos;.
It very well may be that this is exactly what the programmer wants to
do, in which case you may suppress this message for this variable using
the option -esym(1788,a). It may also be that the normal use of class A
is to employ it in this fashion. That is, to obtain the effects of
construction and, possibly, destruction but have no other reference to
the variable. In this case the option of choice would be -esym(1788,A).</c>
    </m>
    <m id="1789">
        <c>This message is issued for classes for which a copy constructor was not
defined but a template constructor was defined. For example:

    struct A {
           template &lt;typename T&gt;
           A(const T&amp;);            // Info 1789
    };

The C++ standard specifically states that a template constructor will
not be used as a copy constructor. Hence, a default copy constructor is
created for such a class while the programmer may be deluded into
thinking that the template will be employed for this purpose. .</c>
    </m>
    <m id="1790">
        <c>A public base class contained no virtual functions except possibly
virtual destructors. There is a school of thought that public
inheritance should only be used to interject custom behavior at the
event of virtual function calls. To quote from Marshall Cline, &quot;Never
inherit publicly to reuse code (in the base class); inherit publicly in
order to be reused (by code that uses base objects polymorphically)&quot; .</c>
    </m>
    <m id="1791">
        <c>A line is found that ends with a return keyword and with no other tokens
following. Did the programmer forget to append a semi-colon? The problem
with this is that the next expression is then consumed as part of the
return statement. Your return might be doing more that you thought. For
example:

    void f( int n, int m ) {
        if( n &lt; 0 ) return   // do not print when n is negative
        print( n );
        print( m );
    }

Assuming print() returns void, this is entirely legal but is probably
not what you intended. Instead of printing n and m, for n not negative
you print just m. For n negative you print n.
To avoid this problem always follow the return keyword with something on
the same line. It could be a semi-colon, an expression or, for very
large expressions, some portion of an expression.</c>
    </m>
    <m id="1793">
        <c>A non-static and non-const member function was called and an rvalue (a
temporary object) of class symbol was used to initialize the implicit
object parameter. This is legal (and possibly intentional) but
suspicious. Consider the following.

    struct A { void f(); };
    ...
    A().f();          // Info 1793
    ...

In the above the &apos;non-static, non-const member function&apos; is A::f(). The
&apos;implicit object parameter&apos; for the call to A::f() is A(), a temporary.
Since the A::f() is non-const it presumably modifies A(). But since A()
is a temporary, any such change is lost. It would at first blush appear
to be a mistake.
The Standard normally disallows binding a non-const reference to an
rvalue but as a special case allows it for the binding of the implicit
object parameter in member function calls. Some popular libraries take
advantage of this rule in a legitimate way. For example, the GNU
implementation of std::vector&lt;bool&gt;::operator[] returns a temporary
object of type std::_Bit_reference - a class type with a non-const
member operator=(). _Bit_reference serves a dual purpose. If a value is
assigned to it, it modifies the original class through its operator=().
If a value is extracted from it, it obtains that value from the original
class through its operator bool().
This message will not be issued for member functions declared using an
rvalue ref-qualifier such as void f() &amp;&amp;;.
Probably the best policy to take with this message is to examine
instances of it and if this is a library invocation or a specially
designed class, then suppress the message with a -esym() option.</c>
    </m>
    <m id="1798">
        <c>A block scope function declaration was found within a function whose
innermost enclosing namespace was not the global namespace. This alone
cannot introduce a namespace member but the declaration of the nested
function will still be taken to refer to a (possibly non-existent)
member of the innermost enclosing namespace. This can lead to pernicious
linker errors if one expects the declared function to introduce a
namespace member into the innermost enclosing namespace or the global
namespace. It is also easy to misidentify the innermost enclosing
namespace, for example:

    namespace X {
        namespace Y {
            struct Z {
                void f();
            };
        }
    }
    using X::Y::Z;

    void Z::f() {
        void g();
        g();
    }

The declaration on line 11 can be a source of confusion. The enclosing
function is defined using the qualified name Z::f in a definition
written at global scope, but g is neither the global ::g nor the invalid
&apos;Z::g&apos; (for Z is a struct). The call to g on line 12 will invoke
X::Y::g().
This message will not be issued for a block scope function declaration
outside of a namespace. See message 9108.</c>
    </m>
    <m id="1901">
        <c>PC-lint Plus judges that a temporary needs to be created. This occurs,
typically, when a conversion is required to a user object (i.e. class
object). Where temporaries are created, can be an issue of some concern
to programmers seeking a better understanding of how their programs are
likely to behave. But compilers differ in this regard.</c>
    </m>
    <m id="1902">
        <c>It is possible to follow a function body with a useless semi-colon. This
is not necessarily &apos;lint&apos; to be removed but may be a preferred style of
programming (as semi-colons are placed at the end of other
declarations).</c>
    </m>
    <m id="1904">
        <c>For the real bridge-burner one can hunt down and remove all instances of
the /* ... */ form of comment.</c>
    </m>
    <m id="1906">
        <c>A function was declared with an exception specification. Some authors
contend exception specifications are not worth using due to a presumably
false sense of security associated with the specifications. See for
example .</c>
    </m>
    <m id="1907">
        <c>The named class does not itself have an explicit destructor but either
had a base class that has a destructor or has a member class that has a
destructor (or both). In this case a destructor will be generated by the
compiler.</c>
    </m>
    <m id="1908">
        <c>The destructor cited was inherited from a base class with a virtual
destructor. This word &apos;virtual&apos; was omitted from the declaration. It is
common practice to omit this keyword when implied. See also 1909.</c>
    </m>
    <m id="1909">
        <c>The named function overrides a base class virtual function and so is
virtual. It is common practice to omit the virtual keyword in these
cases although some feel that this leads to sloppy programming. This
message allows programmers to detect and make explicit which functions
are actually virtual.</c>
    </m>
    <m id="1911">
        <c>The symbol in the message is the name of a constructor called to make an
implicit conversion. This message can be helpful in tracking down hidden
sources of inefficiencies.</c>
    </m>
    <m id="1912">
        <c>A conversion function (one of the form symbol::operator type ()) was
implicitly called. This message can be helpful in tracking down hidden
sources of inefficiencies.</c>
    </m>
    <m id="1914">
        <c>A default constructor was not referenced. When a member function of a
class is not referenced, you will normally receive an Informational
message (1714) to that effect. When the member function is the default
constructor, however, we give this Elective Note instead.
The rationale for this different treatment lay in the fact that many
authors recommend defining a default constructor as a general principle.
Therefore, if you are following a modus operandi of not always defining
a default constructor you may want to turn on message 1914 instead.</c>
    </m>
    <m id="1915">
        <c>A virtual function that overrides a base class function was not declared
with the override virt-specifier. This message is only emitted for C++11
and higher. See also the softer 9421 which is only issued if neither
override nor final are specified.</c>
    </m>
    <m id="1916">
        <c>An ellipsis was encountered while processing the prototype of some
function declaration. An ellipsis is a way of breaking the typing system
of C or C++.</c>
    </m>
    <m id="1919">
        <c>A member assignment operator was declared but it is neither a copy
assignment operator nor a move assignment operator. Assignment operators
with specific signatures are considered special member functions. The
declaration of a non-copy non-move assignment operator will not prevent
the compiler from generating its own implicit copy and move assignment
operators.
If this declaration was intended to allow assignment from an object of a
different type, a &quot;converting assignment operator&quot; may be supported more
generally using a converting constructor unless the construction and
assignment of an object have unique semantics that prevent analogous
initialization.</c>
    </m>
    <m id="1920">
        <c>The ARM states that reference casts are often &apos;misguided&apos;. However, too
many programs are openly using reference casts to place such casts in
the Informational category.</c>
    </m>
    <m id="1924">
        <c>A C-style cast was used in C++ code. This can usually be replaced by one
of the newer C++ casts: static_cast, dynamic_cast, const_cast,
reinterpret_cast, or a combination thereof. .

This message is not issued for casts to void used to discard values. See
1954.</c>
    </m>
    <m id="1925">
        <c>The indicated symbol is a public data member of a class. If the class is
introduced with the keyword struct the message is not issued. In some
quarters the use of public data members is deprecated. The rationale is
that if function calls replace data references in the public interface,
the implementation can change without affecting the interface.</c>
    </m>
    <m id="1926">
        <c>A member of a class (identified by symbol) did not appear in the
constructor initialization list. Since it had a default constructor this
constructor was implicitly called. Is this what the user intended? Some
authorities suggest that all members should appear in the constructor
initialization list. ].</c>
    </m>
    <m id="1927">
        <c>A member of a class (identified by symbol) did not appear in a
constructor initialization list. If the item remains uninitialized
through the whole of the constructor, a Warning 1401 is issued. Some
authorities suggest that all members should appear in the constructor
initialization list. .</c>
    </m>
    <m id="1928">
        <c>A base class (identified by symbol) did not appear in a constructor
initialization list. If a constructor does not appear, the default
constructor is called. This may or may not be valid behavior. If a base
class is missing from the initializer list of a copy constructor (as
opposed to some ordinary constructor), a more severe Warning (1538) is
issued. .</c>
    </m>
    <m id="1929">
        <c>A non-member function was found to be returning a reference. This is not
normally considered good practice because responsibility for deleting
the object is not easily assigned. No warning is issued if the base
class has no constructor. .</c>
    </m>
    <m id="1930">
        <c>A non-explicit conversion operator is a member function of the form:

    operator Type ();

This will be called implicitly by the compiler whenever an object (of
the class type) is to be converted to type Type. Some programmers
consider such implicit calls to be potentially harmful leading to
programming situations that are difficult to diagnose. See for example .
Explicit conversion operators declared with the explicit keyword are not
reported.</c>
    </m>
    <m id="1931">
        <c>A constructor was found that could be used for implicit conversions. For
example:

    class X {
    public:
        X(int);
        ...
    };

Here any int (or type convertible to int) could be automatically
converted to X. This can sometimes cause confusing behavior. If this is
not what was intended, use the keyword &apos;explicit&apos; as in:

    explicit X(int);

This will also serve to suppress this message. See also message 9169.</c>
    </m>
    <m id="1932">
        <c>An abstract class is a class with at least one pure virtual specifier.
At least one author has argued that all base classes should be abstract
although this suggestion flies in the face of existing practice.</c>
    </m>
    <m id="1933">
        <c>A classical C++ gotcha is the calling of a virtual function from within
a constructor or a destructor. When we discover a direct call from a
constructor or destructor to a virtual function we issue Warning 1506.
But what about indirect calls. Suppose a constructor calls a function
that in turn, perhaps through several levels of call, calls a virtual
function. This could be difficult to detect. Dan Saks has suggested a
compromise Guideline that &quot;imposes few, if any, practical restrictions&quot;.
The Guideline, implemented by this Elective Note, issues a message
whenever an unqualified virtual function is called by any other
(non-static) member function (for the same &apos;this&apos; object). For example:

    class X { virtual void f(); void g(); };

    void X::g() {
        f();          // Note 1933
        X::f();       // ok -- non virtual call.
    }

Even if total abstinence is unwarranted, turning on message 1933
occasionally can be helpful in detecting situations when constructors or
destructors call virtual functions.</c>
    </m>
    <m id="1934">
        <c>It has been suggested that you should never make a shift operator a
member function unless you&apos;re defining ostream or istream (the message
is suppressed in these two cases). The reason is that there is a
temptation on the part of the novice to, for example, define output to
ostream as a class member function left shift that takes ostream as an
argument. This is exactly backwards. The shift operator normally employs
the destination (or source) on the left.
On the other hand, if the class you are defining is the source or
destination then defining the shift operators is entirely appropriate.</c>
    </m>
    <m id="1937">
        <c>A static scalar whose name is symbol has a destructor. Destructors of
static objects are invoked in a predictable order only for objects
within the same module (the reverse order of construction). For objects
in different modules this order is indeterminate. Hence, if the correct
operation of a destructor depends on the existence of an object in some
other module an indeterminacy could result. See also 1544.</c>
    </m>
    <m id="1938">
        <c>A constructor is accessing global data. It is generally not a good idea
for constructors to access global data because order of initialization
dependencies can be created. If the global data is itself initialized in
another module and if the constructor is accessed during initialization,
a &apos;race&apos; condition is established.</c>
    </m>
    <m id="1939">
        <c>A down cast is a cast from a pointer (or reference) to a base class to a
pointer (or reference) to a derived class. A cast down the class
hierarchy is fraught with danger. Are you sure that the alleged base
class pointer really points to an object in the derived class? Some
amount of down casting is necessary, but a wise programmer will reduce
this to a minimum.</c>
    </m>
    <m id="1940">
        <c>The address of a reference parameter is being transferred (either via a
return statement, assigned to a static, or assigned through a pointer
parameter) to a point where it can persist beyond the lifetime of the
function. These are all violations of the Linton Convention (see Murray
).
The particular instance at hand is with a reference to a non-const and,
as such, it is not considered as dangerous as with a reference to a
const. (See 1780, 1781 and 1782 for those cases). For example:

    int *f( int &amp;n ) { return &amp;n; }
    int g();
    int *p = f( g() );

would create a problem were it not for the fact that this is diagnosed
as a non-lvalue being assigned to a reference to non-const.</c>
    </m>
    <m id="1941">
        <c>The typical use of an assignment operator for class C is to assign new
information to variables of class C. If this were the entire story there
would be no need for the assignment operator to return anything.
However, it is conventional to support chains of assignment as in:

    C x, y, z;
    ...
    x = y = z;
    // parsed as x = (y = z);

For this reason assignment normally returns a reference to the object
assigned the value. For example, assignment (y = z) would return a
reference to y.
Since it is almost never the case that this variable is to be
reassigned, i.e. we almost never wish to write:

    (x = y) = z; // unusual

as a general rule it is better to make the assignment operator return a
const reference. This will generate a warning when the unusual case is
attempted.
But experts differ. Some maintain that in order to support non-const
member functions operating directly on the result of an assignment as
in:

    (x = y).mangle();

where, as its name suggests, mangle is non-const it would be necessary
for the return value of assignment to be non-const. Another reason to
not insist on the const qualifier is that the default assignment
operator returns simply a reference to object and not a reference to
const object. In an age of generic programming, compatibility may be
more important than the additional protection that the const would
offer.</c>
    </m>
    <m id="1943">
        <c>This message is issued for file-scope variables of class type that have
a non-trivial constructor that requires the constructor to be executed
to initialize the object at startup time. This can be a potential
performance concern.</c>
    </m>
    <m id="1944">
        <c>This message is issued for file-scope variables of class type that have
a non-trivial destructor that requires the destructor to be executed to
destroy the object at shutdown time. This can be a potential performance
concern.</c>
    </m>
    <m id="1945">
        <c>This message is issued for file-scope variables of class type that have
a non-trivial destructor that requires the destructor to be executed to
destroy the object at shutdown time. This can be a potential performance
concern.</c>
    </m>
    <m id="1946">
        <c>This message is issued for all functional-style casts except those that
apply a converting constructor / conversion operator that has been
marked as explicit.</c>
    </m>
    <m id="1954">
        <c>A C-style cast to void was used in C++ code. If one endeavors to
eliminate all C-style casts, a static_cast could be used instead.</c>
    </m>
    <m id="1962">
        <c>The designated member function could be declared const but shouldn&apos;t be
because it contains a deep modification. For example:

    class X {
        char *p;

    public:
        void f() { *p = 0; }
    };

will elicit this message indicating that X::f() contains a deep
modification. A modification is considered shallow if it modifies (or
exposes for modification) a class member directly. A modification is
considered deep if it modifies information indirectly through a class
member pointer. This Elective Note is available for completeness so that
a programmer can find all functions that could result in a class being
modified. It does not indicate that the programming is deficient. In
particular, if the function is marked const an Info 1763 will be issued.
See also 1762, 1763.</c>
    </m>
    <m id="1966">
        <c>An ellipsis was used in a catch handler resulting in a handler that will
catch any exception. This &quot;catch-all&quot; handler was preceded by one or
more catch handlers in the same try block such that this handler will
catch any exceptions not caught by one of the more specific handlers.
Catch-all exception handlers are generally considered a bad practice due
to the inability to distinguish between different types of exceptions
and the potential to hide serious issues. The use of such an exception
handler without any preceding catch clauses is diagnosed by message
1766.</c>
    </m>
    <m id="1970">
        <c>This Elective Note diagnoses the use of default capture in a lambda
expression. string is either = or &amp;. The use of default capture can have
unintended consequences, even in apparently innocuous situations and as
such it has been suggested that default capture never be used. For an
in-depth discussion of the issue, see .</c>
    </m>
    <m id="1971">
        <c>The motivation for the creation of the function-try block in C++ is to
allow for the handling of exceptions thrown during the processing of
constructor initializer lists. Such exceptions cannot be handled inside
of the body of the constructor as the body is not yet entered. While
function-try blocks are allowed for non-constructor functions, the same
functionality can be obtained using the more general try-catch block
inside the body of the function.</c>
    </m>
    <m id="1972">
        <c>An empty declaration was encountered; this can happen from an extraneous
semi-colon:

    int x;;

Note: In PC-lint this was reported as error 19.</c>
    </m>
    <m id="1973">
        <c>The delete operator was applied to a non-parameter pointer to const.
This is legal and not necessarily suspect. See also message 1726 reports
on cases where the pointer being deleted is a function parameter, which
is more likely to result in unexpected behavior.</c>
    </m>
    <m id="2001">
        <c>An appropriately sized integer type could not be found when attempting
to determine the smallest integer type with enough bits to represent a
bitfield or an integer constant expression.</c>
    </m>
    <m id="2006">
        <c>A \x or \u escape sequence was seen but there were no hexadecimal digits
immediately following the sequence.</c>
    </m>
    <m id="2400">
        <c>PC-lint Plus has encountered an unexpected situation while processing
the provided source code. This doesn&apos;t necessarily represent either a
bug in the source code or in PC-lint Plus, and PC-lint Plus will
continue to operate normally, but rather serves to report potentially
interesting circumstances that may be of use to Gimpel Software
engineering staff. This message is not emitted unless appropriate
debugging options are enabled.</c>
    </m>
    <m id="2401">
        <c>The format string for a printf/scanf style function contains both
positional and non-positional arguments. Positional arguments are an
extension provided by POSIX implementations but mixing positional and
non-positional arguments results in undefined behavior. For example:

    printf(&quot;%1$d %d&quot;, 1, 2);

will elicit this message.</c>
    </m>
    <m id="2402">
        <c>The format string for a printf/scanf style function contains a
conversion specifier whose width or precision is given as an asterisk
(*) indicating that the width/precision be extracted from the next
argument, which should have type int, but this argument was not
provided.</c>
    </m>
    <m id="2403">
        <c>The width or precision of a conversion specifier within the format for a
printf or scanf style function was specified with an asterisk (*) and as
such a corresponding int argument was expected to represent the
width/precision but the argument in that position was not the correct
type. For example:

    extern double f;
    printf(&quot;%*d&quot;, f, f);

will yield the messages:

    field width should have type &apos;int&apos;, but argument has type &apos;double&apos;</c>
    </m>
    <m id="2404">
        <c>Within the format string of a printf or scanf style function, a
positional parameter specifier was expected for a field width or
precision that used the asterisk (*) to indicate that the field or width
should be taken from the argument list but one was not provided. For
example:

    printf(&quot;%1$*d&quot;, 1, 2);

will yield the message:

    invalid position specified for field width

This is because when positional specifiers are used within a format
string, all arguments must have corresponding positional specifiers. The
correct way to indicate that the field width corresponds to the second
data argument is:

    printf(&quot;%1$*2$d&quot;, 1, 2);</c>
    </m>
    <m id="2405">
        <c>The use of a field width or precision with an incompatible conversion
specifier has been encountered. Standard C allows a precision to be used
only with the d, I, o, u, x, X, a, A, e, E, f, F, g, and G conversion
specifiers and a field width to be used with any conversion specifiers
except for n. Use of field width/precision outside of these conversion
specifiers results in undefined behavior.</c>
    </m>
    <m id="2406">
        <c>Within a format string for a scanf style function, a &apos;%[&apos; was seen
denoting the start of a scan list but there was no terminating &apos;]&apos;. The
lack of a closing bracket makes the conversion specification invalid and
results in undefined behavior.</c>
    </m>
    <m id="2407">
        <c>Within a scanf style function, a zero was given as the maximum field
width. Standard C specifies that the maximum field width for scanf must
be a &quot;decimal integer greater than zero&quot;. Providing a zero as the width
makes the conversion specifier invalid resulting in undefined behavior.</c>
    </m>
    <m id="2408">
        <c>A non-POD or non-trivial class type that cannot be passed as a variadic
function argument was given as the argument to a printf/scanf style
function. The first type specifies the type of the argument that was
provided, the second type specifies the type that was expected from the
format string.</c>
    </m>
    <m id="2410">
        <c>Recursively executing the initializer for a static local variable is
undefined behavior, even if it appears not to cause an infinite loop. An
implementation with proper support for thread-safe static initialization
is likely to deadlock.</c>
    </m>
    <m id="2414">
        <c>This message is issued when a non-standard, non-user-defined, numeric
literal suffix that is recognized by PC-lint Plus is encountered. The
use of non-standard literal suffixes is not portable. The suffixes
reported by this message include q/Q, I8/I16/I32/I64 (and the lowercase
equivalents), NaN and Infinity.</c>
    </m>
    <m id="2423">
        <c>A value was provided to a mathematical function that will result in a
domain error. For example, the acos function is only defined for values
in the range [-1, 1], values provided outside this range will be
diagnosed by this message. Value tracking is used to determine the value
provided to the function. For example:

    double foo(double x, double y) {
        acos(x + y);
    }
    void bar() {
        foo(0.5, 0.75);
    }

will elicit the message:

    warning 2423: apparent domain error for function &apos;acos(double)&apos;,
        argument 1 (value=1.25) outside of accepted range (between -1 and 1)
    acos(x + y);
           ^</c>
    </m>
    <m id="2425">
        <c>A call was made to a function for which a user-defined semantic exists
but the semantic could not be applied because it contains a semantic
that is not valid for this call. There are several reasons this can
occur including specifying a semantic for an argument that does not
exist, a return value of a type that conflicts with the actual return
value, or the use of a symbol or macro in the semantic that cannot be
resolved at the time of the call.</c>
    </m>
    <m id="2426">
        <c>A user-defined return semantic was specified for a function for which
PC-lint Plus has access to the implementation. Furthermore, PC-lint has
determined that during a specific call of the function the actual value
returned conflicts with the claimed return value in the return semantic.
This represents a likely error in either the implementation of the
function or the specification of the semantic. See also &quot;Return Semantic
Validation&quot; in the Reference Manual in the Semantics chapter.</c>
    </m>
    <m id="2427">
        <c>The array associated with an initializer list is allocated with a
temporary lifetime. The lifetime of the array will not be extended
beyond the full expression of a return statement. The returned
initializer list will contain dangling pointers. For example:

    #include &lt;initializer_list&gt;

    std::initializer_list&lt;int&gt; f() {
        return { 1, 2, 3 }; // The memory used to store the array
                            // elements will be freed before returning.
    }

    void g() {
        auto x = f();
        // Attempting to access the elements of x will read invalid memory.
    }

Note that this message will be issued when returning a local variable of
initializer_list type (regardless of initialization source), including a
parameter. While it may initially appear safe to return an
initializer_list argument as the lifetime was determined by the caller,
this is likely to lead to invalid use of the return value in the caller
when a temporary argument is destroyed at the end of the statement of
the call expression.</c>
    </m>
    <m id="2430">
        <c>Standard C requires the presence of whitespace between a macro name and
its definition for object-like macros. For example:

    #define MINUS-

will elicit:

    warning 2430: missing whitespace between macro name &apos;MINUS&apos; and definition
    #define MINUS-
                 ^

Despite the warning, the macro MINUS is still defined to - so it is safe
to suppress this message for legacy code that cannot be changed. The
best way to address the warning is to place a space between the macro
name and definition:

    #define MINUS -</c>
    </m>
    <m id="2431">
        <c>The line number provided to the #line number preprocessing directive
(and the GNU equivalent # number) is always interpreted as a decimal
number, even when the first digit is a zero. For example, #line 034 is
treated as #line 34, not as #line 28 (the decimal equivalent of octal
34). As such, a #line directive with a line number beginning with a zero
is suspicious.</c>
    </m>
    <m id="2432">
        <c>Within a construct that appears to be a macro include guard, the name of
the macro being checked is similar to, but different from, the name of
the macro subsequently defined. For example:

    #ifndef FOO_INCLUDED
    #define FOO_INCLODED
    ...
    #endif

will elicit:

    warning 2432: macro &apos;FOO_INCLUDED&apos; used as header guard is followed by a
        #define of a similar but different macro &apos;FOO_INCLODED&apos;
    #ifndef FOO_INCLUDED
            ^~~~~~~~~~~~

This usually represents a typo, which will prevent the include guard
from functioning as intended. This message can be suppressed with
-estring using the name of the macro being defined, e.g.
-estring(2432, FOO_INCLODED) if the difference was intentional.</c>
    </m>
    <m id="2433">
        <c>Bounds-checked format functions are described in Annex K of the C11
standard. The bounds-checked printf-like functions forbid the use of the
%n conversion specifier.</c>
    </m>
    <m id="2434">
        <c>This message is a less certain variant of 449 and is issued when the
deallocation was dependent on conditional execution flow at runtime.</c>
    </m>
    <m id="2435">
        <c>The same declaration specifier was used more than once in the
declaration of a symbol. For example:

    inline inline void foo();

will elicit this message. Was this intended? While legal, it is suspect.
Other specifiers that will be diagnosed for duplicates include virtual,
explicit, _Noreturn, friend, and constexpr.</c>
    </m>
    <m id="2436">
        <c>A function that was declared as not returning either with the keyword
_Noreturn or a GCC or C++11 noreturn attribute contained a return
statement. Returning from a function designated as not returning invokes
undefined behavior.</c>
    </m>
    <m id="2437">
        <c>An indirection on a non-volatile null pointer was encountered. While
this is undefined behavior as far as Standard C is concerned, the
programmer may have intended for this to generate a trap condition
relying on implementation details but the compiler is likely to simply
remove the offending indirection instead. The null pointer should be
volatile to indicate to the compiler that it should not be optimized
out.</c>
    </m>
    <m id="2438">
        <c>The values of two different enumeration types were used in an equality
or comparison operation. This is suspect because there is no intrinsic
relationship among different enumeration types and as such it usually
doesn&apos;t make sense to compare them. For example:

    enum color { RED, GREEN, BLUE };
    enum fruit { APPLE, PEAR, MANGO };

    void foo(enum color c, enum fruit f) {
        if (c == f) return;     // 2438 issued here
        // ...
    }

The message is parameterized by the two enumeration types compared.</c>
    </m>
    <m id="2439">
        <c>A lint comment was encountered that did not contain any lint options,
was this a mistake? The comment may be empty or may start with text that
does not begin an option. For example:

    //lint e714 -e715

Since e714 does not start with a -, +, or !, it, along with everything
that follows, is assumed to be commentary. In this case -e714 was
probably meant.</c>
    </m>
    <m id="2440">
        <c>The address of a function, array, or variable was directly compared to
null. This is suspicious because the address of a function or variable
can never be null in well-formed code. Note that this message is not
given for null checks of function or object pointers. For example:

    void foo(int *pi) {
        if (!pi) return;        // Okay
        if (&amp;pi == 0) return;   // 2440
        if (foo != 0) return;   // 2440
    }

The first string parameter is one of &apos;function&apos;, &apos;array&apos;, or &apos;address
of&apos; and the second string parameter represents the corresponding
function, array, or variable.</c>
    </m>
    <m id="2441">
        <c>The address of a function, array, or variable was used in a boolean
context. This is suspicious because such an address can never be false.
Note that this message is not given for function or object pointers. For
example:

    void foo(int *pi) {
        if (!pi) return;    // Okay
        if (&amp;pi) return;    // 2441
        if (!foo) return;   // 2441
    }

The first string parameter is one of &apos;function&apos;, &apos;array&apos;, or &apos;address
of&apos; and the second string parameter represents the corresponding
function, array, or variable.</c>
    </m>
    <m id="2444">
        <c>The condition of a switch statement has enum type but contains a case
statement with a value that doesn&apos;t correspond to any of the enumerators
in the enum. For example:

    enum color { RED, GREEN, BLUE };
    void foo(enum color c) {
        switch (c) {
        case RED:       // OK
        case RED + 1:   // OK, refers to GREEN
        case 2:         // OK, refers to BLUE
        case 3: ...     // Warning 2444, no member with value 3
        }
    }</c>
    </m>
    <m id="2445">
        <c>A cast was made from a pointer to one type to a pointer to a type that
has greater alignment requirements than the type pointed to by the
original pointer. For example, assuming an alignment requirement of 4
bytes for &apos;int&apos; and 8 bytes for &apos;long double&apos;:

    void foo(int *pi) {
        long double *pld = (long double *)pi;
    }

will result in the message:

    warning 2445: cast from &apos;int *&apos; to &apos;long double *&apos; increases
        required alignment from 4 to 8
    long double *pld = (long double *)pi;
                       ^~~~~~~~~~~~~~~~~

Accessing the value through the new pointer may invoke undefined
behavior if it is not properly aligned. The alignment requirements of
fundamental types can be set using the -a option.
The message is parameterized by the types of the pointer before and
after the cast and the alignment requirements of the types before and
after the cast.</c>
    </m>
    <m id="2446">
        <c>During a token pasting operation performed by the preprocessor ##
operator, an invalid token was formed. This is illegal even if the
result is immediately pasted with another token that would then form a
valid token. For example, a naive token concatenation macro might look
like:

    CAT(x, y) x##y

which would work fine in cases like int i = CAT(1,2); and expand to
int i = 12; without issue. The problem comes about when the macro is
invoked recursively, such as:

    int i = CAT(CAT(1, 2), 3);

which will be greeted with:

    warning 2446: pasting formed &apos;)3&apos;, an invalid preprocessing token
    int i = CAT(CAT(1, 2),3);
            ^
    supplemental 893: expanded from macro &apos;CAT&apos;
    #define CAT(x,y) x##y
                      ^

followed by other parsing errors. One way to handle this is to use two
macros:

    #define CATX(x, y) x##y
    #define CAT(x, y) XCAT(x, y)</c>
    </m>
    <m id="2447">
        <c>This message is issued when the main function is declared as static,
inline, constexpr, or deleted. The C++ Standard forbids the main
function to be declared with these specifiers.</c>
    </m>
    <m id="2448">
        <c>According to the C Standard, the main function must return int in a
hosted environment but a return type other than int was specified for
main. If you are targeting a freestanding/embedded platform or making
use of non-standard extensions, you should suppress this message.</c>
    </m>
    <m id="2449">
    </m>
    <m id="2450">
        <c>A literal null character was encountered within the module being
processed and will be ignored by PC-lint Plus.</c>
    </m>
    <m id="2452">
        <c>A pointer to an signed integer type was implicitly converted to or from
a pointer to the corresponding unsigned integer type. For example:

    void foo(int *p) {
        unsigned *up = p;   // Warning 2452
    }</c>
    </m>
    <m id="2453">
        <c>A pointer type was implicitly converted to an incompatible integer type.
For example:

    void foo(float *p) {
        int i = p;  // Warning 2453
    }</c>
    </m>
    <m id="2454">
        <c>A pointer type was implicitly converted to an incompatible pointer type.
For example:

    void foo(float *pf) {
        int *pi = pf;  // Warning 2454
    }</c>
    </m>
    <m id="2455">
        <c>A function pointer type was implicitly converted to an incompatible
function pointer type. For example:

    void foo(int i) {
        int (*pf)(float) = &amp;foo;    // Warning 2455
    }</c>
    </m>
    <m id="2456">
        <c>A C++ language linkage specification was encountered in a C module. For
example:

    extern &quot;C++&quot; int i;

This may indicate that a C++ module is incorrectly being processed in C
mode or that a region of code that is only intended to be processed in
C++ is not properly guarded (e.g. with #ifdef __cplusplus). Language
linkage specifications in C mode are supported by some embedded
compilers. If your compiler supports this, feel free to suppress this
message.</c>
    </m>
    <m id="2460">
        <c>A string, character, integer, or floating literal was provided as an
argument to a function parameter which was designated with the argument
semantic indicating that the argument should not be a literal. For
example, perhaps a database connection function should not receive a
string literal in the password argument field.</c>
    </m>
    <m id="2461">
        <c>This message is issued at the conclusion of global wrap-up if a call to
the standard rand or POSIX random function was found in the program but
no call to the corresponding seed function srand or srandom was found.</c>
    </m>
    <m id="2465">
        <c>A tag that was previously defined is being redefined in a function
parameter list. While this is legal, it is suspect as this redefinition
will only be visible within the function. It would be better to use
another name and/or place the desired definition outside the function if
the intention is to make the tag visible elsewhere.</c>
    </m>
    <m id="2466">
        <c>The specified symbol was used despite being marked as unused, either via
#pragma unused, the GCC __attribute__ syntax, or with a C++11-style
attribute specified. For example:

    int i = 1;
    #pragma unused(i)
    int j [[gnu::unused]] = 2;
    int k __attribute__((unused)) = 3;

Message 2466 will be issued if i, j, or k are subsequently used.</c>
    </m>
    <m id="2470">
        <c>A file stream was subjected to multiple consecutive pushbacks (such as
by the ungetc function). Standard C guarantees support for pushing back
a single character. While some implementations support pushback of
multiple characters, this is non-portable.</c>
    </m>
    <m id="2471">
        <c>An operation was performed on a file stream that has been closed. The
value of a file pointer after calling fclose is indeterminate and
attempts to perform file operations in such a pointer result in
undefined behavior.</c>
    </m>
    <m id="2472">
        <c>A non-standard character was encountered in the mode argument to fopen
or freopen. The allowable characters are a, b, r, w, x, and +; other
characters appearing in the mode argument results in undefined behavior.</c>
    </m>
    <m id="2473">
        <c>The mode argument in a call to fopen or freopen contained valid
characters but was not one of the specific combinations allowed by
Standard C and therefore will result in undefined behavior. The allowed
combinations are:

  ----- ----- ------ -----
  r     w     wx     a
  rb    wb    wbx    ab
  r+    w+    w+x    a+
  r+b   w+b   w+bx   a+b
  rb+   wb+   wb+x   ab+
  ----- ----- ------ -----

The second string parameter provides an explanation of why the mode
argument is invalid.</c>
    </m>
    <m id="2474">
        <c>An file stream that was not opened for writing was provided as an
argument to a file-flushing function such as fflush. Attempting to flush
a file stream that wasn&apos;t opened for writing (or update) results in
undefined behavior.</c>
    </m>
    <m id="2475">
        <c>An attempt was made to flush a file stream immediately following an
input operation; this results in undefined behavior.</c>
    </m>
    <m id="2476">
        <c>An attempt was made to read from a file stream that was not opened for
reading. This results in undefined behavior.</c>
    </m>
    <m id="2477">
        <c>An attempt was made to write to a file stream that was not opened for
writing. This results in undefined behavior.</c>
    </m>
    <m id="2478">
        <c>An attempt was made to read from a file stream following a write
operation on the stream. Failure to flush or reposition the stream
between a write and subsequent read operation results in undefined
behavior.</c>
    </m>
    <m id="2479">
        <c>An attempt was made to write to a file stream following a read operation
on the stream. Failure to reposition the stream between a read and
subsequent write operation results in undefined behavior.</c>
    </m>
    <m id="2480">
        <c>A byte-oriented file manipulation function was called with a
wide-oriented file stream which results in undefined behavior.</c>
    </m>
    <m id="2481">
        <c>A wide-oriented file manipulation function was called with a
byte-oriented file stream which results in undefined behavior.</c>
    </m>
    <m id="2491">
        <c>A sizeof expression was encountered inside of a preprocessor
conditional. Furthermore, the expression appearing within sizeof was not
previously registered with the -pp_sizeof option and will evaluate to
zero. See the -pp_sizeof option for more information.</c>
    </m>
    <m id="2498">
        <c>Bitwise comparison of structures containing floating point values leads
to the comparison of the object representations of data members of
floating point type. See 2499.</c>
    </m>
    <m id="2499">
        <c>Bitwise comparison of the object representations of floating point
values may differ in a number of ways from value comparison using
comparison operators. Common differences include inequality of
representations of zero and negative zero and equality of identical NaN
representations (but inequality of NaNs with different payload bits).</c>
    </m>
    <m id="2501">
        <c>An unsigned integer type was promoted to a signed type as an operand to
the unary minus operator. This may surprise those who are otherwise
familiar with the common adage that applying unary minus to an unsigned
type does not yield a negative value (see message 501). For example:
(assuming 16-bit shorts and 32-bit ints)

    -(unsigned)5; // 2^32 - 5, type is still unsigned int
    -(unsigned short)5; // -5, type is signed int</c>
    </m>
    <m id="2536">
        <c>Source files are expected to be encoded as UTF-8 or UTF-16 text. The
provided source file was presumed to contain UTF-8 text but an invalid
byte sequence was encountered inside of an unprefixed string literal.
Encoding errors encountered outside of string literals are reported via
error 336.</c>
    </m>
    <m id="2586">
        <c>This message is issued when a entity is encountered that has been
deprecated using either the C++14 deprecated attribute or the GCC
deprecated attribute syntax. The type and name of the deprecated entity
are provided in the message. If the deprecation contains a reason text,
this is included as an additional string parameter as the end of the
message. An 891 message provides the location of the actual deprecation.
For example:

    [[deprecated]] void foo();

    void bar() {
        foo();
    }

The use of foo on line 4 results in the message:

    warning 2586: Function &apos;foo&apos; is deprecated
        foo();
        ^
    supplemental 891: Function &apos;foo&apos; was marked deprecated here
            [[deprecated]] void foo();
                        ^

This message is not used to report the use of entities that are
deprecated with the -deprecate option, such instances are instead
reported by message 586.</c>
    </m>
    <m id="2601">
        <c>A pointer to automatic storage was passed as an argument to a function
parameter with the no_ptr_to_auto semantic. Note that during a specific
walk this message is not limited to local variables in the immediate
function performing the call, for example:

    //lint -sem(save, no_ptr_to_auto(1))
    void save(int* p);
    void g(int* x) {
        save(x);
    }
    void f(void) {
        int a = 5;
        g(&amp;a);
    }

will report:

    4  warning 2601: passing address of auto variable &apos;a&apos; to parameter 1 of
        function &apos;save&apos;
        save(x);
        ^
    8  supplemental 894: during specific walk g(&amp;(5))
        g(&amp;a);
        ^</c>
    </m>
    <m id="2618">
        <c>A non-type specifier was provided after a type specifier in a
declaration. For example int inline foo(); will elicit this message. The
non-type specifiers reported by this message are: friend, constexpr,
thread_local, mutable, inline, virtual, and explicit. See also message
618 which reports storage class specifiers appearing after a type and
message 963 which reports on const and volatile qualifiers before or
after a type.</c>
    </m>
    <m id="2623">
        <c>Value tracking inferencing has determined that the value provided to a
mathematical function is within a range that contains values that are
not appropriate for the function and may result in a domain error. For
example:

    double foo(unsigned i) {
        if (i &lt;= 10)
            acos(i);
    }

will solicit the message:

    warning 2623: possible domain error for function &apos;acos(double)&apos;, argument 1
       (value=0:10) outside of accepted range (between -1 and 1)
           acos(i);
                ^

as the valid range for the argument to acos is [-1, 1] and all that is
known about the value provided is that it is between 0 and 10. To
eliminate the diagnostic, the test should be corrected as in

    if (i &lt;= 1)</c>
    </m>
    <m id="2641">
        <c>An enumeration type was implicitly converted to a floating point type.
Since enumerations are always represented using integral underlying
types, it is suspicious to use an enumeration value in a floating point
context. This message can be suppressed by using a cast.</c>
    </m>
    <m id="2650">
        <c>This message is issued when only the &quot;greater than&quot; or &quot;less than&quot; part
of a &quot;greater than or equal&quot; or &quot;less than or equal&quot; compound comparison
operator is out of range. For example (assuming 8-bit bytes):

    void foo(unsigned char a) {
        if (a == 255) { }   // Okay - &apos;a&apos; could be equal to 255
        if (a &gt; 255) { }    // 650  - &apos;a&apos; can&apos;t be greater than 255
        if (a &gt;= 255) { }   // 2650 - &apos;a&apos; could be equal but not greater than 255

Message 2650 is issued on line 4 because while a could be equal to 255,
it cannot be greater than 255 so the use of the &gt;= operator is
suspicious (perhaps a was intended to be compared to a different value).
See also message 650 which is issued when the provided constant is out
of range for the entire comparison operator.</c>
    </m>
    <m id="2662">
        <c>This message is issued instead of 662 when a pointer that appears likely
not to refer to an array is subject to integer arithmetic. Addition,
subtraction, and array subscripting are considered. Referring to the
value itself with the operand zero is ignored. For example:

    void f(int a) {
        int* p = &amp;a;
        p[0] = 0;
        p[1] = 0;   // Warning 2662
        p + 0;
        p + 1;      // Warning 2662
    }</c>
    </m>
    <m id="2666">
        <c>This message is issued when a function-like macro is invoked with a
parameter that appears as though it would have side effects if it were
evaluated but since the corresponding parameter is not expanded in the
macro definition, no side-effect will occur. E.g.:

    #define DEBUG_VAL(x)

    int process(int i) {
        DEBUG_VAL(++i);  // 2666 - increment doesn&apos;t occur
        /* ... */
        return i;
    }

Since the parameter isn&apos;t expanded, ++i is not evaluated and the
increment does not occur which may be unexpected. If the intention is
that the side-effect occurs regardless of how the macro is defined, the
expression provoking the side effect should be placed outside the macro
invocation. For the purpose of this message, any expression appearing to
contain a function call is considered to have side-effects.
Detail is one of &quot;parameter is not referenced in the expansion&quot; or
&quot;parameter is only used with #/## operators&quot;. The message can be
suppressed based on the value of the detail parameter by using -estring.</c>
    </m>
    <m id="2670">
        <c>A called an function. This is likely to cause undefined behavior.</c>
    </m>
    <m id="2671">
        <c>An contained a return statement. This is likely to cause undefined
behavior.</c>
    </m>
    <m id="2701">
        <c>The specified symbol was declared inside of a module but not defined
inside the same module. If the symbol is defined in another module, it
would be better to place the declaration of the symbol in a header and
include that header in the modules that use the symbol.</c>
    </m>
    <m id="2702">
        <c>The named static symbol was declared in a header included by the module
but was not used within the including module. If the symbol had been
declared in the module itself, warning 528 would be issued instead.</c>
    </m>
    <m id="2703">
        <c>A dangling else occurs when an if/else construct appears as the unbraced
body of an if statement. In such cases, it may not be clear which of the
if statements the else is intended to be associated with. For example:

    int foo(int a, int b) {
        if (a)
        if (b)
            return 1;
        else
            return 0;
        return 2;
    }

Is the else statement part of the if (a) or the if (b)? In C and C++,
the else is associated with the closest preceding if that it is legal to
be associated with so the else in the example is associated with if (b).
The message can be addressed by placing braces around the parent if (a)
statement to make the intention explicit:

    int foo(int a, int b) {
        if (a) {
            if (b)
                return 1;
            else
                return 0;
        }
        return 2;
    }</c>
    </m>
    <m id="2704">
        <c>An integer value with the potential to equal the most negative possible
integer was negated. In a two&apos;s complement representation, there is no
positive equivalent to the most negative representable integer. For
example:

    void f(int a) {
        if (a &lt; 0) {
            a = -a;
        }
        // Not safe to assume a is non-negative, negation of -2147483648
        // yields the same negative value in many compilers.
    }</c>
    </m>
    <m id="2705">
        <c>A type qualifier was provided for the return type of a function but has
no effect. Was the intention to qualify the function, a pointee type, a
reference to the type returned, or something else? For example:

    const int foo();

will be met with this message as const qualifier has no effect in this
context.</c>
    </m>
    <m id="2706">
        <c>An integer constant is being used to assign a value to an enumeration
type but the constant value does not match the value of any of the
enumeration&apos;s enumerators. For example:

    enum color { RED, GREEN, BLUE };

    void foo(enum color);
    void bar() {
        enum color c1 = RED;    // Okay
        enum color c2 = 0;      // Okay
        enum color c3 = 3;      // 2706
        foo(4);                 // 2706
    }

The values 3 and 4 are not part of the enumeration &apos;color&apos; so 2706 will
be issued in these cases.</c>
    </m>
    <m id="2707">
        <c>The specified function has no means of returning to its caller but this
information is not included in the functions declaration via either the
C11 _Noreturn keyword, the C++11 noreturn attribute, or the GCC noreturn
attribute. Adding this information to the declaration may help clarify
the purpose of the function.</c>
    </m>
    <m id="2709">
        <c>A value of type &apos;char&apos; was used as the subscript to an array. &apos;char&apos; is
a signed type on some platforms, relying on the signedness of &apos;char&apos; in
this was is not wise.</c>
    </m>
    <m id="2712">
        <c>The specified function was declared as taking a large object type
by-value. It may be more efficient to have the function receive a
pointer or reference instead. The threshold for determining what
constitutes a large object is specified using the -size option.</c>
    </m>
    <m id="2713">
        <c>A large object type is being returned by-value from the specified
function; you might want to consider returning the object by pointer or
reference instead. The threshold for determining what constitutes a
large object is specified using the -size option.</c>
    </m>
    <m id="2715">
        <c>The token pasting operator ## appeared between a comma and the
__VA_ARGS__ macro. While supported by several compilers as a mechanism
by which to elide a trailing comma in a variadic macro, such a construct
is technically undefined and could result in different behavior on a
compiler that doesn&apos;t support this extension. See the discussion for the
frc macro for more details.</c>
    </m>
    <m id="2716">
        <c>This message is issued when a declaration for a variable of array type
that acts as a tentative definition is encountered without a declared
array size. A tentative definition in C is a file-scope declaration
without an initializer that does not contain an extern storage class
specifier. If the translation unit contains no external definition for
an identifier, the C Standard specifies that it is defined with the
composite type of the tentative definition(s) for that identifier. In
the case of an array without a size, this becomes an array with one
element. This might represent an oversight in the program. If this was
intentional, it would be clearer to define the array explicitly with one
element.</c>
    </m>
    <m id="2760">
        <c>This message is issued to report a call to the standard srand or POSIX
srandom function if the seed argument is the result of a call to the
standard time function. While this is not uncommon, it is considered
insecure. The current time is predictable and the poor granularity
measured in seconds on typical implementations makes it easy to probe
the entire window in which the application may have called the seed
function. The current time can also be manipulated in a variety of ways,
not only through local access but also potentially through updates from
a malicious time server. The ability for an attacker to predict the
sequence of pseudorandom numbers that will be generated can render
various algorithms insecure.</c>
    </m>
    <m id="2761">
        <c>A called a function that was not explicitly . This could potentially
lead to undefined behavior.</c>
    </m>
    <m id="2762">
        <c>A called a function. This could lead to undefined behavior if the signal
number being registered is not the same signal that invoked this signal
handler.</c>
    </m>
    <m id="2763">
        <c>A called a function to register itself. This could potentially lead to
undefined behavior if the signal number being registered is not the same
signal that invoked this signal handler.</c>
    </m>
    <m id="2764">
        <c>An did not appear to unconditionally end the program. (The end of the
function body was reachable for the purposes of message 527.) This could
potentially lead to undefined behavior.</c>
    </m>
    <m id="2765">
        <c>A referenced a non-local variable that was not _Atomic, std::atomic&lt;T&gt;,
nor volatile sig_atomic_t. This is likely to cause undefined behavior.</c>
    </m>
    <m id="2865">
        <c>A #pragma message directive was encountered. The text of this message is
the string provided in the pragma.</c>
    </m>
    <m id="2901">
        <c>When generating stack reporting data, if the fun flag is set, this
message will be issued once for each function in the stack report with
detail containing the stack information for the function. See -stack for
details.</c>
    </m>
    <m id="2902">
        <c>A post-increment or post-decrement operator was applied to a scalar in a
context where the value will not be used (i.e. as an expression
statement, as the left operand to the comma operator, or as the third
clause of a for statement). A modern optimizing compiler is virtually
guaranteed to elide the wasteful copy implied by such an operation when
the value is not used but some may prefer to use pre-increment or
pre-decrement operators instead for clarity and consistency. See also
1757 for potentially more serious cases involving user-defined types.</c>
    </m>
    <m id="2932">
        <c>A macro with a name that is different from the header guard macro was
defined immediately after the header guard. It is conventional practice
to define the macro used in the header guard check but this is not
always done for every file; this message can be used to identify those
that do not follow this pattern. The more egregious violations (those
that define a macro with a very similar name) are flagged by message
2432.</c>
    </m>
    <m id="2960">
        <c>An integer constant expression was provided as an argument to a function
parameter which was designated with the argument semantic indicating
that the argument should not be a literal. While an integer constant
expression does not necessarily consist of a single literal, it may be
suspicious for many of the same reasons as the value is constant. For
example, perhaps you do not want srand to be seeded with a constant
expression to ensure it produces a different sequence on each execution.
This message can be enabled or suppressed for specific constant values.</c>
    </m>
    <m id="3401">
        <c>There are relatively few valid reasons to declare a move constructor
taking an rvalue reference to const but this construct could easily be
formed by accident due to its similarity to a canonical copy
constructor. This message will not be given if the move constructor is
deleted, as this is occasionally useful.</c>
    </m>
    <m id="3402">
        <c>A lambda with reference capture still implicitly captures the this
pointer by value if any non-static members are used. For clarity, some
prefer to explicitly specify this in the capture list.</c>
    </m>
    <m id="3403">
        <c>A forwarding reference (sometimes referred to as a universal reference)
was given as an argument to std::move. Either the formation of a
forwarding reference instead of an rvalue reference or the use of
std::move instead of std::forward was likely accidental. For example:

    template&lt;typename T&gt;
    void f(T&amp;&amp; t) {
        g(std::move(t)); // might unexpectedly move from the caller&apos;s lvalue
    }</c>
    </m>
    <m id="3405">
        <c>A function was specified as having C language linkage but the function
returns a type that is not compatible with C so what is the point in
having C linkage?</c>
    </m>
    <m id="3406">
        <c>A function that was specified as having C language linkage has an
incomplete return type.</c>
    </m>
    <m id="3407">
        <c>The implementation for an operator new function has the possibility to
return null but the function is not declared with &apos;throw()&apos; or
&apos;noexcept&apos;. Operator new functions should never return null except in
these cases.</c>
    </m>
    <m id="3408">
        <c>The address of a reference was directly compared to null. This is
suspicious because the address of a reference can never be null in
well-formed code

    void foo(int &amp;i) {
      int &amp;ri = i;
      if (&amp;i == 0) return;   // 3408
      if (&amp;i != 0) return;   // 3408
    }</c>
    </m>
    <m id="3409">
        <c>The address of a reference was used in a boolean context. This is
suspicious because such an address can never be false. For example:

    void foo(int &amp;i) {
      int &amp;ri = i;
      if (&amp;i) return;    // 3409
      if (&amp;ri) return;   // 3409
      if (!&amp;i) return;   // 3409
    }</c>
    </m>
    <m id="3410">
        <c>A class contains a conversion function that converts to the type of the
class itself. This is suspicious because such a conversion function will
never be called. For example:

    class X {
       operator X();
    };

will elicit this message.</c>
    </m>
    <m id="3411">
        <c>A class contains a conversion function that converts to the type of its
base class. This is suspicious because such a conversion function will
never be called. For example:

    class X { };
    class Y : public X {
       operator X();
    };

will elicit this message.</c>
    </m>
    <m id="3412">
        <c>A class contains at least one virtual function but has a non-private,
not-virtual destructor. Classes that may be used as base classes should
always have virtual destructors to ensure that instances of derived
classes that are deleted through a pointer to the base class are
properly destructed. The declaration of a virtual function implies that
this class is meant to be used as a base class and as such it should
provide a virtual destructor.</c>
    </m>
    <m id="3413">
        <c>This message is similar to 3412 but while the former warns about the
potential problem that could arise from having a non-virtual destructor,
this message warns when delete is applied to such an object.</c>
    </m>
    <m id="3414">
        <c>This message is similar to 3413 but is reported for abstract types.</c>
    </m>
    <m id="3415">
        <c>A pointer is being initialized with a temporary array, which will be
destroyed at the end of the containing expression making it impossible
to safely dereference the pointer before assigning a new value to it.
For example:

    struct S { int array[10]; };

    void f() {
        int *pi = S().array;   // warning 3415, array pointed to by pi
                               // will cease to exist after initialization.
    }</c>
    </m>
    <m id="3416">
        <c>The this pointer was used in a boolean context such as:

    if (this) ...

Was this a mistake? The this pointer is never null in well-formed C++ so
such a test is suspect.</c>
    </m>
    <m id="3417">
        <c>The this pointer is explicitly tested for null such as

    if (this == 0)

Was this a mistake? The this pointer is never null in well-formed C++ so
such a test is suspect.</c>
    </m>
    <m id="3418">
        <c>A reinterpret_cast was used to cast between a class type and a base
class type in an unsafe way; static_cast should probably be used
instead.</c>
    </m>
    <m id="3419">
        <c>An in-class initializer for a static data member of floating point type
was encountered. This is a non-portable extension.</c>
    </m>
    <m id="3420">
        <c>An extraneous template parameter list was provided in the declaration of
a template specialization. For example:

    template &lt;typename T&gt;
    T foo(T);

    template&lt;&gt;       // warning 3420
    template&lt;&gt;
    int foo(int);</c>
    </m>
    <m id="3421">
        <c>In the partial specialization of a class or variable template, the
presence of one or more template parameters that cannot be deduced means
that the specialization will never be used. Was this a mistake?</c>
    </m>
    <m id="3423">
        <c>A case value, enumerator value, non-type template argument, or array
size was provided that cannot be narrowed to the required type. For
example:

    void foo(unsigned u) {
        switch(u) {
        case -1:         // warning 3423, cannot narrow -1 to unsigned
            break;
            ...
            }
    }

    template &lt;unsigned char I&gt;
    struct S { unsigned char value = I; };
    S&lt;300&gt; s;           // warning 3423, cannot narrow 300 to unsigned char</c>
    </m>
    <m id="3424">
        <c>A function marked as constexpr must contain at least one code path that
produces a constant expression to be used in a context where a constant
expression is required. The specified function was marked as constexpr
but does not ever produce a constant expression so the use of constexpr
is suspect.</c>
    </m>
    <m id="3425">
        <c>Inside an initializer list, a prohibited implicit narrowing conversion
would be required to perform the initialization. The prohibited implicit
conversion is one that is never allowed in list initialization. For
example:

    int i = { 3.0 };

will elicit this message because conversion from a floating point type
to a integral type is required to perform the initialization but is not
an allowed implicit conversion within an initializer list. The issue can
be corrected by correcting the type used in the initializer, casting the
type, or not using list initialization.</c>
    </m>
    <m id="3426">
        <c>Inside an initializer list, a prohibited implicit narrowing conversion
would be required to perform the initialization. The implicit conversion
is of a type that is allowed for constant expressions but not for the
provided expression. For example:

    extern int i;
    float f = { i; };

will elicit this message while:

    float f = { 3 };

will not. The issue can be corrected by correcting the type used in the
initializer, casting the type, or not using list initialization.</c>
    </m>
    <m id="3427">
        <c>Inside an initializer list there is an implicit conversion of a constant
expression to a type where the value cannot be represented exactly,
which is prohibited. For example:

    unsigned char c = { 1234 };

will elicit this message, assuming 8-bit chars. The message can be
avoided by correcting the value, using a cast, or by not employing list
initialization.</c>
    </m>
    <m id="3428">
        <c>A class member that is declared out-of-line (outside of the class
declaration) must have a definition. For example:

    class A {
        void foo();
    }

    void A::foo();

The second declaration of A::foo must contain a definition.</c>
    </m>
    <m id="3429">
        <c>In C++11, an array member can be initialized in a member initialization
list using extended initializer syntax, e.g.:

    class A {
        A() : array { 0 } { };
        int array[10];
    }

A deprecated GNU extension allowed an array member to be initialized
using the syntax for initializing class types:

    A() : array({ 0 });

This parenthesis around the initializer here are not Standard.</c>
    </m>
    <m id="3430">
        <c>An attempt was made to take the address of a temporary object. For
example:

    struct X { ... };

    void foo() {
        &amp;X();       // warning 3430
    }</c>
    </m>
    <m id="3431">
        <c>A const static data member of integral type may be initialized in its
in-class declaration with a constant expression. For non-integral types,
the member must be declared with constexpr, e.g.:

    struct A {
        const static int i = 3;
        constexpr static float f = 3.0;
    };

This message is issued for non-integral static data members with an
in-class initializer of a type for which constexpr is expected but not
provided.</c>
    </m>
    <m id="3432">
        <c>A literal appeared adjacent to an identifier but there was no space
separating the two and the identifier was not a valid suffix for the
literal.</c>
    </m>
    <m id="3450">
        <c>The integral or pointer value of a member of this, accessed implicitly
through the current object, was subtracted from the this pointer. This
is almost certainly a mistake where the &gt; in -&gt; was forgotten.
For example:

    struct X {
        bool value;
        bool getValue() const {
            return this-value; // intended to be this-&gt;value
        }
    };

If for some reason explicitly applying a negative offset to the this
pointer based on a member value is actually desired then the member name
can be enclosed in parentheses to avoid confusion.</c>
    </m>
    <m id="3701">
        <c>A push, push_back, or insert function is called in a situation where
emplace_back or emplace could be used instead.</c>
    </m>
    <m id="3702">
        <c>The this pointer was implicitly captured due to a member access inside a
lambda. For clarity, some prefer to explicitly specify this in the
capture list.</c>
    </m>
    <m id="3703">
        <c>An ellipsis was encountered, which was probably intended to declare a
function parameter pack but instead declares a variable argument
function. For example:

    template &lt;typename... T&gt;
    void foo() {
        bar([] {
            void g(T t...);     // warning 3703, probably meant g(T... t);
        }...);
    }</c>
    </m>
    <m id="3704">
        <c>A set of empty parenthesis were added to what would otherwise be
interpreted as a variable declaration but instead results in the
declaration of a function. For example:

    struct S {
        S(int a = 0) : _a(a) { }
        int _a;
    };

    void foo() {
        S s1(1);     // OK, declares and initializes variable s1
        S s2();      // warning 3704, declares a function s2
    }

s2 is interpreted as a function that returns type S and takes not
arguments, not a zero-initialized variable as presumably intended.
There are multiple ways to force interpretation of a variable, e.g.:

    S s3(0);    // OK
    S s4 = S(); // OK, initialize via temporary
    S s5{};     // OK, C++11 uniform initialization

See also message 3705.</c>
    </m>
    <m id="3705">
        <c>A syntactic construct was encountered that could be interpreted as
either a variable declaration or a function declaration (sometimes
referred to as the &quot;most vexing parse&quot;). The C++ disambiguation rules
require that it be interpreted as a function declaration, which may not
be what the programmer intended. For example:

    struct X { };
    struct Y {
        Y(const X&amp;);
    };

    void foo() {
        Y y(X());   // warning 3705
    }

Here y is interpreted as a function that returns an object of type Y and
takes a single parameter that is a pointer to a function taking no
arguments and returning type X. In particular, it is not interpreted as
a declaration of an object of type Y initialized with a temporary of
type X as was almost certainly intended.
There are several ways to force interpretation of a variable
declaration. In C++11 and later the simplest way is to employ uniform
initialization syntax, for example any of the following would work:

    Y y1(X{});    // OK, variable declaration
    Y y2{X()};    // OK, variable declaration
    Y y3{X{}};    // OK, variable declaration

Prior to C++11, an extra pair of parenthesis can be used to force the
desired interpretation, e.g.:

    Y y4((X()));   // OK, variable declaration

The same issue can appear with casts, for example:

    void foo(double d) {
        int i( int(d) );    // warning 3705
    }

In this case, i is not a variable initialized with the truncated value
of d but rather a function returning int and taking int. In addition to
the methods mentioned above to force a variable declaration, the
functional cast can be converted to a C-style cast or a named cast,
e.g.:

    int i1( (int) d );              // OK, variable declaration
    int i2( static_cast&lt;int&gt;(d) );  // OK, variable declaration</c>
    </m>
    <m id="3706">
        <c>An abstract class (one that contains at least one pure virtual
specifier) was marked as final or sealed preventing the class from being
used as a base class. Since abstract classes cannot be instantiated,
what would be the purpose of having abstract class that cannot be
inherited from?</c>
    </m>
    <m id="3707">
        <c>C++ defines the language linkage specifiers C and C++. Other specifiers
may be supported by compilers as an extension with
implementation-defined semantics. This message is issued when a language
linkage specifier other than C or C++ is encountered. For example:

    extern &quot;C&quot; int a;       // Okay
    extern &quot;C++&quot; int b;     // Okay
    extern &quot;ADA&quot; int c;     // Info 3707</c>
    </m>
    <m id="3901">
        <c>A non-static data member or function was referenced inside of the
containing class with an implicit this object instead of using
this-&gt;member to access the member. For example:

    struct A {
        int value;
        int getValue() { return this-&gt;value; }  // OK, explicit this-&gt;
        void setValue(int v) { value = v; }     // note 3901
    };

Some authors suggest always using this-&gt; to access members to prevent
the potential for confusion when local objects or functions with the
same name as a member exist in the same scope. See also message 578,
which will be issued if a local symbol is declared that hides a member.</c>
    </m>
    <m id="3902">
        <c>This message is issued where a throw-expression initializes an exception
object that is not derived from std::exception. The point is to have a
type that can be caught by

    catch(std::exception &amp; p)

instead of

    catch(...)

This way, in a situation where it&apos;s necessary to catch everything,
information about the kind of error can at least be logged or
translated.</c>
    </m>
    <m id="8000">
        <c>Messages in the 8xxx range are reserved for user-defined diagnostics,
see +message for more information.</c>
    </m>
    <m id="9001">
        <c>An octal constant appears in the code. Octal constants may be
inadvertently interpreted by engineers as decimal values. This message
is not issued for a constant zero written as a single digit.</c>
    </m>
    <m id="9003">
        <c>A variable was declared at global scope but only utilized within one
function. Moving the declaration of this variable to that function
reduces the chance the variable will be used incorrectly.</c>
    </m>
    <m id="9004">
        <c>The named symbol was declared in multiple locations, not counting the
point of definition for that symbol. Declaring a symbol in one location
and in one file helps to ensure consistency between declaration and
definition as well as avoiding the risk of conflicting definitions
across modules.</c>
    </m>
    <m id="9005">
        <c>A cast attempted to remove the qualifiers from an object to which a
pointer points or a reference refers. Doing so can result in undesired
or unexpected modification of the object in question and may result in
an exception being thrown.</c>
    </m>
    <m id="9006">
        <c>If the operand of the sizeof operator is an expression, it is not
usually evaluated. Attempting to apply sizeof to such an expression can
result, therefore, in code one expects to be evaluated actually not
being evaluated and the side-effects not taking place. This message is
not given if the operand is an lvalue of volatile qualified type and is
not a variably-lengthed array.</c>
    </m>
    <m id="9007">
        <c>The right hand side of the || and &amp;&amp; operators is only evaluated if the
left hand side evaluates to a certain value. Consequently, code that
expects the right hand side to be evaluated regardless of the left hand
side can produce unanticipated results.</c>
    </m>
    <m id="9008">
        <c>The comma operator is thought by some to reduce readability in code.</c>
    </m>
    <m id="9009">
        <c>The use of floating point variables as loop counters can produce
surprising behavior if the accumulation of rounding errors results in a
different number of iterations than anticipated.</c>
    </m>
    <m id="9010">
        <c>An expression of integral type (other than a null pointer constant) was
converted to a pointer type (other than void*).</c>
    </m>
    <m id="9011">
        <c>More than one break statement or goto statement is used to terminate a
loop. Minimizing the number of exits from a loop is thought by some to
reduce visual complexity of the code.</c>
    </m>
    <m id="9012">
        <c>Multiple authors have advised making sure the body of every
iteration-statement and selection-statement be a compound-statement.
However, no { was seen to begin the compound-statement.</c>
    </m>
    <m id="9013">
        <c>An if...else if chain was seen without a final else statement. Providing
such a statement helps to act as an analog to the default case of a
switch-statement.</c>
    </m>
    <m id="9014">
        <c>A switch-statement was found without a default case. Providing such a
case provides defensive programming.</c>
    </m>
    <m id="9015">
        <c>In the expansion of a function-like macro, a macro argument was used
both as an operand to the stringizing or pasting operators and was also
used in a way in which it was subject to further macro replacement. For
example:

    #define M1 123
    #define FM(x) ident_ ## x + x
    ...
    FM(10);     // Okay, 10 is not a macro
    FM(M1);     // 9015, M1 both expanded and used with ##

The FM macro uses the parameter x as an operand to the token pasting
operator (where a macro argument would not be expanded) and in a context
where a macro argument would be expanded. This example expands to:

    ident_10 + 10;
    ident_M1 + 123;

In the second invocation, part of the expansion contains the unexpanded
macro and another contains the result of the expanded macro argument.
This may be confusing and lead to unexpected results.</c>
    </m>
    <m id="9016">
        <c>Array indexing is thought, by some, to be more readily understood and
less error prone than other forms of pointer arithmetic.</c>
    </m>
    <m id="9017">
        <c>While at least one standards organization cautions against using any
pointer arithmetic besides array indexing, the use of increment or
decrement operators with pointers may represent an intuitive application
and illustration of the underlying logic. Consequently, such constructs
are separated from message 9016 and placed under this one, allowing a
more fine tuning of Lint diagnostics.</c>
    </m>
    <m id="9018">
        <c>Depending upon padding, alignment, and endianness of union, as well as
the size and bit-order of their members, the use of unions can result in
unspecified, undefined, or implementation defined behavior, prompting
some to advise against their use.</c>
    </m>
    <m id="9019">
        <c>The symbol mentioned in string was seen in a module with a subsequent
#include directive. It can be argued that collecting all #include
directives at the beginning of the module helps improve code readability
and helps reduce risk of undefined behavior resulting from any use of
the ISO standard library before the relevant #include directive.</c>
    </m>
    <m id="9020">
        <c>The use of non-standard characters in #include directives results in
undefined behavior.</c>
    </m>
    <m id="9021">
        <c>The use of the #undef directive can lead to confusion about whether or
not a particular macro exists at a randomly given point of code.</c>
    </m>
    <m id="9022">
        <c>Multiple authors have cautioned against the use of unparenthesized macro
parameters in cases where the parameter is used as an expression. If
care is not taken, unparenthesized macro parameters can result in
operator precedence rules producing expressions other than intended.</c>
    </m>
    <m id="9023">
        <c>Multiple use of such operators is thought by some to increase risk of
undefined behavior.</c>
    </m>
    <m id="9024">
        <c>The use of token pasting (##) and stringizing (#) preprocessor operators
is thought by some to reduce code clarity and increase the risk of
undefined behavior.</c>
    </m>
    <m id="9025">
        <c>Three or more levels of pointer indirection may make it harder to
understand the code.</c>
    </m>
    <m id="9026">
        <c>Multiple authors have expressed reasons why a function, when possible,
should be used in place of a function-like macro.</c>
    </m>
    <m id="9027">
        <c>Out of concern for unspecified, undefined, and/or implementation defined
behavior, some standards urge restrictions on certain types of operands
when used with certain operators.</c>
    </m>
    <m id="9028">
        <c>MISRA C 2012 has defined the concept of essentially character type and
placed restrictions on the use of expressions with such a type.</c>
    </m>
    <m id="9029">
        <c>MISRA C 2012 has defined the concept of essentially type and placed
restrictions on the use of expressions with certain types with respect
to binary operators.</c>
    </m>
    <m id="9030">
        <c>MISRA C 2012 has defined the concept of essential type and placed
restrictions on the use of casts between certain types.</c>
    </m>
    <m id="9031">
        <c>MISRA C 2012 has defined the concepts of composite expression and
essential type and placed restrictions on assignments of the former.</c>
    </m>
    <m id="9032">
        <c>MISRA C 2012 has defined the concepts of composite expression and
essential type and placed restrictions on operands to binary operators
when at least one of the operands meets the definition of the former
concept.</c>
    </m>
    <m id="9033">
        <c>MISRA C 2012 has defined the concepts of composite expression and
essential type and placed restrictions on casts of the former. This
message, when given, is also followed by text explaining why the cast is
considered &quot;impermissible&quot;.</c>
    </m>
    <m id="9034">
        <c>MISRA C 2012 has defined the concept of essential type and placed
restrictions on assignments in relation to such types.</c>
    </m>
    <m id="9035">
        <c>Variable length arrays can introduce unspecified behavior and
runtime-dependent undefined behavior. As of C11 it is not required that
implementations support this feature. For these reasons, the use of VLAs
is often discouraged.</c>
    </m>
    <m id="9036">
        <c>MISRA C 2012 has defined the concept of essentially Boolean type and
requires the conditional expressions of all if and iteration-statements
comply with this definition.</c>
    </m>
    <m id="9037">
        <c>Some urge such a practice in the interest of strong typing.</c>
    </m>
    <m id="9038">
        <c>Flexible array members can alter the behavior of sizeof in surprising
ways. Additionally, flexible array members often require dynamic memory
allocation, which may be problematic in safety critical code.</c>
    </m>
    <m id="9039">
        <c>An octal or hexadecimal escape sequence has been detected within a
string or character literal that is not immediately followed by another
escape sequence or end of literal.</c>
    </m>
    <m id="9040">
        <c>Prior to C99 adding flexible array members, the now obsolete struct hack
technique was widely used to create structures who&apos;s last member was an
array with variable length. In addition, some compilers also allowed
this technique to create variable length array members within unions.
The technique required the variable length member array(s) to be
declared with a size of either 0 or 1 within the declaration of the
structure or union.

    struct S {
      int a;
      int b[0];     // warning 9040
    };

    union U {
      int    a;
      short  b[1];  // warning 9040
      char   c[1];  // warning 9040
      double d;
    };</c>
    </m>
    <m id="9041">
        <c>It has been deemed safer by some experts that the block (i.e., compound
statement) containing the goto should be the same as or nested within
the block containing the label. Thus

    { label: { goto label; } }

is permitted but

    {  goto label;  {  label: ; }  }

is not. To assist the programmer, the message refers in the blocks using
an identification code (e.g. &quot;1.2.1&quot;). This identification scheme is
defined as follows:

1.  The outer block has an identification of 1.

2.  If a particular block is identified by x then its immediate
    subblocks, if any, are identified as x.1, x.2, x.3, etc.

Thus in the following &apos;code&apos;,

    { { } {{label: } { } } }

label lies in block 1.2.1.</c>
    </m>
    <m id="9042">
        <c>A switch-statement was found that does not comply with the MISRA
switch-statement syntax. detail contains a description of the departure.</c>
    </m>
    <m id="9043">
        <c>Some advocate against using the keyword static in array declarations due
to a perceived increased risk of undefined behavior.</c>
    </m>
    <m id="9044">
        <c>It has been advocated that function parameters be first copied to local
variables where they can be modified rather than modifying the
parameters directly.</c>
    </m>
    <m id="9045">
        <c>Some advise against including structure definitions unless the
definition is required for the current module.</c>
    </m>
    <m id="9046">
        <c>Some have warned against the use of identifiers that may be considered
typographically ambiguous. In addition to the name of the previously
seen symbol, the reasons Lint considers the identifiers to be ambiguous
and the location of said previous symbol are provided in the message, if
available.</c>
    </m>
    <m id="9047">
        <c>At least one standards organization urges against this practice,
directly or indirectly.</c>
    </m>
    <m id="9048">
        <c>An integer literal of unsigned type was found without a &apos;U&apos; suffix.</c>
    </m>
    <m id="9049">
        <c>An expression was seen involving an increment or decrement operator and
the expression also contained potential side-effects other than those
resulting from said operator. For the purpose of this message, a
function call is always considered to have potential side-effects.</c>
    </m>
    <m id="9050">
        <c>Reliance on operator precedence was found in a particular expression.
Using parentheses, it is felt, helps clarify the order of evaluation.</c>
    </m>
    <m id="9051">
        <c>A macro was defined with the same name as an ISO C keyword. The use of
such a macro causes undefined behavior.</c>
    </m>
    <m id="9052">
        <c>A macro was defined with the same name as an ISO C++ keyword. The use of
such a macro causes undefined behavior.</c>
    </m>
    <m id="9053">
        <c>MISRA 2012 defines the notion of an &quot;essential type&quot;. A quantity with a
certain essential type, as defined by MISRA, was left shifted by a
number exceeding the number of bits used to represent that essential
type.</c>
    </m>
    <m id="9054">
        <c>It has been advocated, when arrays initializers contain designators, the
dimension of the array should be explicitly stated in the declaration.
The initializer of the array in question has been found in violation of
this recommendation.</c>
    </m>
    <m id="9055">
        <c>Labels nested inside of compound statements within the corresponding
switch are legal but can reduce comprehension and lead to unstructured
code.</c>
    </m>
    <m id="9056">
        <c>This message is issued for all inline functions defined with a
storage-class specifier. +estring can be used to find all inline
functions defined with a specific specifier. For example,
+estring(9056, extern) will report all inline functions defined with
extern.</c>
    </m>
    <m id="9057">
        <c>A lowercase letter &quot;l&quot; is used inside of a literal suffix following an
upper or lowercase letter u. With some fonts, the lowercase letter &quot;l&quot;
can be easily confused with the number one. This is less likely to
happen when there is a &quot;u&quot; between the number and the &quot;l&quot; (as in 35ul),
but some coding standards forbid the use of &quot;l&quot; in any literals. Message
620 reports the more suspicious case where the &quot;l&quot; immediately follows a
number (as in 35l).</c>
    </m>
    <m id="9058">
        <c>A tag was used only in the course of creating a typedef. Was the tag
unused by mistake (say a recursive reference inside the body of the
struct was accidentally omitted)? Such tags are most often redundant and
can be eliminated.</c>
    </m>
    <m id="9059">
        <c>A C++-style comment was seen inside a C-style comment. This can be
confusing.</c>
    </m>
    <m id="9060">
        <c>A trigraph was seen inside a comment. Since trigraphs are translated
before preprocessing, a trigraph sequence like ??/ can have surprising
results, especially in a C++ style comment where the trigraph sequence
translates into a backslash.</c>
    </m>
    <m id="9063">
        <c>An else-branch was seen that contained neither a comment nor an
actionable statement. At least one standards organization cautions
against such &quot;empty else&quot; branches.</c>
    </m>
    <m id="9064">
        <c>A goto makes reference to a label appearing earlier in the code. At
least one author recommends all such statements reference points later
in the code in an attempt to reduce visual code complexity.</c>
    </m>
    <m id="9066">
        <c>A C-style comment was seen inside a C++-style comment. This can result
in confusion.</c>
    </m>
    <m id="9067">
        <c>An array was declared without a dimension. At least one standards
organization advises against such a practice in the interest of safety.
Note this message is not given if the array is initialized at the time
of declaration.</c>
    </m>
    <m id="9068">
        <c>An array has been initialized only partly. Providing an explicit
initialization for each element of an array makes it clear every element
has been considered. This diagnostic is not issued if the array is
initialized with a {0} initializer or if the initializer consists
entirely of designated initializers or if the array is initialized using
a string literal. See also 785.</c>
    </m>
    <m id="9069">
        <c>In the initializer for a variable declared with aggregate (array or
structure) or union type, there were insufficient braces or designators
necessary to make clear which members/elements are initialized to which
values. More specifically, the initializer is expected to be fully
braced, e.g. with braces appearing at the beginning of every aggregate
sub-object being explicitly initialized, with the following exceptions:

-   If all of the initializers for a particular sub-object are
    designated initializers, braces are not required for that
    sub-object.

-   String literals may be used to initialize arrays.

-   An aggregate sub-object may be initialized with an object of
    compatible type.

-   The idiomatic { 0 } may be used to initialize sub-objects to an
    arbitrary depth without providing nested braces.

For example:

    enum wk_type { FIRE, ICE };

    struct monster {
        const char name[10];
        int hp;
        struct weakness {
            enum wk_type wk;
            double dmg_mult;
        } weak[2];
    };

    // Okay - all initialized sub-objects are braced, array &apos;name&apos; initialized with string literal
    struct monster goblin1 = {&quot;goblin&quot;, 10, {{ICE, 2.0}, {FIRE, 1.5}}};

    // 9069 - the second element of the &apos;weak&apos; array is not braced
    struct monster goblin2 = {&quot;goblin&quot;, 10, {{ICE, 2.0}, FIRE, 1.5}};

    // Okay - only initialized part of non-braced sub-object uses designated initializer
    struct monster goblin3 = {&quot;goblin&quot;, 20, .weak[0].wk = FIRE};

    // 9069 - &apos;1&apos; initializes part of sub-object that is not braced
    struct monster goblin4 = {&quot;goblin&quot;, 10, .weak[0].wk = FIRE, 1};

    // 9069 - initialized sub-object &apos;struct weakness [0]&apos; needs additional braces
    struct monster goblin5 = {&quot;goblin&quot;, 40, {1}};

    // Okay - exception for sub-objects initialized with { 0 }
    struct monster goblin6 = {&quot;goblin&quot;, 40, {0}};</c>
    </m>
    <m id="9070">
        <c>The named function has been found to potentially call itself, either
directly or indirectly. Recursion carries with it the danger of
exceeding available stack space, which can lead to a run-time failure.
All else being equal, the more that recursion is constrained, the easier
determining the worst-case stack usage can be.</c>
    </m>
    <m id="9071">
        <c>A macro was defined that is reserved to the compiler. Such definition
results in undefined behavior.</c>
    </m>
    <m id="9072">
        <c>The parameter of function symbol specified by integer has a parameter
name that differs from the name of a previous declaration of the same
function. Using inconsistent names within declarations of the same
function can be confusing and result in misuse.</c>
    </m>
    <m id="9073">
        <c>In a function declaration or definition, the specified parameter is
declared with a type that, while technically identical, uses a different
name for the type than was used for the parameter in a previous
declaration. For example:

    typedef int INT;
    void foo(int i);
    void foo(INT i) {
        ...
    }

would yield this message as the parameter i in function foo is declared
as an int in both cases but in the definition the typedef name INT is
used while in the preceding declaration the name INT is not employed.
Such inconsistencies can result in unnecessary confusion.</c>
    </m>
    <m id="9074">
        <c>A conversion was seen between a pointer to function and a different
type. The conversion of a pointer to a function into or from a pointer
to object, pointer to incomplete type, or pointer to void results in
undefined behavior and, consequently, at least one standards
organization advises against such practice. This diagnostic is
suppressed if the conversion is to void.</c>
    </m>
    <m id="9075">
        <c>If a declaration for an object is visible when that object is defined, a
compiler must verify that the declaration and definition are compatible.
A lack of prior declaration prevents such checking.</c>
    </m>
    <m id="9076">
        <c>A conversion between two distinct types involved a pointer to an
incomplete type. The resulting pointer may be improperly aligned and the
result of interpreting the target memory using a different type may be a
trap representation. Conversions to void and conversions to or from a
pointer to void will not be reported.</c>
    </m>
    <m id="9077">
        <c>A case at the end of a switch had no unconditional break. Some coding
guidelines require the use of a break for every switch case, including
the last one, for maintenance reasons. Note that this message is issued
even if the case contains an unconditional return statement.</c>
    </m>
    <m id="9078">
        <c>A conversion between a pointer type and an integer/enum type was seen.
Such conversions can result in undefined behavior if the pointer value
cannot be represented in the integer/enum type. This diagnostic is not
given for null pointer constants.</c>
    </m>
    <m id="9079">
        <c>Conversion of a pointer to void into a pointer to object may result in a
pointer that is not correctly aligned, resulting in undefined behavior.</c>
    </m>
    <m id="9080">
        <c>An integer null pointer constant other than the NULL macro was used.
Using the NULL macro makes it clear a null pointer constant was
intended.</c>
    </m>
    <m id="9081">
        <c>A switch was seen with fewer than two non-consecutive case labels. A
switch with fewer than two such cases is redundant and may indicate a
programming error. See also message 9181.</c>
    </m>
    <m id="9082">
        <c>Placing the default label either first or last makes locating it easier.</c>
    </m>
    <m id="9083">
        <c>A #undef was seen applied to an identifier given by name and that
identifier is reserved to the compiler by the ISO C/C++ standards.</c>
    </m>
    <m id="9084">
        <c>An assignment expression was seen inside a larger expression. The use of
assignment operators, simple or compound, in combination with other
arithmetic operations can significantly impair the readability of the
code.</c>
    </m>
    <m id="9085">
        <c>A default label was seen without a comment or statement between it and
either the corresponding break or, if default is the last case in the
switch, the closing }. Adding a statement to take action or adding a
comment to explain why no action is taken is a form of defensive
programming.</c>
    </m>
    <m id="9087">
        <c>A cast was seen between two pointer types that differ with respect to
what those types point to. Additionally, the type to which the
expression was cast is not a pointer to char, whether signed or
unsigned. At least one standards organization has cautioned against such
a practice.</c>
    </m>
    <m id="9088">
        <c>A named bit-field was declared with a signed data type and only one bit
of width. According to the ISO C Standard, a single-bit signed bit-field
has one sign bit and no value bits and, consequently does not specify a
meaningful value.</c>
    </m>
    <m id="9090">
        <c>A switch case was seen that did not conclude with an unconditional
break. Some authors advise against such absences on the grounds they are
often errors.</c>
    </m>
    <m id="9091">
        <c>A cast of a pointer to an integer type was seen. Since the size of the
integer required when a pointer is converted to an integer is
implementation defined, some coding guidelines advise against such
casts.</c>
    </m>
    <m id="9093">
        <c>A symbol was declared with a name reserved to the compiler.</c>
    </m>
    <m id="9094">
        <c>This message is similar to 9073 (which deals with parameter types) but
applies to return types. In a declaration of a function, the return type
specified, while technically identical, uses a different type name than
was used for a previous declaration. For example:

    typedef int INT;
    int foo(void);
    INT foo(void) {
        ...
    }

will yield this message.</c>
    </m>
    <m id="9095">
        <c>A symbol was defined with the same name as a macro that was defined
earlier in the same translation unit. For example:

    #define sum(x, y) ((x)+(y))
    int sum = 0;

will produce:

    note 9095: symbol &apos;sum&apos; has same name as previously defined macro

A supplemental message (891) provides the location of the offending
macro definition. Note that the message is issued regardless of whether
the macro definition is active at the point in which the symbol is
declared. For example:

    #define A
    #undef A
    int A = 0;

will elicit the same complaint for the declaration of A.</c>
    </m>
    <m id="9096">
        <c>This message is similar to 9095 but is issued for symbols defined with
the same name as a macro whose definition appears after the declaration
of the symbol. For example:

    int A;
    #define A 10

Unlike message 652, this message will be issued even if the macro is
defined outside the scope of the symbol. For example:

    void foo(int x) { }
    #define x 10

will not result in a 652 warning since the definition of the x macro is
outside the scope of the function parameter but 9096 will still be
issued.
A supplemental message (891) provides the location of the offending
macro definition.</c>
    </m>
    <m id="9097">
        <c>An unparenthesized expression was used as the argument to the sizeof
operator. While legal, it can result in confusion when used within a
larger expression, e.g.:

    size = sizeof x + y;

was this meant to be sizeof(x) + y or sizeof(x + y)? Using parenthesis
can eliminate such questions.</c>
    </m>
    <m id="9098">
        <c>The first or second argument to memcmp (or a function with semantics
copied from memcmp) was not either 1) a pointer to a pointer or 2) a
pointer to a MISRA C 2012 essentially signed, unsigned, boolean, or enum
type.</c>
    </m>
    <m id="9102">
        <c>A possible digraph was seen. At least one set of coding guidelines
advises against such due to the risk of failure to meet developer
expectations.</c>
    </m>
    <m id="9103">
        <c>An identifier of the given name was seen declared static in one location
and not static in another. Some coding guidelines advise against such
practice due to the potential for programmer confusion.</c>
    </m>
    <m id="9104">
        <c>Octal escape sequences can be problematic because the inadvertent
introduction of a decimal digit (i.e. 8 or 9) ends the octal escape and
introduces another character. This diagnostic is not given for \0.</c>
    </m>
    <m id="9105">
        <c>The inclusion of such a suffix makes clear the value has unsigned type.</c>
    </m>
    <m id="9106">
        <c>Using upper case literal suffixes removes the potential for ambiguity
with respect to literal values.</c>
    </m>
    <m id="9107">
        <c>One set of guidelines advises the use of headers in such a way as to
avoid the definition of objects or functions that occupy storage.</c>
    </m>
    <m id="9108">
        <c>A function was declared within the body of another function. The inner
declaration will be associated with a definition in the scope enclosing
the outer function for linking purposes but the name will be meaningful
only within the body of the enclosing function unless re-declared
elsewhere.
If a block scope declaration occurs within a namespace in C++ then
message 1798 will also be issued to highlight the heightened danger of
confusion.</c>
    </m>
    <m id="9110">
        <c>The under lying bit representation of floating point values can differ
from compiler to compiler, making reliance upon such representation
non-portable.</c>
    </m>
    <m id="9111">
        <c>The use of expressions of bool with certain operators, such as the
bitwise operators, is not likely to be either meaningful or intended.</c>
    </m>
    <m id="9112">
        <c>With the exception of the sequence of character values representing 0
thru 9, the exact value of any other particular character is not
guaranteed and reliance upon such an order is non-portable.</c>
    </m>
    <m id="9113">
        <c>The use of parentheses instead of relying upon operator precedence can
help make the code easier to understand.</c>
    </m>
    <m id="9114">
        <c>A prominent coding standard has defined the notion of a cvalue
expression and, to help ensure operations in a given expression are
performed within a particular fashion, the guidelines caution against
such a value undergoing implicit conversions.</c>
    </m>
    <m id="9115">
        <c>Such conversions between these two types of values can result in inexact
representation.</c>
    </m>
    <m id="9116">
        <c>A prominent coding standard has defined the notion of a cvalue
expression and, to help ensure operations in a given expression are
performed within a particular fashion, the guidelines caution against
such a value undergoing implicit conversions.</c>
    </m>
    <m id="9117">
        <c>Some such conversions can lead to implementation defined behavior.
Reliance upon such behavior is, therefore, not portable.</c>
    </m>
    <m id="9118">
        <c>Such conversions between these two types of values can result in
undefined behavior.</c>
    </m>
    <m id="9119">
        <c>A conversion was performed from an integer to a type that has a smaller
MISRA C++ underlying type.</c>
    </m>
    <m id="9120">
        <c>A conversion was performed from a floating point type to a type that has
a smaller MISRA C++ underlying type.</c>
    </m>
    <m id="9121">
        <c>A cast was used to convert a MISRA C++ cvalue expression from an
integral to floating point type.</c>
    </m>
    <m id="9122">
        <c>A cast was used to convert a MISRA C++ cvalue expression from a floating
point to integral type.</c>
    </m>
    <m id="9123">
        <c>A cast was used to convert a MISRA C++ cvalue expression of integral
type to a type with a larger underlying type.</c>
    </m>
    <m id="9124">
        <c>A cast was used to convert a MISRA C++ cvalue expression of floating
point type to a type with a larger underlying type.</c>
    </m>
    <m id="9125">
        <c>A cast was used to convert a MISRA C++ cvalue expression of integral
type to an underlying type with a different signedness.</c>
    </m>
    <m id="9126">
        <c>The ~ or &lt;&lt; operator was applied to an operand with a MISRA C++
underlying type of unsigned char or unsigned short but the result was
not cast to the appropriate underlying type.</c>
    </m>
    <m id="9128">
        <c>A prominent standard urges, since whether plain char is signed or
unsigned is implementation defined, the char type not be mixed with
other types.</c>
    </m>
    <m id="9130">
        <c>The specified bitwise operator was applied to an operand with a signed
MISRA C++ underlying type.</c>
    </m>
    <m id="9131">
        <c>Using only postfix-expressions with logical operators helps to improve
readability of the code. Note this message is not given if the
expression consists of either a sequence of only logical &amp;&amp; or a
sequence of only logical ||.</c>
    </m>
    <m id="9132">
        <c>Array-to-pointer decay results in a loss of array bound information. A
function depending upon an array to have a certain length, if that array
decays to a pointer, can result in out-of-bounds operations, depending
upon whether or not the bound of the original array matches with
expectations.</c>
    </m>
    <m id="9133">
        <c>The use of non-bool operands with !, &amp;&amp;, or || is unlikely to be
meaningful or intended. A more likely scenario is the programmer meant
to use such an operand with one of the bitwise operators.</c>
    </m>
    <m id="9134">
        <c>A unary minus was applied to an expression with an unsigned MISRA C++
underlying type.</c>
    </m>
    <m id="9135">
        <c>The unary operator &amp; was overloaded.</c>
    </m>
    <m id="9136">
        <c>The value specified for the right hand side of a shift operator was out
of bounds for the MISRA C++ underlying type on the left hand side of the
operator.</c>
    </m>
    <m id="9137">
        <c>A floating point value was tested, directly or indirectly, for
(in)equality with another value.</c>
    </m>
    <m id="9138">
        <c>A null statement was encountered that, before preprocessing, did not
appear on a line by itself. Comments following the null statement are
allowed as long as there is whitespace separating the null statement
from the comment.</c>
    </m>
    <m id="9139">
        <c>A case label was encountered following the default label of a switch
statement.</c>
    </m>
    <m id="9141">
        <c>The specified symbol was declared in the global namespace.</c>
    </m>
    <m id="9142">
        <c>A function with the name &apos;main&apos; was declared that was not the global
main function.</c>
    </m>
    <m id="9144">
        <c>A using directive was encountered.</c>
    </m>
    <m id="9145">
        <c>A using directive or using declaration was encountered in a header file.
This message is not issued for using declarations in class or function
scope.</c>
    </m>
    <m id="9146">
        <c>A declaration was encountered that contains multiple declarators. For
example:

    int i, j;

will elicit this message.</c>
    </m>
    <m id="9147">
        <c>The unadorned name of a function was encountered that was not part of a
function call.</c>
    </m>
    <m id="9148">
        <c>Unintentional duplication of enumerator values can occur when an
enumeration consists of members with explicit and implicit values.</c>
    </m>
    <m id="9149">
        <c>When using &apos;int&apos; or &apos;wchar_t&apos; as the bit-field type, it is
implementation defined whether or not the type used is a signed type.
Explicitly specifying &apos;signed&apos; or &apos;unsigned&apos; makes it clear what type
will be used as the underlying type.</c>
    </m>
    <m id="9150">
        <c>A member of a non-POD structure was declared public or protected.</c>
    </m>
    <m id="9151">
        <c>A public copy assignment operator was declared in an abstract class.</c>
    </m>
    <m id="9153">
        <c>In a context where a name resolves either to a non-template function or
to a specialization of a function template (typically a call), the set
of viable candidates included both.</c>
    </m>
    <m id="9154">
        <c>A pointer type was passed to a throw expression. It may not be clear who
is responsible for cleaning up the pointed to object.</c>
    </m>
    <m id="9156">
        <c>An empty throw expression was encountered outside of a try-catch block.
An empty throw re-throws the currently handled exception. If there is no
such exception std::terminate() will be called. This is likely to be
unintended.</c>
    </m>
    <m id="9158">
        <c>A macro was defined inside the braced region of the entity described by
string (such as function or class). Such usage could imply the belief
that the scope of the macro definition is limited to the braced region,
which is not the case.</c>
    </m>
    <m id="9159">
        <c>A macro was undefined inside the braced region of the entity described
by string (such as function or class). Such usage could imply the belief
that the scope of the directive is limited to the braced region, which
is not the case.</c>
    </m>
    <m id="9160">
        <c>Within a conditionally excluded region, a line that started with a # was
seen but was not part of a valid preprocessing directive. Error 16 is
produced if an unknown preprocessor directive appears in a non-excluded
region.</c>
    </m>
    <m id="9162">
        <c>Either a static_assert() or a using-declaration was seen at global
scope, as indicated by the string.</c>
    </m>
    <m id="9165">
        <c>The named function is defined to take a variable number of arguments. At
least one author advises against such a practice because doing so avoids
the type checking provided by the compiler.</c>
    </m>
    <m id="9167">
        <c>A macro was defined inside of a declaration of a function,
class/struct/union, namespace, or enumeration and was not undefined
within the braced region of that declaration. The macro will persist
beyond the end of the declaration, which may not be intended. For
example:

    void foo() {
    #define A ...

    }

will result in the message:
    macro &apos;A&apos; defined in function &apos;foo&apos; not undefined in same function</c>
    </m>
    <m id="9168">
        <c>A variable is declared in two places with types that, while technically
identical, have different alias names. For example:

    typedef int INT;
    extern int var;
    INT var;            // note 9168</c>
    </m>
    <m id="9169">
        <c>A constructor was found that could be used for implicit conversions from
a fundamental type. This message is similar to 1931 but only reports
instances where the implicit conversion is from a fundamental type (e.g.
integer and floating point types but not pointers, references, arrays,
classes, etc.). Like message 1931, if the constructor is declared with
the keyword explicit, this message will not be emitted. This message is
also not be emitted for variadic constructors.</c>
    </m>
    <m id="9170">
        <c>The specified function is declared as pure but overrides a non-pure
function in a base class. Was this a mistake?</c>
    </m>
    <m id="9171">
        <c>A cast was used to convert a pointer to a polymorphic type (a class that
contains or inherits one or more virtual functions) to a pointer to a
derived class.</c>
    </m>
    <m id="9172">
        <c>A bitwise operator was used whose operands did not have the same MISRA
C++ underlying type. This message is not produced if either operand is
an integer constant expression.</c>
    </m>
    <m id="9173">
        <c>The use of new or delete was encountered that will allocate or
deallocate dynamic memory. Placement new is not reported as it does not
allocate memory.</c>
    </m>
    <m id="9174">
        <c>A class derivation was marked as virtual; some coding standards prohibit
virtual inheritance due to the potential complexities involved.</c>
    </m>
    <m id="9175">
        <c>The specified function does not appear to have any external side-effects
and does not return any information so what is the purpose of calling
the function?</c>
    </m>
    <m id="9176">
        <c>A pointer was converted (implicitly or explicitly) to a different
pointer type and the source pointee type was not a class or structure
derived from the destination pointee type.</c>
    </m>
    <m id="9177">
        <c>The controlling expression of a do, for, if, or while statement had a
non-Boolean type before applying the contextual Boolean conversion that
occurs for the control statement. For example:

    void foo(int value) {
        if (value) { ... }          // Note 9177
        if ((bool)value) { ... }    // OK
        if (value != 0) { ... }     // OK
    }

As indicated in the above example, a cast to bool can be used to make
the intention explicit and suppress this message. 9177 is not issued if
the condition contains a variable declaration, e.g.:

    int bar();
    void foo() {
        if (int value = bar()) { ... }  // OK
    }

If a user-defined conversion operator is employed to perform implicit
Boolean conversion of the controlling expression, the message is issued
only if the corresponding conversion operator is not declared with the
explicit keyword. For example:

    struct X1 { operator bool(); };
    struct X2 { explicit operator bool(); };
    void foo(X1 x1, X2 x2) {
        if (x1) { ... }     // Note 9177
        if (x2) { ... }     // OK, explicit conversion operator
    }

The string parameter indicates the type of statement for which the
non-Boolean condition appeared and is one of &quot;do&quot;, &quot;for&quot;, &quot;if&quot;, or
&quot;while&quot;.</c>
    </m>
    <m id="9178">
        <c>The predicate of a conditional operator had a non-Boolean type before
applying the implicit Boolean conversion. For example:

    void foo(int value) {
        value ? x() : y();          // Note 9178
        (bool)value ? x() : y();    // OK
        (value != 0) ? x() : y();   // OK
    }

As indicated in the above example, a cast to bool will suppress this
message.
If a user-defined conversion operator is employed to perform implicit
Boolean conversion of the predicate, the message is issued only if the
corresponding conversion operator is not declared with the explicit
keyword.</c>
    </m>
    <m id="9181">
        <c>A switch was seen with fewer than two non-default cases. A switch with
fewer than two cases might be better expressed as an if statement. See
also message 9081.</c>
    </m>
    <m id="9183">
        <c>This message is issued when the const or volatile qualifiers appear
before a typedef or using name in a type specifier sequence. Placing
const or volatile before a typedef or using name can provide a false
impression of how the qualifier affects the type. For example:

    typedef int * INTPTR;
    volatile INTPTR counter1;  // Note 9183
    INTPTR volatile counter2;  // OK

The declaration of counter1 may lead to the incorrect impression that
its type is &quot;pointer to volatile int&quot; instead of its actual type of
&quot;volatile pointer to non-volatile int&quot;. Analogous issues exist for the
const qualifier. Placing the qualifier after the typedef name doesn&apos;t
change the semantic meaning but reduces the chance of misinterpreting
the impact of the qualifier. The string parameter is const or volatile
and the type parameter contains the typedef type that follows the
qualifier.</c>
    </m>
    <m id="9185">
        <c>A member assignment operator function was declared without an lvalue
reference qualifier, the presence of which would limit assignment to
lvalue objects. Allowing assignment to rvalue class objects can result
in subtle logic errors and may be confusing since assignment to rvalues
of fundamental types is not possible using built-in assignment
operators. Assignment operators include copy assignment, move
assignment, simple assignment, and compound assignment (e.g.
operator+=). A member function is declared with an lvalue reference
qualifier by adding &amp; after the function&apos;s parameter list. For example:

    class X {
        X&amp; operator+=(int);     // Message 9185
        X&amp; operator-=(int) &amp;;   // OK
    }</c>
    </m>
    <m id="9186">
        <c>An overloaded comparison operator function (one of operator&lt;,
operator&lt;=, operator&gt;, operator&gt;=, operator==, or operator!=) was
declared to return a non-dependent type other than bool. The built-in
versions of these operators that operate on fundamental types, as well
as the overloaded versions defined in the C++ Standard library, return
bool so declaring a comparison operator with a different return type
implies unconventional semantics which may be confusing.</c>
    </m>
    <m id="9187">
        <c>A non-const member function or member function template overloads the
subscript operator and there is no corresponding const version of the
function declared in the same class. It is sometimes advised that a
const version of the subscript operator be provided with a non-const
version. The corresponding const version is expected to have the same
parameter type, ref-qualifier, and volatile qualifier as the non-const
version. The implemented semantics of the subscript operator for some
classes, such as std::map (which adds the element referenced by the
subscript operator if it does not exist), may not lend itself to a const
version. The symbol parameter contains the offending function and can be
used to suppress the message on a case-by-case basis using the -esym
option. The option -esym(9187,std::*) can be used to suppress the
message for classes defined in the Standard C++ library.</c>
    </m>
    <m id="9204">
        <c>A hexadecimal escape sequence (\x) was used inside a character or string
literal.</c>
    </m>
    <m id="9209">
        <c>The plain char type is defined by the implementation to have the same
size and range as either signed char or unsigned char but is a separate
and distinct type. For this reason, it is often recommended that char be
used for character data and signed char and unsigned char be used for
numeric data. This message reports when an object of plain char type is
used as an operand to a unary operator or a binary operator other than
=, ==, and !=.</c>
    </m>
    <m id="9212">
        <c>A bit field was defined with a type other than signed int or
unsigned int or with a typedef that is defined using one of these two
explicit types. When using plain int as a bit-field type, the signedness
of the type used is implementation defined. Only int (signed and
unsigned) and _Bool (in C99) are sanctioned for use in bit-fields, use
of any other type results in implementation-defined behavior.
-etype(9212, _Bool) can be used to suppress this message for the C99
_Bool type. See also message 9149, which is similar but more lenient.</c>
    </m>
    <m id="9215">
        <c>This message is emitted when an unnamed function parameter is
encountered in the definition of a function.</c>
    </m>
    <m id="9224">
        <c>An expression that is not &quot;effectively boolean&quot; is being implicitly
tested for zero in the controlling expression of an if statement, an
iteration statement, or the first operand of a conditional operator. For
example, given that x is an integer:

    if (x)

will elicit this message while:

    if (x != 0)

will not. &quot;Effectively boolean&quot; value are produced by the operators ==,
!=, &lt;=, &gt;=, &lt;, &gt;, !, ||, and &amp;&amp;.</c>
    </m>
    <m id="9225">
        <c>An integral expression was implicitly converted from to a type that was
not a wider type of the same signedness.</c>
    </m>
    <m id="9226">
        <c>A complex integral expression was implicitly converted to a different
type or a non-constant integral expression was implicitly converted to a
different type while being passed to or returned from a function.
&quot;Complex&quot; here means an expression that is not an lvalue and is not a
function return value.</c>
    </m>
    <m id="9227">
        <c>A floating point expression was implicitly converted to a type that is
not a wider type.</c>
    </m>
    <m id="9228">
        <c>A floating point expression was implicitly converted to a different type
in a context in which a cast should be used to be compliant with MISRA C
2004. The context is provided in string, which is one of a
complex expression, a function argument, or a return value.</c>
    </m>
    <m id="9229">
        <c>A complex expression with integral type was cast to a type with
different signedness or whose underlying type is wider than the
underlying type of the expression.</c>
    </m>
    <m id="9230">
        <c>A complex expression with floating point type was cast to a type with
whose underlying type is wider than the underlying type of the
expression.</c>
    </m>
    <m id="9231">
        <c>The ~ or &lt;&lt; operator was applied to an operand with a MISRA C underlying
type of unsigned char or unsigned short but the result was not cast to
the appropriate underlying type.</c>
    </m>
    <m id="9232">
        <c>A MISRA C effectively boolean expression was used as an operand to an
operator that should not operate on such an expression or an operator
for which an effectively boolean expression was expected was not
provided one. Specifically, the operators &amp;&amp;, ||, and ! should contain
only effectively boolean operands and effectively boolean operands
should not be used with operators other than &amp;&amp;, ||, !, =, ==, !=, and
 ?:.</c>
    </m>
    <m id="9233">
        <c>An expression with a MISRA C signed underlying type was provided as an
operand to a bitwise operator.</c>
    </m>
    <m id="9234">
        <c>An expression was shifted by a negative amount or an amount greater than
the bit width of the expression&apos;s MISRA C underlying type.</c>
    </m>
    <m id="9235">
        <c>The unary minus operator was applied to an expression with an unsigned
MISRA C underlying type.</c>
    </m>
    <m id="9236">
        <c>An assignment operator was used within a boolean context, such as
comparing the result of assignment to a specific value.</c>
    </m>
    <m id="9237">
        <c>A conversion was performed between a pointer to function and a pointer
to a different type that was not a pointer to an integral type.</c>
    </m>
    <m id="9238">
        <c>The conditional expression of a switch statement has a MISRA C
effectively boolean type.</c>
    </m>
    <m id="9240">
        <c>This message is issued when the operands of the || and &amp;&amp; operators are
not primary-expressions.</c>
    </m>
    <m id="9252">
        <c>Message 777 is issued when an object with a floating point type is
tested for equality using either == or !=. Message 777 is not issued
when one of the operands is a value that can be represented exactly in
the corresponding floating point representation, such as 0 or 13.5. In
such cases, this message is issued instead.</c>
    </m>
    <m id="9254">
        <c>A continue statement was seen. Some coding guidelines forbid the use of
continue statements.</c>
    </m>
    <m id="9259">
        <c>Message 9059 reports on cases where a C comment contains what may be a
C++ comment, e.g. the sequence &apos;//&apos;. Because including URLs inside of
comments is a common practice, message 9059 is not issued when the &apos;//&apos;
sequence is immediately preceded by a &apos;:&apos; to prevent the message from
being issued in cases such as:

    /* See http://www.gimpel.com for details */

This message fills the gap by reporting on the instances not reported by
9059.</c>
    </m>
    <m id="9260">
        <c>A C++-style comment (//) was encountered. Such comments were not part of
C until C99 and may not be consistently supported by older compilers.</c>
    </m>
    <m id="9264">
        <c>The base of an array subscript operation was not declared as an array
(i.e., it was declared as a pointer). Some coding guidelines suggest
that array subscript operations should only be applied to array types.</c>
    </m>
    <m id="9272">
        <c>This message is similar to 9072 but applied to differences between
overridden functions. In the declaration of a function, the name given
to the specified parameter is different from the name given for the same
parameter in the declaration of one of the functions being overridden.
For example:

    struct A {
        virtual void foo(int width);
    };
    struct B : A {
        void foo(int depth);
    };

will yield this message because A::foo uses width as the name of the
first parameter while the overridden function B::foo uses the name
depth.</c>
    </m>
    <m id="9273">
        <c>This message is similar to 9073 but applies to differences between
overridden functions. In the declaration of a function, the specified
parameter is declared with a type that, while technically identical,
uses a different name for the type than was used for the parameter in
the declaration of one of the functions that this function overrides.
For example:

    typedef int INT;

    struct A {
        virtual void foo(int);
    };

    struct B : A {
        void foo(INT);
    };

will yield this message because A::foo is declared with a first
parameter of type int while the overridden function B::foo declared the
parameter with type INT, a type alias name difference.</c>
    </m>
    <m id="9287">
        <c>A cast was performed between a pointer to an object type and a pointer
to a character type. The actual pointer types are provided in the
message.</c>
    </m>
    <m id="9288">
        <c>An unnamed signed bit-field was declared with a single bit.</c>
    </m>
    <m id="9294">
        <c>This message is similar to 9094 but applies to differences between
overridden functions. In a declaration of a function, the return type
specified, while technically identical, uses a different type name than
was used for the declaration of one of the functions that this function
overrides. For example:

    typedef int INT;

    struct A {
        virtual int foo();
    };

    struct B : A {
        INT foo();
    };

will yield this message.</c>
    </m>
    <m id="9295">
        <c>This message is issued when a cast is used to convert between a pointer
to object type and a non-integer arithmetic MISRA C 2012 essential type.
For example:

    enum color { RED, GREEN, BLUE };
    void foo(int *pi) {
        enum color c = (enum color)pi;  // Note 9295
    }</c>
    </m>
    <m id="9401">
        <c>The specified function returns a pointer to void, which some consider to
be unsafe because it can compromise type safety.</c>
    </m>
    <m id="9402">
        <c>The specified function accepts a void pointer as an argument, which some
consider to be unsafe because such pointers can compromise type safety.</c>
    </m>
    <m id="9403">
        <c>A function has two consecutive parameters of the same (unqualified)
type. Functions that accept many arguments can be difficult to use
correctly as the chance of misordered arguments increases as the number
of parameters increases. When arguments are of different types,
misordered arguments are more likely to be detected by the compiler.
When consecutive parameters are of the same type, calls to the function
that accidentally transpose the arguments are less likely to be noticed.</c>
    </m>
    <m id="9404">
        <c>Given that destructors should never throw, declaring them as &apos;noexcept&apos;
is wise as it allows the compiler to ensure this is the case.</c>
    </m>
    <m id="9405">
        <c>Move constructors should not throw; declaring them as &apos;noexcept&apos; allows
the compiler to ensure this is the case.</c>
    </m>
    <m id="9406">
        <c>Move assignment functions should not throw; declaring them as &apos;noexcept&apos;
allows the compiler to ensure this is the case.</c>
    </m>
    <m id="9407">
        <c>A copy assignment operator was declared as virtual; this is rarely the
right thing to do.</c>
    </m>
    <m id="9408">
        <c>A copy assignment operator should take a const reference argument.</c>
    </m>
    <m id="9409">
        <c>A copy assignment operator should return a non-const lvalue-reference
type.</c>
    </m>
    <m id="9410">
        <c>A move assignment operator was declared as virtual, this is rarely the
right thing to do.</c>
    </m>
    <m id="9411">
        <c>A move assignment operator was declared whose argument is not a
non-const reference.</c>
    </m>
    <m id="9412">
        <c>A move assignment operator was declared that doesn&apos;t return a non-const
lvalue-reference type.</c>
    </m>
    <m id="9413">
        <c>A class contains data members declared with different access levels.</c>
    </m>
    <m id="9414">
        <c>If the operand of the typeid operator is an expression, it is not
usually evaluated. Using typeid with an expression that would have side
effects if it were evaluated could result in confusion about whether the
apparent side-effects will actually take place.</c>
    </m>
    <m id="9415">
        <c>Initializing an auto variable using list initialization can result in
unexpected and compiler-dependent results. Additionally, the rules
governing the type deduced when using list initialization with auto
variables changed in C++17 which can result in code that has different
meaning depending on the target language of the compiler. For example:

        auto j1{1};     // direct list initialization
                        // j1 is std::initializer_list&lt;int&gt; in C++11 and int in C++17

        auto j2 = {1};  // copy list initialization
                        // j2 is always std::initializer_list&lt;int&gt;

        auto j3 = 1;    // copy initialization - NOT list initialization
                        // j3 is always int

This message will be issued for the initialization of j1 and j2.
Avoiding list initialization for auto variables can prevent unintended
results. The string parameter is either &apos;direct&apos; or &apos;copy&apos; indicating
the type of list initialization employed (copy list initialization uses
an equal sign, direct list initialization does not).</c>
    </m>
    <m id="9416">
        <c>A typedef was used to define a type alias instead of a using alias.</c>
    </m>
    <m id="9417">
        <c>The specified data member of a class has an access level of protected.
Some authors suggest against using protected data members.</c>
    </m>
    <m id="9418">
        <c>Since C++11 it is possible to explicitly specify an underlying type for
enums and enum classes. This message is issued for enums that do not
explicitly specify an underlying type in their definition. This message
is not issued in C or C++03 modes.</c>
    </m>
    <m id="9419">
        <c>Scoped enumerations (those using enum class or enum struct) were
introduced in C++11 and limit the scope of the enumeration constants to
the enumeration. This message is issued for unscoped enums. This message
is not issued in C or C++03 modes.</c>
    </m>
    <m id="9420">
        <c>This message is issued when a bitfield is declared with a type that is
not an implementation-independent unsigned integral type. In particular,
the message is issued for bitfields with plain char, plain int, or
wchar_t types or types that are implicitly or explicitly signed such as
short and signed short. For bitfields of enumeration type, if the
underlying type of the enumeration is explicitly specified as an
unsigned type, the message is suppressed. As it is only possible to
specify an explicit underlying type for enumerations since C++11, the
message will be issued for all bitfields of enum type in C or C++03
modes.</c>
    </m>
    <m id="9421">
        <c>A virtual function that overrides a base class function was not declared
with at least one of override or final. This message is only emitted for
C++11 and higher. See also 1915 which is issued when an overriding
function is not specified with override, even if final is specified.</c>
    </m>
    <m id="9422">
        <c>A virtual function was declared without specifying exactly one of
virtual, override, or final. Some authors suggest that virtual should be
specified in the base class and that overriding functions should be
specified with either override or final and without a redundant virtual
specifier. This message is only issued for C++11 and higher.</c>
    </m>
    <m id="9432">
        <c>An interface is a class where 1) all non-static member functions (if
any) are public, virtual, and pure, and 2) all data members (if any) are
public, static (or thread_local), and constexpr (or const in C++ modes
prior to C++11). This message is issued when a class inherits from more
than one non-interface class. The list of non-interface bases are
provided in a supplemental message.</c>
    </m>
    <m id="9433">
        <c>This message is issued whenever a literal operator function declaration
is encountered. Literal operators introduce user-defined literal
suffixes that can be applied to certain types of literals. See also
message 9434 which is issued when a literal operator is invoked by a
user-defined literal.</c>
    </m>
    <m id="9434">
        <c>This message is issued when a user-defined literal is encountered. This
message is parameterized by the suffix used and can be suppressed for
individual suffixes using -estring. See also message 9433 which is
issued for the declaration of literal operator functions which introduce
user-defined suffixes.</c>
    </m>
    <m id="9435">
        <c>This message is issued when a friend declaration is encountered. The
string parameter is either symbol or type to indicate the kind of entity
declared as a friend. The first symbol parameter is the entity declared
as a friend unless the entity is a type in which case the parameter is
actually a type parameter. The last symbol is the class in which the
friend declaration appeared. Some authors suggest that friend
declarations reduce encapsulation and should be avoided.</c>
    </m>
    <m id="9436">
        <c>A symbol was declared with array type or reference to array type in a
C++ module. Because arrays are implicitly convertible to pointers and
don&apos;t maintain size information across such conversions, arrays are the
subject of various programming errors. Some authors suggest replacing
arrays with other container types such as std::array or std::vector.
This message is not issued for static constexpr class data members (or
static const data members in C++03 where constexpr is not available).</c>
    </m>
    <m id="9437">
        <c>This message is issued when a non-POD class is defined using the struct
keyword. Some authors suggest that non-POD types should be defined using
the class keyword which forces private default access control.</c>
    </m>
    <m id="9501">
        <c>A preprocessing directive appeared within the call to a function, for
example:

    void init_buffer(void *buffer) {
        memset(buffer, 0,
    #ifdef LARGE_BUFFER
        1024
    #else
        128
    #endif
        );
    }

The problem is that if memset is implemented as a macro, the presence of
the embedded preprocessor directives would invoke undefined behavior.
PC-lint Plus issues message 436 when a preprocessor directive appears
inside a macro invocation but message 9501 can be used to warn about
directives in function calls that may be implemented as macros in other
configurations or when compiled on other platforms.

One alternative is to move the directives outside the call, e.g.:

    void init_buffer(void *buffer) {
        const unsigned buf_size =
    #ifdef LARGE_BUFFER
        1024
    #else
        128
    #endif
        ;
        memset(buffer, 0, buf_size);
    }

This message isn&apos;t issued if the function name is surrounded by
parenthesis which suppresses the invocation of a potential macro by the
same name. This message is parameterized on the function being called
and can be enabled for specific functions using either +esym or +ecall.</c>
    </m>
    <m id="9502">
        <c>A macro definition appeared to contain multiple statements but was not
enclosed in a mono-carpic do/while loop. A macro is considered to
contain multiple statements if the replacement text contains one or more
semi-colons. A mono-carpic do/while loop is one that will be executed
exactly once. PC-lint Plus is specifically expecting a loop of the
following form:

    #define M(x) do { ... } while (0)

where 0 may be replaced by any integer literal with a zero value (0u,
0x0, etc.), the false keyword or a keyword that has been assigned the
same meaning as false with the -rw_asgn option, or an identifier whose
name is false, ignoring case.
A macro that expands to multiple statements may result in unintentional
interpretation during expansion. For example:

    #define ADJUST(a, b) a = (b); a++; b = 0

would not work as intended if used as:

    void foo(int a, int b) {
        if (a &gt;= b)
            ADJUST(a, b);
    }

which would expand to:

    void foo(int a, int b) {
        if (a &gt;= b)
            a = (b); a++; b = 0;
    }

where the last two statements would be unconditionally executed as they
are not part of the if statement. Simply wrapping the macro definition
in braces is not always sufficient:

    #define ADJUST(a, b) { a = (b); a++; b = 0; }

as this will prevent the macro from being usable in certain contexts,
e.g.:

    void foo(int a, int b) {
        if (a &gt;= b)
            ADJUST(a, b);
        else
            ADJUST(b, a);
    }

will result in a compile error as the else is not attached to the if
statement because of the semi-colon. Wrapping the replacement text in a
do/while (0) loop addresses all of the related issues:

    #define ADJUST(a, b) do { a = (b); a++; b = 0; } while (0)</c>
    </m>
    <m id="9901">
        <c>This message is emitted when a return semantic adds or updates value
tracking information for a return value of a function call either
because the semantic contains more specific information than was gleaned
from walking the body of the called function or because the fso flag was
set.</c>
    </m>
    <m id="9902">
        <c>This message is emitted when a return semantic is not applied to a
function call because the semantic does not provide any information that
was not already known from walking the call.</c>
    </m>
    <m id="9903">
        <c>This message shows the step-by-step evaluation of how an expression&apos;s
MISRA C 2012 essential type is calculated. See the f12 flag for details.</c>
    </m>
    <m id="9904">
        <c>This message is emitted every time a hookable event is reached in the
AST walking phase.</c>
    </m>
    <m id="9905">
	<c>
named __vt_assert, conventionally a typedef for void, this message will
be issued during Value Tracking if it does not appear to be guaranteed
that the subexpression is a non-zero integral value. This may occur
multiple times for the same expression during specific walks.</c>
    </m>
    <m id="9906">
	<c>
named __vt_alert, conventionally a typedef for void, this message will
be issued during Value Tracking parameterized by the value of the
subexpression as it would be displayed in a Value Tracking message. This
may occur multiple times for the same expression during specific walks.</c>
    </m>
</doc>